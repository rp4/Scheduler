"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/excel/parser.ts":
/*!*****************************!*\
  !*** ./lib/excel/parser.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseExcelFile: () => (/* binding */ parseExcelFile)\n/* harmony export */ });\n/* harmony import */ var xlsx__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! xlsx */ \"(app-pages-browser)/./node_modules/xlsx/xlsx.mjs\");\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/utils */ \"(app-pages-browser)/./lib/utils.ts\");\n/* harmony import */ var _barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! __barrel_optimize__?names=format,isValid,parse,startOfWeek!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/isValid.js\");\n/* harmony import */ var _barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! __barrel_optimize__?names=format,isValid,parse,startOfWeek!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/format.js\");\n/* harmony import */ var _barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! __barrel_optimize__?names=format,isValid,parse,startOfWeek!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/parse.js\");\n/* harmony import */ var _barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=format,isValid,parse,startOfWeek!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/startOfWeek.js\");\n\n\n\n// Function to normalize date to yyyy-MM-dd format (Monday of the week)\nfunction normalizeDateToMonday(dateValue) {\n    let parsedDate = null;\n    // Handle Date objects from Excel parsing\n    if (dateValue instanceof Date && (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_1__.isValid)(dateValue)) {\n        parsedDate = dateValue;\n        console.log(\"    \\uD83D\\uDCC5 Processing Date object: \".concat((0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_2__.format)(dateValue, 'yyyy-MM-dd')));\n    } else if (typeof dateValue === 'number' && dateValue > 0) {\n        parsedDate = new Date((dateValue - 25569) * 86400 * 1000);\n        console.log(\"    \\uD83D\\uDCC5 Excel number \".concat(dateValue, \" -> \").concat((0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_2__.format)(parsedDate, 'yyyy-MM-dd')));\n    } else if (typeof dateValue === 'string') {\n        const dateStr = dateValue.trim();\n        // Priority: yyyy-MM-dd format\n        if (/^\\d{4}-\\d{2}-\\d{2}/.test(dateStr)) {\n            const dateOnly = dateStr.split('T')[0];\n            parsedDate = (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_3__.parse)(dateOnly, 'yyyy-MM-dd', new Date());\n            if ((0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_1__.isValid)(parsedDate)) {\n                console.log(\"    \\uD83D\\uDCC5 Parsed yyyy-MM-dd: \".concat(dateOnly));\n            }\n        } else {\n            const formats = [\n                'MM/dd/yyyy',\n                'M/d/yyyy',\n                'MMM d yyyy',\n                'd-MMM-yyyy'\n            ];\n            for (const fmt of formats){\n                try {\n                    const parsed = (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_3__.parse)(dateStr, fmt, new Date());\n                    if ((0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_1__.isValid)(parsed)) {\n                        parsedDate = parsed;\n                        console.log(\"    \\uD83D\\uDCC5 Parsed \".concat(fmt, \": \").concat(dateStr, \" -> \").concat((0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_2__.format)(parsed, 'yyyy-MM-dd')));\n                        break;\n                    }\n                } catch (e) {}\n            }\n        }\n    }\n    // If we couldn't parse, use current date\n    if (!parsedDate || !(0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_1__.isValid)(parsedDate)) {\n        console.warn('    âš ï¸ Could not parse date: \"'.concat(dateValue, '\", using current date'));\n        parsedDate = new Date();\n    }\n    // Convert to Monday of that week\n    const monday = (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_4__.startOfWeek)(parsedDate, {\n        weekStartsOn: 1\n    });\n    const dateFormatted = (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_2__.format)(monday, 'yyyy-MM-dd');\n    const weekFormatted = (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_2__.format)(monday, 'MMM d').toUpperCase();\n    const dayName = (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_2__.format)(parsedDate, 'EEEE');\n    if (parsedDate.getDay() === 1) {\n        console.log(\"    âœ… Date is already Monday: \".concat(dateFormatted, ' -> Week: \"').concat(weekFormatted, '\"'));\n    } else {\n        console.log(\"    \\uD83D\\uDCC5 Converted \".concat(dayName, \" \").concat((0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_2__.format)(parsedDate, 'yyyy-MM-dd'), \" -> Monday: \").concat(dateFormatted, ' (Week: \"').concat(weekFormatted, '\")'));\n    }\n    return {\n        date: dateFormatted,\n        week: weekFormatted\n    };\n}\nasync function parseExcelFile(file) {\n    return new Promise((resolve, reject)=>{\n        const reader = new FileReader();\n        reader.onload = (e)=>{\n            try {\n                var _e_target;\n                console.log('ðŸ“Š Starting Excel parsing...');\n                const data = new Uint8Array((_e_target = e.target) === null || _e_target === void 0 ? void 0 : _e_target.result);\n                const workbook = xlsx__WEBPACK_IMPORTED_MODULE_5__.read(data, {\n                    type: 'array',\n                    cellDates: true\n                });\n                console.log('ðŸ“‹ Workbook sheets found:', Object.keys(workbook.Sheets));\n                const result = parseWorkbook(workbook);\n                console.log('âœ… Parsing complete:', {\n                    employees: result.employees.length,\n                    projects: result.projects.length,\n                    assignments: result.assignments.length,\n                    skills: result.skills.length,\n                    teams: result.teams.length\n                });\n                resolve(result);\n            } catch (error) {\n                console.error('âŒ Error parsing Excel:', error);\n                reject(error);\n            }\n        };\n        reader.onerror = ()=>reject(new Error('Failed to read file'));\n        reader.readAsArrayBuffer(file);\n    });\n}\nfunction parseWorkbook(workbook) {\n    const result = {\n        employees: [],\n        projects: [],\n        assignments: [],\n        skills: [],\n        teams: [\n            'All Teams'\n        ]\n    };\n    // Parse Employees sheet\n    if (workbook.Sheets['Employees']) {\n        const sheet = xlsx__WEBPACK_IMPORTED_MODULE_5__.utils.sheet_to_json(workbook.Sheets['Employees']);\n        result.employees = sheet.map((row)=>({\n                id: row.ID || row.id || (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.generateId)(),\n                name: row.Name || row.Employee || '',\n                email: row.Email || '',\n                maxHours: Number(row['Max Hours']) || 40,\n                team: row.Team || 'Default',\n                skills: parseSkills(row)\n            }));\n    }\n    // Parse Projects sheet\n    if (workbook.Sheets['Projects']) {\n        const sheet = xlsx__WEBPACK_IMPORTED_MODULE_5__.utils.sheet_to_json(workbook.Sheets['Projects']);\n        result.projects = sheet.map((row)=>({\n                id: row.ID || row.id || (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.generateId)(),\n                name: row.Name || row.Project || '',\n                startDate: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.parseDate)(row['Start Date']) || new Date(),\n                endDate: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.parseDate)(row['End Date']) || new Date(),\n                requiredSkills: row['Required Skills'] ? String(row['Required Skills']).split(',').map((s)=>s.trim()) : [],\n                portfolio: row.Portfolio || ''\n            }));\n    }\n    // Parse Assignments sheet\n    if (workbook.Sheets['Assignments']) {\n        console.log('ðŸ“… Parsing Assignments sheet...');\n        const sheet = xlsx__WEBPACK_IMPORTED_MODULE_5__.utils.sheet_to_json(workbook.Sheets['Assignments']);\n        console.log(\"  Found \".concat(sheet.length, \" assignment rows\"));\n        // Log first few rows for debugging\n        if (sheet.length > 0) {\n            console.log('  Sample assignment row:', sheet[0]);\n            console.log('  Assignment column headers:', Object.keys(sheet[0]));\n        }\n        result.assignments = sheet.map((row, index)=>{\n            // Check all possible column names for week/date\n            const rawDate = row.Week || row['Week'] || row.Date || row['Date'] || row.week || row.date;\n            const { date, week } = normalizeDateToMonday(rawDate);\n            // Parse hours with better handling\n            const rawHours = row.Hours || row['Hours'] || row.hours || 0;\n            const parsedHours = typeof rawHours === 'string' ? parseFloat(rawHours) || 0 : Number(rawHours) || 0;\n            const assignment = {\n                id: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.generateId)(),\n                employeeId: row['Employee ID'] || row.Employee || row['Employee'] || row['employee'] || '',\n                projectId: row['Project ID'] || row.Project || row['Project'] || row['project'] || '',\n                hours: parsedHours,\n                week: week,\n                date: date // New: Store full date in yyyy-MM-dd format\n            };\n            // Debug log for first few assignments\n            if (index < 3) {\n                console.log(\"  Assignment \".concat(index + 1, \":\"), {\n                    employeeId: assignment.employeeId,\n                    projectId: assignment.projectId,\n                    hours: \"\".concat(assignment.hours, ' (raw: \"').concat(rawHours, '\", type: ').concat(typeof rawHours, \")\"),\n                    rawDate: rawDate,\n                    storedDate: assignment.date,\n                    displayWeek: assignment.week,\n                    allColumns: Object.keys(row).join(', ')\n                });\n            }\n            return assignment;\n        });\n        console.log(\"  âœ“ Parsed \".concat(result.assignments.length, \" assignments\"));\n        console.log('  Unique weeks found:', [\n            ...new Set(result.assignments.map((a)=>a.week))\n        ]);\n    } else {\n        console.log('âš ï¸ No Assignments sheet found in workbook');\n    }\n    // Parse Skills sheet (optional)\n    if (workbook.Sheets['Skills']) {\n        const sheet = xlsx__WEBPACK_IMPORTED_MODULE_5__.utils.sheet_to_json(workbook.Sheets['Skills']);\n        const skillSet = new Set();\n        sheet.forEach((row)=>{\n            Object.keys(row).forEach((key)=>{\n                if (key !== 'Employee' && key !== 'ID' && key !== 'Name') {\n                    skillSet.add(key);\n                }\n            });\n        });\n        result.skills = Array.from(skillSet);\n    } else {\n        // Extract skills from employees\n        const skillSet = new Set();\n        result.employees.forEach((emp)=>{\n            Object.keys(emp.skills).forEach((skill)=>skillSet.add(skill));\n        });\n        result.skills = Array.from(skillSet);\n    }\n    // Extract teams\n    const teamSet = new Set([\n        'All Teams'\n    ]);\n    result.employees.forEach((emp)=>{\n        if (emp.team) teamSet.add(emp.team);\n    });\n    result.teams = Array.from(teamSet);\n    return result;\n}\nfunction parseSkills(row) {\n    const skills = {};\n    const excludeFields = [\n        'Name',\n        'Employee',\n        'Email',\n        'ID',\n        'id',\n        'Max Hours',\n        'Team'\n    ];\n    Object.keys(row).forEach((key)=>{\n        if (!excludeFields.includes(key)) {\n            const value = row[key];\n            if (value && value !== 'None' && value !== '') {\n                // Try to parse as proficiency level\n                if ([\n                    'Beginner',\n                    'Intermediate',\n                    'Expert'\n                ].includes(value)) {\n                    skills[key] = value;\n                } else if (typeof value === 'number') {\n                    // Convert numeric values to proficiency levels\n                    if (value >= 3) skills[key] = 'Expert';\n                    else if (value >= 2) skills[key] = 'Intermediate';\n                    else if (value >= 1) skills[key] = 'Beginner';\n                } else if (value) {\n                    // Default to Intermediate for any other non-empty value\n                    skills[key] = 'Intermediate';\n                }\n            }\n        }\n    });\n    return skills;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9leGNlbC9wYXJzZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUE0QjtBQUV1QztBQUNMO0FBRTlELHVFQUF1RTtBQUN2RSxTQUFTTyxzQkFBc0JDLFNBQWM7SUFDM0MsSUFBSUMsYUFBMEI7SUFFOUIseUNBQXlDO0lBQ3pDLElBQUlELHFCQUFxQkUsUUFBUUwseUdBQU9BLENBQUNHLFlBQVk7UUFDbkRDLGFBQWFEO1FBQ2JHLFFBQVFDLEdBQUcsQ0FBQyw0Q0FBa0UsT0FBaENULHdHQUFNQSxDQUFDSyxXQUFXO0lBQ2xFLE9BRUssSUFBSSxPQUFPQSxjQUFjLFlBQVlBLFlBQVksR0FBRztRQUN2REMsYUFBYSxJQUFJQyxLQUFLLENBQUNGLFlBQVksS0FBSSxJQUFLLFFBQVE7UUFDcERHLFFBQVFDLEdBQUcsQ0FBQyxpQ0FBdUNULE9BQWhCSyxXQUFVLFFBQXVDLE9BQWpDTCx3R0FBTUEsQ0FBQ00sWUFBWTtJQUN4RSxPQUVLLElBQUksT0FBT0QsY0FBYyxVQUFVO1FBQ3RDLE1BQU1LLFVBQVVMLFVBQVVNLElBQUk7UUFFOUIsOEJBQThCO1FBQzlCLElBQUkscUJBQXFCQyxJQUFJLENBQUNGLFVBQVU7WUFDdEMsTUFBTUcsV0FBV0gsUUFBUUksS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ3RDUixhQUFhTCx1R0FBS0EsQ0FBQ1ksVUFBVSxjQUFjLElBQUlOO1lBQy9DLElBQUlMLHlHQUFPQSxDQUFDSSxhQUFhO2dCQUN2QkUsUUFBUUMsR0FBRyxDQUFDLHVDQUFzQyxPQUFUSTtZQUMzQztRQUNGLE9BRUs7WUFDSCxNQUFNRSxVQUFVO2dCQUFDO2dCQUFjO2dCQUFZO2dCQUFjO2FBQWE7WUFDdEUsS0FBSyxNQUFNQyxPQUFPRCxRQUFTO2dCQUN6QixJQUFJO29CQUNGLE1BQU1FLFNBQVNoQix1R0FBS0EsQ0FBQ1MsU0FBU00sS0FBSyxJQUFJVDtvQkFDdkMsSUFBSUwseUdBQU9BLENBQUNlLFNBQVM7d0JB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TUFBTSxDQUFDa0QsSUFBSSxHQUFHUztnQkFDaEIsT0FBTyxJQUFJLE9BQU9BLFVBQVUsVUFBVTtvQkFDcEMsK0NBQStDO29CQUMvQyxJQUFJQSxTQUFTLEdBQUczRCxNQUFNLENBQUNrRCxJQUFJLEdBQUc7eUJBQ3pCLElBQUlTLFNBQVMsR0FBRzNELE1BQU0sQ0FBQ2tELElBQUksR0FBRzt5QkFDOUIsSUFBSVMsU0FBUyxHQUFHM0QsTUFBTSxDQUFDa0QsSUFBSSxHQUFHO2dCQUNyQyxPQUFPLElBQUlTLE9BQU87b0JBQ2hCLHdEQUF3RDtvQkFDeEQzRCxNQUFNLENBQUNrRCxJQUFJLEdBQUc7Z0JBQ2hCO1lBQ0Y7UUFDRjtJQUNGO0lBRUEsT0FBT2xEO0FBQ1QiLCJzb3VyY2VzIjpbIi9ob21lL3A0NzIvU2NoZWR1bGVyL2xpYi9leGNlbC9wYXJzZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgWExTWCBmcm9tICd4bHN4J1xuaW1wb3J0IHsgU2NoZWR1bGVEYXRhLCBFbXBsb3llZSwgUHJvamVjdCwgQXNzaWdubWVudCwgUHJvZmljaWVuY3lMZXZlbCB9IGZyb20gJ0AvdHlwZXMvc2NoZWR1bGUnXG5pbXBvcnQgeyBnZW5lcmF0ZUlkLCBwYXJzZURhdGUsIGdldEN1cnJlbnRXZWVrIH0gZnJvbSAnQC9saWIvdXRpbHMnXG5pbXBvcnQgeyBmb3JtYXQsIHBhcnNlLCBpc1ZhbGlkLCBzdGFydE9mV2VlayB9IGZyb20gJ2RhdGUtZm5zJ1xuXG4vLyBGdW5jdGlvbiB0byBub3JtYWxpemUgZGF0ZSB0byB5eXl5LU1NLWRkIGZvcm1hdCAoTW9uZGF5IG9mIHRoZSB3ZWVrKVxuZnVuY3Rpb24gbm9ybWFsaXplRGF0ZVRvTW9uZGF5KGRhdGVWYWx1ZTogYW55KTogeyBkYXRlOiBzdHJpbmcsIHdlZWs6IHN0cmluZyB9IHtcbiAgbGV0IHBhcnNlZERhdGU6IERhdGUgfCBudWxsID0gbnVsbFxuICBcbiAgLy8gSGFuZGxlIERhdGUgb2JqZWN0cyBmcm9tIEV4Y2VsIHBhcnNpbmdcbiAgaWYgKGRhdGVWYWx1ZSBpbnN0YW5jZW9mIERhdGUgJiYgaXNWYWxpZChkYXRlVmFsdWUpKSB7XG4gICAgcGFyc2VkRGF0ZSA9IGRhdGVWYWx1ZVxuICAgIGNvbnNvbGUubG9nKGAgICAg8J+ThSBQcm9jZXNzaW5nIERhdGUgb2JqZWN0OiAke2Zvcm1hdChkYXRlVmFsdWUsICd5eXl5LU1NLWRkJyl9YClcbiAgfVxuICAvLyBIYW5kbGUgRXhjZWwgZGF0ZSBudW1iZXJzXG4gIGVsc2UgaWYgKHR5cGVvZiBkYXRlVmFsdWUgPT09ICdudW1iZXInICYmIGRhdGVWYWx1ZSA+IDApIHtcbiAgICBwYXJzZWREYXRlID0gbmV3IERhdGUoKGRhdGVWYWx1ZSAtIDI1NTY5KSAqIDg2NDAwICogMTAwMClcbiAgICBjb25zb2xlLmxvZyhgICAgIPCfk4UgRXhjZWwgbnVtYmVyICR7ZGF0ZVZhbHVlfSAtPiAke2Zvcm1hdChwYXJzZWREYXRlLCAneXl5eS1NTS1kZCcpfWApXG4gIH1cbiAgLy8gSGFuZGxlIHN0cmluZyBkYXRlc1xuICBlbHNlIGlmICh0eXBlb2YgZGF0ZVZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IGRhdGVTdHIgPSBkYXRlVmFsdWUudHJpbSgpXG4gICAgXG4gICAgLy8gUHJpb3JpdHk6IHl5eXktTU0tZGQgZm9ybWF0XG4gICAgaWYgKC9eXFxkezR9LVxcZHsyfS1cXGR7Mn0vLnRlc3QoZGF0ZVN0cikpIHtcbiAgICAgIGNvbnN0IGRhdGVPbmx5ID0gZGF0ZVN0ci5zcGxpdCgnVCcpWzBdXG4gICAgICBwYXJzZWREYXRlID0gcGFyc2UoZGF0ZU9ubHksICd5eXl5LU1NLWRkJywgbmV3IERhdGUoKSlcbiAgICAgIGlmIChpc1ZhbGlkKHBhcnNlZERhdGUpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGAgICAg8J+ThSBQYXJzZWQgeXl5eS1NTS1kZDogJHtkYXRlT25seX1gKVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBUcnkgb3RoZXIgZm9ybWF0c1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgZm9ybWF0cyA9IFsnTU0vZGQveXl5eScsICdNL2QveXl5eScsICdNTU0gZCB5eXl5JywgJ2QtTU1NLXl5eXknXVxuICAgICAgZm9yIChjb25zdCBmbXQgb2YgZm9ybWF0cykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlKGRhdGVTdHIsIGZtdCwgbmV3IERhdGUoKSlcbiAgICAgICAgICBpZiAoaXNWYWxpZChwYXJzZWQpKSB7XG4gICAgICAgICAgICBwYXJzZWREYXRlID0gcGFyc2VkXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgICAgIPCfk4UgUGFyc2VkICR7Zm10fTogJHtkYXRlU3RyfSAtPiAke2Zvcm1hdChwYXJzZWQsICd5eXl5LU1NLWRkJyl9YClcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIHt9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICAvLyBJZiB3ZSBjb3VsZG4ndCBwYXJzZSwgdXNlIGN1cnJlbnQgZGF0ZVxuICBpZiAoIXBhcnNlZERhdGUgfHwgIWlzVmFsaWQocGFyc2VkRGF0ZSkpIHtcbiAgICBjb25zb2xlLndhcm4oYCAgICDimqDvuI8gQ291bGQgbm90IHBhcnNlIGRhdGU6IFwiJHtkYXRlVmFsdWV9XCIsIHVzaW5nIGN1cnJlbnQgZGF0ZWApXG4gICAgcGFyc2VkRGF0ZSA9IG5ldyBEYXRlKClcbiAgfVxuICBcbiAgLy8gQ29udmVydCB0byBNb25kYXkgb2YgdGhhdCB3ZWVrXG4gIGNvbnN0IG1vbmRheSA9IHN0YXJ0T2ZXZWVrKHBhcnNlZERhdGUsIHsgd2Vla1N0YXJ0c09uOiAxIH0pXG4gIGNvbnN0IGRhdGVGb3JtYXR0ZWQgPSBmb3JtYXQobW9uZGF5LCAneXl5eS1NTS1kZCcpXG4gIGNvbnN0IHdlZWtGb3JtYXR0ZWQgPSBmb3JtYXQobW9uZGF5LCAnTU1NIGQnKS50b1VwcGVyQ2FzZSgpXG4gIFxuICBjb25zdCBkYXlOYW1lID0gZm9ybWF0KHBhcnNlZERhdGUsICdFRUVFJylcbiAgaWYgKHBhcnNlZERhdGUuZ2V0RGF5KCkgPT09IDEpIHtcbiAgICBjb25zb2xlLmxvZyhgICAgIOKchSBEYXRlIGlzIGFscmVhZHkgTW9uZGF5OiAke2RhdGVGb3JtYXR0ZWR9IC0+IFdlZWs6IFwiJHt3ZWVrRm9ybWF0dGVkfVwiYClcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmxvZyhgICAgIPCfk4UgQ29udmVydGVkICR7ZGF5TmFtZX0gJHtmb3JtYXQocGFyc2VkRGF0ZSwgJ3l5eXktTU0tZGQnKX0gLT4gTW9uZGF5OiAke2RhdGVGb3JtYXR0ZWR9IChXZWVrOiBcIiR7d2Vla0Zvcm1hdHRlZH1cIilgKVxuICB9XG4gIFxuICByZXR1cm4geyBkYXRlOiBkYXRlRm9ybWF0dGVkLCB3ZWVrOiB3ZWVrRm9ybWF0dGVkIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBhcnNlRXhjZWxGaWxlKGZpbGU6IEZpbGUpOiBQcm9taXNlPFNjaGVkdWxlRGF0YT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICBcbiAgICByZWFkZXIub25sb2FkID0gKGUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5OKIFN0YXJ0aW5nIEV4Y2VsIHBhcnNpbmcuLi4nKVxuICAgICAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoZS50YXJnZXQ/LnJlc3VsdCBhcyBBcnJheUJ1ZmZlcilcbiAgICAgICAgY29uc3Qgd29ya2Jvb2sgPSBYTFNYLnJlYWQoZGF0YSwgeyB0eXBlOiAnYXJyYXknLCBjZWxsRGF0ZXM6IHRydWUgfSlcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfk4sgV29ya2Jvb2sgc2hlZXRzIGZvdW5kOicsIE9iamVjdC5rZXlzKHdvcmtib29rLlNoZWV0cykpXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlV29ya2Jvb2sod29ya2Jvb2spXG4gICAgICAgIGNvbnNvbGUubG9nKCfinIUgUGFyc2luZyBjb21wbGV0ZTonLCB7XG4gICAgICAgICAgZW1wbG95ZWVzOiByZXN1bHQuZW1wbG95ZWVzLmxlbmd0aCxcbiAgICAgICAgICBwcm9qZWN0czogcmVzdWx0LnByb2plY3RzLmxlbmd0aCxcbiAgICAgICAgICBhc3NpZ25tZW50czogcmVzdWx0LmFzc2lnbm1lbnRzLmxlbmd0aCxcbiAgICAgICAgICBza2lsbHM6IHJlc3VsdC5za2lsbHMubGVuZ3RoLFxuICAgICAgICAgIHRlYW1zOiByZXN1bHQudGVhbXMubGVuZ3RoXG4gICAgICAgIH0pXG4gICAgICAgIHJlc29sdmUocmVzdWx0KVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIHBhcnNpbmcgRXhjZWw6JywgZXJyb3IpXG4gICAgICAgIHJlamVjdChlcnJvcilcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmVhZGVyLm9uZXJyb3IgPSAoKSA9PiByZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gcmVhZCBmaWxlJykpXG4gICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGZpbGUpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHBhcnNlV29ya2Jvb2sod29ya2Jvb2s6IFhMU1guV29ya0Jvb2spOiBTY2hlZHVsZURhdGEge1xuICBjb25zdCByZXN1bHQ6IFNjaGVkdWxlRGF0YSA9IHtcbiAgICBlbXBsb3llZXM6IFtdLFxuICAgIHByb2plY3RzOiBbXSxcbiAgICBhc3NpZ25tZW50czogW10sXG4gICAgc2tpbGxzOiBbXSxcbiAgICB0ZWFtczogWydBbGwgVGVhbXMnXSxcbiAgfVxuXG4gIC8vIFBhcnNlIEVtcGxveWVlcyBzaGVldFxuICBpZiAod29ya2Jvb2suU2hlZXRzWydFbXBsb3llZXMnXSkge1xuICAgIGNvbnN0IHNoZWV0ID0gWExTWC51dGlscy5zaGVldF90b19qc29uKHdvcmtib29rLlNoZWV0c1snRW1wbG95ZWVzJ10pXG4gICAgcmVzdWx0LmVtcGxveWVlcyA9IHNoZWV0Lm1hcCgocm93OiBhbnkpID0+ICh7XG4gICAgICBpZDogcm93LklEIHx8IHJvdy5pZCB8fCBnZW5lcmF0ZUlkKCksXG4gICAgICBuYW1lOiByb3cuTmFtZSB8fCByb3cuRW1wbG95ZWUgfHwgJycsXG4gICAgICBlbWFpbDogcm93LkVtYWlsIHx8ICcnLFxuICAgICAgbWF4SG91cnM6IE51bWJlcihyb3dbJ01heCBIb3VycyddKSB8fCA0MCxcbiAgICAgIHRlYW06IHJvdy5UZWFtIHx8ICdEZWZhdWx0JyxcbiAgICAgIHNraWxsczogcGFyc2VTa2lsbHMocm93KSxcbiAgICB9KSlcbiAgfVxuXG4gIC8vIFBhcnNlIFByb2plY3RzIHNoZWV0XG4gIGlmICh3b3JrYm9vay5TaGVldHNbJ1Byb2plY3RzJ10pIHtcbiAgICBjb25zdCBzaGVldCA9IFhMU1gudXRpbHMuc2hlZXRfdG9fanNvbih3b3JrYm9vay5TaGVldHNbJ1Byb2plY3RzJ10pXG4gICAgcmVzdWx0LnByb2plY3RzID0gc2hlZXQubWFwKChyb3c6IGFueSkgPT4gKHtcbiAgICAgIGlkOiByb3cuSUQgfHwgcm93LmlkIHx8IGdlbmVyYXRlSWQoKSxcbiAgICAgIG5hbWU6IHJvdy5OYW1lIHx8IHJvdy5Qcm9qZWN0IHx8ICcnLFxuICAgICAgc3RhcnREYXRlOiBwYXJzZURhdGUocm93WydTdGFydCBEYXRlJ10pIHx8IG5ldyBEYXRlKCksXG4gICAgICBlbmREYXRlOiBwYXJzZURhdGUocm93WydFbmQgRGF0ZSddKSB8fCBuZXcgRGF0ZSgpLFxuICAgICAgcmVxdWlyZWRTa2lsbHM6IHJvd1snUmVxdWlyZWQgU2tpbGxzJ10gXG4gICAgICAgID8gU3RyaW5nKHJvd1snUmVxdWlyZWQgU2tpbGxzJ10pLnNwbGl0KCcsJykubWFwKHMgPT4gcy50cmltKCkpXG4gICAgICAgIDogW10sXG4gICAgICBwb3J0Zm9saW86IHJvdy5Qb3J0Zm9saW8gfHwgJycsXG4gICAgfSkpXG4gIH1cblxuICAvLyBQYXJzZSBBc3NpZ25tZW50cyBzaGVldFxuICBpZiAod29ya2Jvb2suU2hlZXRzWydBc3NpZ25tZW50cyddKSB7XG4gICAgY29uc29sZS5sb2coJ/Cfk4UgUGFyc2luZyBBc3NpZ25tZW50cyBzaGVldC4uLicpXG4gICAgY29uc3Qgc2hlZXQgPSBYTFNYLnV0aWxzLnNoZWV0X3RvX2pzb24od29ya2Jvb2suU2hlZXRzWydBc3NpZ25tZW50cyddKVxuICAgIGNvbnNvbGUubG9nKGAgIEZvdW5kICR7c2hlZXQubGVuZ3RofSBhc3NpZ25tZW50IHJvd3NgKVxuICAgIFxuICAgIC8vIExvZyBmaXJzdCBmZXcgcm93cyBmb3IgZGVidWdnaW5nXG4gICAgaWYgKHNoZWV0Lmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKCcgIFNhbXBsZSBhc3NpZ25tZW50IHJvdzonLCBzaGVldFswXSlcbiAgICAgIGNvbnNvbGUubG9nKCcgIEFzc2lnbm1lbnQgY29sdW1uIGhlYWRlcnM6JywgT2JqZWN0LmtleXMoc2hlZXRbMF0pKVxuICAgIH1cbiAgICBcbiAgICByZXN1bHQuYXNzaWdubWVudHMgPSBzaGVldC5tYXAoKHJvdzogYW55LCBpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAvLyBDaGVjayBhbGwgcG9zc2libGUgY29sdW1uIG5hbWVzIGZvciB3ZWVrL2RhdGVcbiAgICAgIGNvbnN0IHJhd0RhdGUgPSByb3cuV2VlayB8fCByb3dbJ1dlZWsnXSB8fCByb3cuRGF0ZSB8fCByb3dbJ0RhdGUnXSB8fCByb3cud2VlayB8fCByb3cuZGF0ZVxuICAgICAgY29uc3QgeyBkYXRlLCB3ZWVrIH0gPSBub3JtYWxpemVEYXRlVG9Nb25kYXkocmF3RGF0ZSlcbiAgICAgIFxuICAgICAgLy8gUGFyc2UgaG91cnMgd2l0aCBiZXR0ZXIgaGFuZGxpbmdcbiAgICAgIGNvbnN0IHJhd0hvdXJzID0gcm93LkhvdXJzIHx8IHJvd1snSG91cnMnXSB8fCByb3cuaG91cnMgfHwgMFxuICAgICAgY29uc3QgcGFyc2VkSG91cnMgPSB0eXBlb2YgcmF3SG91cnMgPT09ICdzdHJpbmcnID8gcGFyc2VGbG9hdChyYXdIb3VycykgfHwgMCA6IE51bWJlcihyYXdIb3VycykgfHwgMFxuICAgICAgXG4gICAgICBjb25zdCBhc3NpZ25tZW50OiBBc3NpZ25tZW50ID0ge1xuICAgICAgICBpZDogZ2VuZXJhdGVJZCgpLFxuICAgICAgICBlbXBsb3llZUlkOiByb3dbJ0VtcGxveWVlIElEJ10gfHwgcm93LkVtcGxveWVlIHx8IHJvd1snRW1wbG95ZWUnXSB8fCByb3dbJ2VtcGxveWVlJ10gfHwgJycsXG4gICAgICAgIHByb2plY3RJZDogcm93WydQcm9qZWN0IElEJ10gfHwgcm93LlByb2plY3QgfHwgcm93WydQcm9qZWN0J10gfHwgcm93Wydwcm9qZWN0J10gfHwgJycsXG4gICAgICAgIGhvdXJzOiBwYXJzZWRIb3VycyxcbiAgICAgICAgd2Vlazogd2VlaywgIC8vIEtlZXAgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAgIGRhdGU6IGRhdGUgICAvLyBOZXc6IFN0b3JlIGZ1bGwgZGF0ZSBpbiB5eXl5LU1NLWRkIGZvcm1hdFxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBEZWJ1ZyBsb2cgZm9yIGZpcnN0IGZldyBhc3NpZ25tZW50c1xuICAgICAgaWYgKGluZGV4IDwgMykge1xuICAgICAgICBjb25zb2xlLmxvZyhgICBBc3NpZ25tZW50ICR7aW5kZXggKyAxfTpgLCB7XG4gICAgICAgICAgZW1wbG95ZWVJZDogYXNzaWdubWVudC5lbXBsb3llZUlkLFxuICAgICAgICAgIHByb2plY3RJZDogYXNzaWdubWVudC5wcm9qZWN0SWQsXG4gICAgICAgICAgaG91cnM6IGAke2Fzc2lnbm1lbnQuaG91cnN9IChyYXc6IFwiJHtyYXdIb3Vyc31cIiwgdHlwZTogJHt0eXBlb2YgcmF3SG91cnN9KWAsXG4gICAgICAgICAgcmF3RGF0ZTogcmF3RGF0ZSxcbiAgICAgICAgICBzdG9yZWREYXRlOiBhc3NpZ25tZW50LmRhdGUsXG4gICAgICAgICAgZGlzcGxheVdlZWs6IGFzc2lnbm1lbnQud2VlayxcbiAgICAgICAgICBhbGxDb2x1bW5zOiBPYmplY3Qua2V5cyhyb3cpLmpvaW4oJywgJylcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIGFzc2lnbm1lbnRcbiAgICB9KVxuICAgIFxuICAgIGNvbnNvbGUubG9nKGAgIOKckyBQYXJzZWQgJHtyZXN1bHQuYXNzaWdubWVudHMubGVuZ3RofSBhc3NpZ25tZW50c2ApXG4gICAgY29uc29sZS5sb2coJyAgVW5pcXVlIHdlZWtzIGZvdW5kOicsIFsuLi5uZXcgU2V0KHJlc3VsdC5hc3NpZ25tZW50cy5tYXAoYSA9PiBhLndlZWspKV0pXG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5sb2coJ+KaoO+4jyBObyBBc3NpZ25tZW50cyBzaGVldCBmb3VuZCBpbiB3b3JrYm9vaycpXG4gIH1cblxuICAvLyBQYXJzZSBTa2lsbHMgc2hlZXQgKG9wdGlvbmFsKVxuICBpZiAod29ya2Jvb2suU2hlZXRzWydTa2lsbHMnXSkge1xuICAgIGNvbnN0IHNoZWV0ID0gWExTWC51dGlscy5zaGVldF90b19qc29uKHdvcmtib29rLlNoZWV0c1snU2tpbGxzJ10pXG4gICAgY29uc3Qgc2tpbGxTZXQgPSBuZXcgU2V0PHN0cmluZz4oKVxuICAgIFxuICAgIHNoZWV0LmZvckVhY2goKHJvdzogYW55KSA9PiB7XG4gICAgICBPYmplY3Qua2V5cyhyb3cpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgaWYgKGtleSAhPT0gJ0VtcGxveWVlJyAmJiBrZXkgIT09ICdJRCcgJiYga2V5ICE9PSAnTmFtZScpIHtcbiAgICAgICAgICBza2lsbFNldC5hZGQoa2V5KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gICAgXG4gICAgcmVzdWx0LnNraWxscyA9IEFycmF5LmZyb20oc2tpbGxTZXQpXG4gIH0gZWxzZSB7XG4gICAgLy8gRXh0cmFjdCBza2lsbHMgZnJvbSBlbXBsb3llZXNcbiAgICBjb25zdCBza2lsbFNldCA9IG5ldyBTZXQ8c3RyaW5nPigpXG4gICAgcmVzdWx0LmVtcGxveWVlcy5mb3JFYWNoKGVtcCA9PiB7XG4gICAgICBPYmplY3Qua2V5cyhlbXAuc2tpbGxzKS5mb3JFYWNoKHNraWxsID0+IHNraWxsU2V0LmFkZChza2lsbCkpXG4gICAgfSlcbiAgICByZXN1bHQuc2tpbGxzID0gQXJyYXkuZnJvbShza2lsbFNldClcbiAgfVxuXG4gIC8vIEV4dHJhY3QgdGVhbXNcbiAgY29uc3QgdGVhbVNldCA9IG5ldyBTZXQoWydBbGwgVGVhbXMnXSlcbiAgcmVzdWx0LmVtcGxveWVlcy5mb3JFYWNoKGVtcCA9PiB7XG4gICAgaWYgKGVtcC50ZWFtKSB0ZWFtU2V0LmFkZChlbXAudGVhbSlcbiAgfSlcbiAgcmVzdWx0LnRlYW1zID0gQXJyYXkuZnJvbSh0ZWFtU2V0KVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gcGFyc2VTa2lsbHMocm93OiBhbnkpOiBSZWNvcmQ8c3RyaW5nLCBQcm9maWNpZW5jeUxldmVsPiB7XG4gIGNvbnN0IHNraWxsczogUmVjb3JkPHN0cmluZywgUHJvZmljaWVuY3lMZXZlbD4gPSB7fVxuICBjb25zdCBleGNsdWRlRmllbGRzID0gWydOYW1lJywgJ0VtcGxveWVlJywgJ0VtYWlsJywgJ0lEJywgJ2lkJywgJ01heCBIb3VycycsICdUZWFtJ11cbiAgXG4gIE9iamVjdC5rZXlzKHJvdykuZm9yRWFjaChrZXkgPT4ge1xuICAgIGlmICghZXhjbHVkZUZpZWxkcy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHJvd1trZXldXG4gICAgICBpZiAodmFsdWUgJiYgdmFsdWUgIT09ICdOb25lJyAmJiB2YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgLy8gVHJ5IHRvIHBhcnNlIGFzIHByb2ZpY2llbmN5IGxldmVsXG4gICAgICAgIGlmIChbJ0JlZ2lubmVyJywgJ0ludGVybWVkaWF0ZScsICdFeHBlcnQnXS5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgICAgICBza2lsbHNba2V5XSA9IHZhbHVlIGFzIFByb2ZpY2llbmN5TGV2ZWxcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgLy8gQ29udmVydCBudW1lcmljIHZhbHVlcyB0byBwcm9maWNpZW5jeSBsZXZlbHNcbiAgICAgICAgICBpZiAodmFsdWUgPj0gMykgc2tpbGxzW2tleV0gPSAnRXhwZXJ0J1xuICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID49IDIpIHNraWxsc1trZXldID0gJ0ludGVybWVkaWF0ZSdcbiAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA+PSAxKSBza2lsbHNba2V5XSA9ICdCZWdpbm5lcidcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICAgIC8vIERlZmF1bHQgdG8gSW50ZXJtZWRpYXRlIGZvciBhbnkgb3RoZXIgbm9uLWVtcHR5IHZhbHVlXG4gICAgICAgICAgc2tpbGxzW2tleV0gPSAnSW50ZXJtZWRpYXRlJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KVxuICBcbiAgcmV0dXJuIHNraWxsc1xufSJdLCJuYW1lcyI6WyJYTFNYIiwiZ2VuZXJhdGVJZCIsInBhcnNlRGF0ZSIsImZvcm1hdCIsInBhcnNlIiwiaXNWYWxpZCIsInN0YXJ0T2ZXZWVrIiwibm9ybWFsaXplRGF0ZVRvTW9uZGF5IiwiZGF0ZVZhbHVlIiwicGFyc2VkRGF0ZSIsIkRhdGUiLCJjb25zb2xlIiwibG9nIiwiZGF0ZVN0ciIsInRyaW0iLCJ0ZXN0IiwiZGF0ZU9ubHkiLCJzcGxpdCIsImZvcm1hdHMiLCJmbXQiLCJwYXJzZWQiLCJ3YXJuIiwibW9uZGF5Iiwid2Vla1N0YXJ0c09uIiwiZGF0ZUZvcm1hdHRlZCIsIndlZWtGb3JtYXR0ZWQiLCJ0b1VwcGVyQ2FzZSIsImRheU5hbWUiLCJnZXREYXkiLCJkYXRlIiwid2VlayIsInBhcnNlRXhjZWxGaWxlIiwiZmlsZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicmVhZGVyIiwiRmlsZVJlYWRlciIsIm9ubG9hZCIsImUiLCJkYXRhIiwiVWludDhBcnJheSIsInRhcmdldCIsInJlc3VsdCIsIndvcmtib29rIiwicmVhZCIsInR5cGUiLCJjZWxsRGF0ZXMiLCJPYmplY3QiLCJrZXlzIiwiU2hlZXRzIiwicGFyc2VXb3JrYm9vayIsImVtcGxveWVlcyIsImxlbmd0aCIsInByb2plY3RzIiwiYXNzaWdubWVudHMiLCJza2lsbHMiLCJ0ZWFtcyIsImVycm9yIiwib25lcnJvciIsIkVycm9yIiwicmVhZEFzQXJyYXlCdWZmZXIiLCJzaGVldCIsInV0aWxzIiwic2hlZXRfdG9fanNvbiIsIm1hcCIsInJvdyIsImlkIiwiSUQiLCJuYW1lIiwiTmFtZSIsIkVtcGxveWVlIiwiZW1haWwiLCJFbWFpbCIsIm1heEhvdXJzIiwiTnVtYmVyIiwidGVhbSIsIlRlYW0iLCJwYXJzZVNraWxscyIsIlByb2plY3QiLCJzdGFydERhdGUiLCJlbmREYXRlIiwicmVxdWlyZWRTa2lsbHMiLCJTdHJpbmciLCJzIiwicG9ydGZvbGlvIiwiUG9ydGZvbGlvIiwiaW5kZXgiLCJyYXdEYXRlIiwiV2VlayIsInJhd0hvdXJzIiwiSG91cnMiLCJob3VycyIsInBhcnNlZEhvdXJzIiwicGFyc2VGbG9hdCIsImFzc2lnbm1lbnQiLCJlbXBsb3llZUlkIiwicHJvamVjdElkIiwic3RvcmVkRGF0ZSIsImRpc3BsYXlXZWVrIiwiYWxsQ29sdW1ucyIsImpvaW4iLCJTZXQiLCJhIiwic2tpbGxTZXQiLCJmb3JFYWNoIiwia2V5IiwiYWRkIiwiQXJyYXkiLCJmcm9tIiwiZW1wIiwic2tpbGwiLCJ0ZWFtU2V0IiwiZXhjbHVkZUZpZWxkcyIsImluY2x1ZGVzIiwidmFsdWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/excel/parser.ts\n"));

/***/ })

});