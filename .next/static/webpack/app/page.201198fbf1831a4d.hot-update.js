"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/excel/parser.ts":
/*!*****************************!*\
  !*** ./lib/excel/parser.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseExcelFile: () => (/* binding */ parseExcelFile)\n/* harmony export */ });\n/* harmony import */ var xlsx__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! xlsx */ \"(app-pages-browser)/./node_modules/xlsx/xlsx.mjs\");\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/utils */ \"(app-pages-browser)/./lib/utils.ts\");\n/* harmony import */ var _barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! __barrel_optimize__?names=format,isValid,parse,startOfWeek!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/isValid.js\");\n/* harmony import */ var _barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! __barrel_optimize__?names=format,isValid,parse,startOfWeek!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/format.js\");\n/* harmony import */ var _barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! __barrel_optimize__?names=format,isValid,parse,startOfWeek!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/parse.js\");\n/* harmony import */ var _barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=format,isValid,parse,startOfWeek!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/startOfWeek.js\");\n\n\n\n// Function to normalize date to yyyy-MM-dd format (Monday of the week)\nfunction normalizeDateToMonday(dateValue) {\n    let parsedDate = null;\n    // Handle Date objects from Excel parsing\n    if (dateValue instanceof Date && (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_1__.isValid)(dateValue)) {\n        parsedDate = dateValue;\n        console.log(\"    \\uD83D\\uDCC5 Processing Date object: \".concat((0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_2__.format)(dateValue, 'yyyy-MM-dd')));\n    } else if (typeof dateValue === 'number' && dateValue > 0) {\n        parsedDate = new Date((dateValue - 25569) * 86400 * 1000);\n        console.log(\"    \\uD83D\\uDCC5 Excel number \".concat(dateValue, \" -> \").concat((0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_2__.format)(parsedDate, 'yyyy-MM-dd')));\n    } else if (typeof dateValue === 'string') {\n        const dateStr = dateValue.trim();\n        // Priority: yyyy-MM-dd format\n        if (/^\\d{4}-\\d{2}-\\d{2}/.test(dateStr)) {\n            const dateOnly = dateStr.split('T')[0];\n            parsedDate = (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_3__.parse)(dateOnly, 'yyyy-MM-dd', new Date());\n            if ((0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_1__.isValid)(parsedDate)) {\n                console.log(\"    \\uD83D\\uDCC5 Parsed yyyy-MM-dd: \".concat(dateOnly));\n            }\n        } else {\n            const formats = [\n                'MM/dd/yyyy',\n                'M/d/yyyy',\n                'MMM d yyyy',\n                'd-MMM-yyyy'\n            ];\n            for (const fmt of formats){\n                try {\n                    const parsed = (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_3__.parse)(dateStr, fmt, new Date());\n                    if ((0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_1__.isValid)(parsed)) {\n                        parsedDate = parsed;\n                        console.log(\"    \\uD83D\\uDCC5 Parsed \".concat(fmt, \": \").concat(dateStr, \" -> \").concat((0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_2__.format)(parsed, 'yyyy-MM-dd')));\n                        break;\n                    }\n                } catch (e) {}\n            }\n        }\n    }\n    // If we couldn't parse, use current date\n    if (!parsedDate || !(0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_1__.isValid)(parsedDate)) {\n        console.warn('    âš ï¸ Could not parse date: \"'.concat(dateValue, '\", using current date'));\n        parsedDate = new Date();\n    }\n    // Convert to Monday of that week\n    const monday = (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_4__.startOfWeek)(parsedDate, {\n        weekStartsOn: 1\n    });\n    const dateFormatted = (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_2__.format)(monday, 'yyyy-MM-dd');\n    const weekFormatted = (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_2__.format)(monday, 'MMM d').toUpperCase();\n    const dayName = (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_2__.format)(parsedDate, 'EEEE');\n    if (parsedDate.getDay() === 1) {\n        console.log(\"    âœ… Date is already Monday: \".concat(dateFormatted, ' -> Week: \"').concat(weekFormatted, '\"'));\n    } else {\n        console.log(\"    \\uD83D\\uDCC5 Converted \".concat(dayName, \" \").concat((0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_2__.format)(parsedDate, 'yyyy-MM-dd'), \" -> Monday: \").concat(dateFormatted, ' (Week: \"').concat(weekFormatted, '\")'));\n    }\n    return {\n        date: dateFormatted,\n        week: weekFormatted\n    };\n}\nasync function parseExcelFile(file) {\n    return new Promise((resolve, reject)=>{\n        const reader = new FileReader();\n        reader.onload = (e)=>{\n            try {\n                var _e_target;\n                console.log('ðŸ“Š Starting Excel parsing...');\n                const data = new Uint8Array((_e_target = e.target) === null || _e_target === void 0 ? void 0 : _e_target.result);\n                const workbook = xlsx__WEBPACK_IMPORTED_MODULE_5__.read(data, {\n                    type: 'array',\n                    cellDates: true\n                });\n                console.log('ðŸ“‹ Workbook sheets found:', Object.keys(workbook.Sheets));\n                const result = parseWorkbook(workbook);\n                console.log('âœ… Parsing complete:', {\n                    employees: result.employees.length,\n                    projects: result.projects.length,\n                    assignments: result.assignments.length,\n                    skills: result.skills.length,\n                    teams: result.teams.length\n                });\n                resolve(result);\n            } catch (error) {\n                console.error('âŒ Error parsing Excel:', error);\n                reject(error);\n            }\n        };\n        reader.onerror = ()=>reject(new Error('Failed to read file'));\n        reader.readAsArrayBuffer(file);\n    });\n}\nfunction parseWorkbook(workbook) {\n    const result = {\n        employees: [],\n        projects: [],\n        assignments: [],\n        skills: [],\n        teams: [\n            'All Teams'\n        ]\n    };\n    // Parse Employees sheet\n    if (workbook.Sheets['Employees']) {\n        const sheet = xlsx__WEBPACK_IMPORTED_MODULE_5__.utils.sheet_to_json(workbook.Sheets['Employees']);\n        result.employees = sheet.map((row)=>({\n                id: row.ID || row.id || (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.generateId)(),\n                name: row.Name || row.Employee || '',\n                email: row.Email || '',\n                maxHours: Number(row['Max Hours']) || 40,\n                team: row.Team || 'Default',\n                skills: parseSkills(row)\n            }));\n    }\n    // Parse Projects sheet\n    if (workbook.Sheets['Projects']) {\n        const sheet = xlsx__WEBPACK_IMPORTED_MODULE_5__.utils.sheet_to_json(workbook.Sheets['Projects']);\n        result.projects = sheet.map((row)=>({\n                id: row.ID || row.id || (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.generateId)(),\n                name: row.Name || row.Project || '',\n                startDate: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.parseDate)(row['Start Date']) || new Date(),\n                endDate: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.parseDate)(row['End Date']) || new Date(),\n                requiredSkills: row['Required Skills'] ? String(row['Required Skills']).split(',').map((s)=>s.trim()) : [],\n                portfolio: row.Portfolio || ''\n            }));\n    }\n    // Parse Assignments sheet\n    if (workbook.Sheets['Assignments']) {\n        console.log('ðŸ“… Parsing Assignments sheet...');\n        const sheet = xlsx__WEBPACK_IMPORTED_MODULE_5__.utils.sheet_to_json(workbook.Sheets['Assignments']);\n        console.log(\"  Found \".concat(sheet.length, \" assignment rows\"));\n        // Log first few rows for debugging\n        if (sheet.length > 0) {\n            console.log('  Sample assignment row:', sheet[0]);\n            console.log('  Assignment column headers:', Object.keys(sheet[0]));\n        }\n        // Check if this is pivot-style format (columns are dates)\n        const firstRow = sheet[0] || {};\n        const columns = Object.keys(firstRow);\n        const dateColumns = columns.filter((col)=>{\n            // Check if column name looks like a date\n            return /^\\d{4}-\\d{2}-\\d{2}/.test(col) || /^\\d{1,2}\\/\\d{1,2}\\/\\d{4}/.test(col) || /^[A-Z][a-z]{2}\\s+\\d{1,2}/.test(col);\n        });\n        if (dateColumns.length > 0) {\n            // Pivot format: Each row is employee-project, columns are week dates\n            console.log('  ðŸ“Š Detected pivot-style format with date columns:', dateColumns.slice(0, 3));\n            result.assignments = [];\n            sheet.forEach((row, rowIndex)=>{\n                const employeeId = row.Employee || row['Employee'] || row['Employee ID'] || '';\n                const projectId = row.Project || row['Project'] || row['Project ID'] || '';\n                if (!employeeId || !projectId) {\n                    console.log(\"  âš ï¸ Skipping row \".concat(rowIndex + 1, \": missing employee or project\"));\n                    return;\n                }\n                // Process each date column\n                dateColumns.forEach((dateCol)=>{\n                    const hours = row[dateCol];\n                    if (hours && Number(hours) > 0) {\n                        const { date, week } = normalizeDateToMonday(dateCol);\n                        const assignment = {\n                            id: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.generateId)(),\n                            employeeId: employeeId,\n                            projectId: projectId,\n                            hours: Number(hours),\n                            week: week,\n                            date: date\n                        };\n                        result.assignments.push(assignment);\n                        // Debug first few\n                        if (result.assignments.length <= 3) {\n                            console.log(\"  Assignment \".concat(result.assignments.length, \":\"), {\n                                employee: employeeId,\n                                project: projectId,\n                                date: date,\n                                week: week,\n                                hours: hours\n                            });\n                        }\n                    }\n                });\n            });\n            console.log(\"  âœ“ Converted pivot format to \".concat(result.assignments.length, \" assignments\"));\n        } else {\n            // Traditional format: Each row is one assignment\n            result.assignments = sheet.map((row, index)=>{\n                // Check all possible column names for week/date\n                const rawDate = row.Week || row['Week'] || row.Date || row['Date'] || row.week || row.date;\n                const { date, week } = normalizeDateToMonday(rawDate);\n                // Parse hours with better handling\n                const rawHours = row.Hours || row['Hours'] || row.hours || 0;\n                const parsedHours = typeof rawHours === 'string' ? parseFloat(rawHours) || 0 : Number(rawHours) || 0;\n                const assignment = {\n                    id: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.generateId)(),\n                    employeeId: row['Employee ID'] || row.Employee || row['Employee'] || row['employee'] || '',\n                    projectId: row['Project ID'] || row.Project || row['Project'] || row['project'] || '',\n                    hours: parsedHours,\n                    week: week,\n                    date: date // New: Store full date in yyyy-MM-dd format\n                };\n                // Debug log for first few assignments\n                if (index < 3) {\n                    console.log(\"  Assignment \".concat(index + 1, \":\"), {\n                        employeeId: assignment.employeeId,\n                        projectId: assignment.projectId,\n                        hours: \"\".concat(assignment.hours, ' (raw: \"').concat(rawHours, '\", type: ').concat(typeof rawHours, \")\"),\n                        rawDate: rawDate,\n                        storedDate: assignment.date,\n                        displayWeek: assignment.week,\n                        allColumns: Object.keys(row).join(', ')\n                    });\n                }\n                return assignment;\n            });\n            console.log(\"  âœ“ Parsed \".concat(result.assignments.length, \" assignments\"));\n        }\n        console.log('  Unique weeks found:', [\n            ...new Set(result.assignments.map((a)=>a.week))\n        ]);\n    } else {\n        console.log('âš ï¸ No Assignments sheet found in workbook');\n    }\n    // Parse Skills sheet (optional)\n    if (workbook.Sheets['Skills']) {\n        const sheet = xlsx__WEBPACK_IMPORTED_MODULE_5__.utils.sheet_to_json(workbook.Sheets['Skills']);\n        const skillSet = new Set();\n        sheet.forEach((row)=>{\n            Object.keys(row).forEach((key)=>{\n                if (key !== 'Employee' && key !== 'ID' && key !== 'Name') {\n                    skillSet.add(key);\n                }\n            });\n        });\n        result.skills = Array.from(skillSet);\n    } else {\n        // Extract skills from employees\n        const skillSet = new Set();\n        result.employees.forEach((emp)=>{\n            Object.keys(emp.skills).forEach((skill)=>skillSet.add(skill));\n        });\n        result.skills = Array.from(skillSet);\n    }\n    // Extract teams\n    const teamSet = new Set([\n        'All Teams'\n    ]);\n    result.employees.forEach((emp)=>{\n        if (emp.team) teamSet.add(emp.team);\n    });\n    result.teams = Array.from(teamSet);\n    return result;\n}\nfunction parseSkills(row) {\n    const skills = {};\n    const excludeFields = [\n        'Name',\n        'Employee',\n        'Email',\n        'ID',\n        'id',\n        'Max Hours',\n        'Team'\n    ];\n    Object.keys(row).forEach((key)=>{\n        if (!excludeFields.includes(key)) {\n            const value = row[key];\n            if (value && value !== 'None' && value !== '') {\n                // Try to parse as proficiency level\n                if ([\n                    'Beginner',\n                    'Intermediate',\n                    'Expert'\n                ].includes(value)) {\n                    skills[key] = value;\n                } else if (typeof value === 'number') {\n                    // Convert numeric values to proficiency levels\n                    if (value >= 3) skills[key] = 'Expert';\n                    else if (value >= 2) skills[key] = 'Intermediate';\n                    else if (value >= 1) skills[key] = 'Beginner';\n                } else if (value) {\n                    // Default to Intermediate for any other non-empty value\n                    skills[key] = 'Intermediate';\n                }\n            }\n        }\n    });\n    return skills;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9leGNlbC9wYXJzZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUE0QjtBQUV1QztBQUNMO0FBRTlELHVFQUF1RTtBQUN2RSxTQUFTTyxzQkFBc0JDLFNBQWM7SUFDM0MsSUFBSUMsYUFBMEI7SUFFOUIseUNBQXlDO0lBQ3pDLElBQUlELHFCQUFxQkUsUUFBUUwseUdBQU9BLENBQUNHLFlBQVk7UUFDbkRDLGFBQWFEO1FBQ2JHLFFBQVFDLEdBQUcsQ0FBQyw0Q0FBa0UsT0FBaENULHdHQUFNQSxDQUFDSyxXQUFXO0lBQ2xFLE9BRUssSUFBSSxPQUFPQSxjQUFjLFlBQVlBLFlBQVksR0FBRztRQUN2REMsYUFBYSxJQUFJQyxLQUFLLENBQUNGLFlBQVksS0FBSSxJQUFLLFFBQVE7UUFDcERHLFFBQVFDLEdBQUcsQ0FBQyxpQ0FBdUNULE9BQWhCSyxXQUFVLFFBQXVDLE9BQWpDTCx3R0FBTUEsQ0FBQ00sWUFBWTtJQUN4RSxPQUVLLElBQUksT0FBT0QsY0FBYyxVQUFVO1FBQ3RDLE1BQU1LLFVBQVVMLFVBQVVNLElBQUk7UUFFOUIsOEJBQThCO1FBQzlCLElBQUkscUJBQXFCQyxJQUFJLENBQUNGLFVBQVU7WUFDdEMsTUFBTUcsV0FBV0gsUUFBUUksS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ3RDUixhQUFhTCx1R0FBS0EsQ0FBQ1ksVUFBVSxjQUFjLElBQUlOO1lBQy9DLElBQUlMLHlHQUFPQSxDQUFDSSxhQUFhO2dCQUN2QkUsUUFBUUMsR0FBRyxDQUFDLHVDQUFzQyxPQUFUSTtZQUMzQztRQUNGLE9BRUs7WUFDSCxNQUFNRSxVQUFVO2dCQUFDO2dCQUFjO2dCQUFZO2dCQUFjO2FBQWE7WUFDdEUsS0FBSyxNQUFNQyxPQUFPRCxRQUFTO2dCQUN6QixJQUFJO29CQUNGLE1BQU1FLFNBQVNoQix1R0FBS0EsQ0FBQ1MsU0FBU00sS0FBSyxJQUFJVDtvQkFDdkMsSUFBSUwseUdBQU9BLENBQUNlLFNBQVM7d0JB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Q0FBQ0csSUFBSTdDLElBQUk7SUFDcEM7SUFDQWpDLE9BQU9jLEtBQUssR0FBRzhELE1BQU1DLElBQUksQ0FBQ0c7SUFFMUIsT0FBT2hGO0FBQ1Q7QUFFQSxTQUFTbUMsWUFBWVosR0FBUTtJQUMzQixNQUFNVixTQUEyQyxDQUFDO0lBQ2xELE1BQU1vRSxnQkFBZ0I7UUFBQztRQUFRO1FBQVk7UUFBUztRQUFNO1FBQU07UUFBYTtLQUFPO0lBRXBGNUUsT0FBT0MsSUFBSSxDQUFDaUIsS0FBSzJCLE9BQU8sQ0FBQ3dCLENBQUFBO1FBQ3ZCLElBQUksQ0FBQ08sY0FBY0MsUUFBUSxDQUFDUixNQUFNO1lBQ2hDLE1BQU1TLFFBQVE1RCxHQUFHLENBQUNtRCxJQUFJO1lBQ3RCLElBQUlTLFNBQVNBLFVBQVUsVUFBVUEsVUFBVSxJQUFJO2dCQUM3QyxvQ0FBb0M7Z0JBQ3BDLElBQUk7b0JBQUM7b0JBQVk7b0JBQWdCO2lCQUFTLENBQUNELFFBQVEsQ0FBQ0MsUUFBUTtvQkFDMUR0RSxNQUFNLENBQUM2RCxJQUFJLEdBQUdTO2dCQUNoQixPQUFPLElBQUksT0FBT0EsVUFBVSxVQUFVO29CQUNwQywrQ0FBK0M7b0JBQy9DLElBQUlBLFNBQVMsR0FBR3RFLE1BQU0sQ0FBQzZELElBQUksR0FBRzt5QkFDekIsSUFBSVMsU0FBUyxHQUFHdEUsTUFBTSxDQUFDNkQsSUFBSSxHQUFHO3lCQUM5QixJQUFJUyxTQUFTLEdBQUd0RSxNQUFNLENBQUM2RCxJQUFJLEdBQUc7Z0JBQ3JDLE9BQU8sSUFBSVMsT0FBTztvQkFDaEIsd0RBQXdEO29CQUN4RHRFLE1BQU0sQ0FBQzZELElBQUksR0FBRztnQkFDaEI7WUFDRjtRQUNGO0lBQ0Y7SUFFQSxPQUFPN0Q7QUFDVCIsInNvdXJjZXMiOlsiL2hvbWUvcDQ3Mi9TY2hlZHVsZXIvbGliL2V4Y2VsL3BhcnNlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBYTFNYIGZyb20gJ3hsc3gnXG5pbXBvcnQgeyBTY2hlZHVsZURhdGEsIEVtcGxveWVlLCBQcm9qZWN0LCBBc3NpZ25tZW50LCBQcm9maWNpZW5jeUxldmVsIH0gZnJvbSAnQC90eXBlcy9zY2hlZHVsZSdcbmltcG9ydCB7IGdlbmVyYXRlSWQsIHBhcnNlRGF0ZSwgZ2V0Q3VycmVudFdlZWsgfSBmcm9tICdAL2xpYi91dGlscydcbmltcG9ydCB7IGZvcm1hdCwgcGFyc2UsIGlzVmFsaWQsIHN0YXJ0T2ZXZWVrIH0gZnJvbSAnZGF0ZS1mbnMnXG5cbi8vIEZ1bmN0aW9uIHRvIG5vcm1hbGl6ZSBkYXRlIHRvIHl5eXktTU0tZGQgZm9ybWF0IChNb25kYXkgb2YgdGhlIHdlZWspXG5mdW5jdGlvbiBub3JtYWxpemVEYXRlVG9Nb25kYXkoZGF0ZVZhbHVlOiBhbnkpOiB7IGRhdGU6IHN0cmluZywgd2Vlazogc3RyaW5nIH0ge1xuICBsZXQgcGFyc2VkRGF0ZTogRGF0ZSB8IG51bGwgPSBudWxsXG4gIFxuICAvLyBIYW5kbGUgRGF0ZSBvYmplY3RzIGZyb20gRXhjZWwgcGFyc2luZ1xuICBpZiAoZGF0ZVZhbHVlIGluc3RhbmNlb2YgRGF0ZSAmJiBpc1ZhbGlkKGRhdGVWYWx1ZSkpIHtcbiAgICBwYXJzZWREYXRlID0gZGF0ZVZhbHVlXG4gICAgY29uc29sZS5sb2coYCAgICDwn5OFIFByb2Nlc3NpbmcgRGF0ZSBvYmplY3Q6ICR7Zm9ybWF0KGRhdGVWYWx1ZSwgJ3l5eXktTU0tZGQnKX1gKVxuICB9XG4gIC8vIEhhbmRsZSBFeGNlbCBkYXRlIG51bWJlcnNcbiAgZWxzZSBpZiAodHlwZW9mIGRhdGVWYWx1ZSA9PT0gJ251bWJlcicgJiYgZGF0ZVZhbHVlID4gMCkge1xuICAgIHBhcnNlZERhdGUgPSBuZXcgRGF0ZSgoZGF0ZVZhbHVlIC0gMjU1NjkpICogODY0MDAgKiAxMDAwKVxuICAgIGNvbnNvbGUubG9nKGAgICAg8J+ThSBFeGNlbCBudW1iZXIgJHtkYXRlVmFsdWV9IC0+ICR7Zm9ybWF0KHBhcnNlZERhdGUsICd5eXl5LU1NLWRkJyl9YClcbiAgfVxuICAvLyBIYW5kbGUgc3RyaW5nIGRhdGVzXG4gIGVsc2UgaWYgKHR5cGVvZiBkYXRlVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgZGF0ZVN0ciA9IGRhdGVWYWx1ZS50cmltKClcbiAgICBcbiAgICAvLyBQcmlvcml0eTogeXl5eS1NTS1kZCBmb3JtYXRcbiAgICBpZiAoL15cXGR7NH0tXFxkezJ9LVxcZHsyfS8udGVzdChkYXRlU3RyKSkge1xuICAgICAgY29uc3QgZGF0ZU9ubHkgPSBkYXRlU3RyLnNwbGl0KCdUJylbMF1cbiAgICAgIHBhcnNlZERhdGUgPSBwYXJzZShkYXRlT25seSwgJ3l5eXktTU0tZGQnLCBuZXcgRGF0ZSgpKVxuICAgICAgaWYgKGlzVmFsaWQocGFyc2VkRGF0ZSkpIHtcbiAgICAgICAgY29uc29sZS5sb2coYCAgICDwn5OFIFBhcnNlZCB5eXl5LU1NLWRkOiAke2RhdGVPbmx5fWApXG4gICAgICB9XG4gICAgfVxuICAgIC8vIFRyeSBvdGhlciBmb3JtYXRzXG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBmb3JtYXRzID0gWydNTS9kZC95eXl5JywgJ00vZC95eXl5JywgJ01NTSBkIHl5eXknLCAnZC1NTU0teXl5eSddXG4gICAgICBmb3IgKGNvbnN0IGZtdCBvZiBmb3JtYXRzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2UoZGF0ZVN0ciwgZm10LCBuZXcgRGF0ZSgpKVxuICAgICAgICAgIGlmIChpc1ZhbGlkKHBhcnNlZCkpIHtcbiAgICAgICAgICAgIHBhcnNlZERhdGUgPSBwYXJzZWRcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgICAg8J+ThSBQYXJzZWQgJHtmbXR9OiAke2RhdGVTdHJ9IC0+ICR7Zm9ybWF0KHBhcnNlZCwgJ3l5eXktTU0tZGQnKX1gKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2gge31cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIC8vIElmIHdlIGNvdWxkbid0IHBhcnNlLCB1c2UgY3VycmVudCBkYXRlXG4gIGlmICghcGFyc2VkRGF0ZSB8fCAhaXNWYWxpZChwYXJzZWREYXRlKSkge1xuICAgIGNvbnNvbGUud2FybihgICAgIOKaoO+4jyBDb3VsZCBub3QgcGFyc2UgZGF0ZTogXCIke2RhdGVWYWx1ZX1cIiwgdXNpbmcgY3VycmVudCBkYXRlYClcbiAgICBwYXJzZWREYXRlID0gbmV3IERhdGUoKVxuICB9XG4gIFxuICAvLyBDb252ZXJ0IHRvIE1vbmRheSBvZiB0aGF0IHdlZWtcbiAgY29uc3QgbW9uZGF5ID0gc3RhcnRPZldlZWsocGFyc2VkRGF0ZSwgeyB3ZWVrU3RhcnRzT246IDEgfSlcbiAgY29uc3QgZGF0ZUZvcm1hdHRlZCA9IGZvcm1hdChtb25kYXksICd5eXl5LU1NLWRkJylcbiAgY29uc3Qgd2Vla0Zvcm1hdHRlZCA9IGZvcm1hdChtb25kYXksICdNTU0gZCcpLnRvVXBwZXJDYXNlKClcbiAgXG4gIGNvbnN0IGRheU5hbWUgPSBmb3JtYXQocGFyc2VkRGF0ZSwgJ0VFRUUnKVxuICBpZiAocGFyc2VkRGF0ZS5nZXREYXkoKSA9PT0gMSkge1xuICAgIGNvbnNvbGUubG9nKGAgICAg4pyFIERhdGUgaXMgYWxyZWFkeSBNb25kYXk6ICR7ZGF0ZUZvcm1hdHRlZH0gLT4gV2VlazogXCIke3dlZWtGb3JtYXR0ZWR9XCJgKVxuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUubG9nKGAgICAg8J+ThSBDb252ZXJ0ZWQgJHtkYXlOYW1lfSAke2Zvcm1hdChwYXJzZWREYXRlLCAneXl5eS1NTS1kZCcpfSAtPiBNb25kYXk6ICR7ZGF0ZUZvcm1hdHRlZH0gKFdlZWs6IFwiJHt3ZWVrRm9ybWF0dGVkfVwiKWApXG4gIH1cbiAgXG4gIHJldHVybiB7IGRhdGU6IGRhdGVGb3JtYXR0ZWQsIHdlZWs6IHdlZWtGb3JtYXR0ZWQgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGFyc2VFeGNlbEZpbGUoZmlsZTogRmlsZSk6IFByb21pc2U8U2NoZWR1bGVEYXRhPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICAgIFxuICAgIHJlYWRlci5vbmxvYWQgPSAoZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfk4ogU3RhcnRpbmcgRXhjZWwgcGFyc2luZy4uLicpXG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShlLnRhcmdldD8ucmVzdWx0IGFzIEFycmF5QnVmZmVyKVxuICAgICAgICBjb25zdCB3b3JrYm9vayA9IFhMU1gucmVhZChkYXRhLCB7IHR5cGU6ICdhcnJheScsIGNlbGxEYXRlczogdHJ1ZSB9KVxuICAgICAgICBjb25zb2xlLmxvZygn8J+TiyBXb3JrYm9vayBzaGVldHMgZm91bmQ6JywgT2JqZWN0LmtleXMod29ya2Jvb2suU2hlZXRzKSlcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VXb3JrYm9vayh3b3JrYm9vaylcbiAgICAgICAgY29uc29sZS5sb2coJ+KchSBQYXJzaW5nIGNvbXBsZXRlOicsIHtcbiAgICAgICAgICBlbXBsb3llZXM6IHJlc3VsdC5lbXBsb3llZXMubGVuZ3RoLFxuICAgICAgICAgIHByb2plY3RzOiByZXN1bHQucHJvamVjdHMubGVuZ3RoLFxuICAgICAgICAgIGFzc2lnbm1lbnRzOiByZXN1bHQuYXNzaWdubWVudHMubGVuZ3RoLFxuICAgICAgICAgIHNraWxsczogcmVzdWx0LnNraWxscy5sZW5ndGgsXG4gICAgICAgICAgdGVhbXM6IHJlc3VsdC50ZWFtcy5sZW5ndGhcbiAgICAgICAgfSlcbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgcGFyc2luZyBFeGNlbDonLCBlcnJvcilcbiAgICAgICAgcmVqZWN0KGVycm9yKVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZWFkZXIub25lcnJvciA9ICgpID0+IHJlamVjdChuZXcgRXJyb3IoJ0ZhaWxlZCB0byByZWFkIGZpbGUnKSlcbiAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoZmlsZSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gcGFyc2VXb3JrYm9vayh3b3JrYm9vazogWExTWC5Xb3JrQm9vayk6IFNjaGVkdWxlRGF0YSB7XG4gIGNvbnN0IHJlc3VsdDogU2NoZWR1bGVEYXRhID0ge1xuICAgIGVtcGxveWVlczogW10sXG4gICAgcHJvamVjdHM6IFtdLFxuICAgIGFzc2lnbm1lbnRzOiBbXSxcbiAgICBza2lsbHM6IFtdLFxuICAgIHRlYW1zOiBbJ0FsbCBUZWFtcyddLFxuICB9XG5cbiAgLy8gUGFyc2UgRW1wbG95ZWVzIHNoZWV0XG4gIGlmICh3b3JrYm9vay5TaGVldHNbJ0VtcGxveWVlcyddKSB7XG4gICAgY29uc3Qgc2hlZXQgPSBYTFNYLnV0aWxzLnNoZWV0X3RvX2pzb24od29ya2Jvb2suU2hlZXRzWydFbXBsb3llZXMnXSlcbiAgICByZXN1bHQuZW1wbG95ZWVzID0gc2hlZXQubWFwKChyb3c6IGFueSkgPT4gKHtcbiAgICAgIGlkOiByb3cuSUQgfHwgcm93LmlkIHx8IGdlbmVyYXRlSWQoKSxcbiAgICAgIG5hbWU6IHJvdy5OYW1lIHx8IHJvdy5FbXBsb3llZSB8fCAnJyxcbiAgICAgIGVtYWlsOiByb3cuRW1haWwgfHwgJycsXG4gICAgICBtYXhIb3VyczogTnVtYmVyKHJvd1snTWF4IEhvdXJzJ10pIHx8IDQwLFxuICAgICAgdGVhbTogcm93LlRlYW0gfHwgJ0RlZmF1bHQnLFxuICAgICAgc2tpbGxzOiBwYXJzZVNraWxscyhyb3cpLFxuICAgIH0pKVxuICB9XG5cbiAgLy8gUGFyc2UgUHJvamVjdHMgc2hlZXRcbiAgaWYgKHdvcmtib29rLlNoZWV0c1snUHJvamVjdHMnXSkge1xuICAgIGNvbnN0IHNoZWV0ID0gWExTWC51dGlscy5zaGVldF90b19qc29uKHdvcmtib29rLlNoZWV0c1snUHJvamVjdHMnXSlcbiAgICByZXN1bHQucHJvamVjdHMgPSBzaGVldC5tYXAoKHJvdzogYW55KSA9PiAoe1xuICAgICAgaWQ6IHJvdy5JRCB8fCByb3cuaWQgfHwgZ2VuZXJhdGVJZCgpLFxuICAgICAgbmFtZTogcm93Lk5hbWUgfHwgcm93LlByb2plY3QgfHwgJycsXG4gICAgICBzdGFydERhdGU6IHBhcnNlRGF0ZShyb3dbJ1N0YXJ0IERhdGUnXSkgfHwgbmV3IERhdGUoKSxcbiAgICAgIGVuZERhdGU6IHBhcnNlRGF0ZShyb3dbJ0VuZCBEYXRlJ10pIHx8IG5ldyBEYXRlKCksXG4gICAgICByZXF1aXJlZFNraWxsczogcm93WydSZXF1aXJlZCBTa2lsbHMnXSBcbiAgICAgICAgPyBTdHJpbmcocm93WydSZXF1aXJlZCBTa2lsbHMnXSkuc3BsaXQoJywnKS5tYXAocyA9PiBzLnRyaW0oKSlcbiAgICAgICAgOiBbXSxcbiAgICAgIHBvcnRmb2xpbzogcm93LlBvcnRmb2xpbyB8fCAnJyxcbiAgICB9KSlcbiAgfVxuXG4gIC8vIFBhcnNlIEFzc2lnbm1lbnRzIHNoZWV0XG4gIGlmICh3b3JrYm9vay5TaGVldHNbJ0Fzc2lnbm1lbnRzJ10pIHtcbiAgICBjb25zb2xlLmxvZygn8J+ThSBQYXJzaW5nIEFzc2lnbm1lbnRzIHNoZWV0Li4uJylcbiAgICBjb25zdCBzaGVldCA9IFhMU1gudXRpbHMuc2hlZXRfdG9fanNvbih3b3JrYm9vay5TaGVldHNbJ0Fzc2lnbm1lbnRzJ10pXG4gICAgY29uc29sZS5sb2coYCAgRm91bmQgJHtzaGVldC5sZW5ndGh9IGFzc2lnbm1lbnQgcm93c2ApXG4gICAgXG4gICAgLy8gTG9nIGZpcnN0IGZldyByb3dzIGZvciBkZWJ1Z2dpbmdcbiAgICBpZiAoc2hlZXQubGVuZ3RoID4gMCkge1xuICAgICAgY29uc29sZS5sb2coJyAgU2FtcGxlIGFzc2lnbm1lbnQgcm93OicsIHNoZWV0WzBdKVxuICAgICAgY29uc29sZS5sb2coJyAgQXNzaWdubWVudCBjb2x1bW4gaGVhZGVyczonLCBPYmplY3Qua2V5cyhzaGVldFswXSkpXG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgcGl2b3Qtc3R5bGUgZm9ybWF0IChjb2x1bW5zIGFyZSBkYXRlcylcbiAgICBjb25zdCBmaXJzdFJvdyA9IHNoZWV0WzBdIHx8IHt9XG4gICAgY29uc3QgY29sdW1ucyA9IE9iamVjdC5rZXlzKGZpcnN0Um93KVxuICAgIGNvbnN0IGRhdGVDb2x1bW5zID0gY29sdW1ucy5maWx0ZXIoY29sID0+IHtcbiAgICAgIC8vIENoZWNrIGlmIGNvbHVtbiBuYW1lIGxvb2tzIGxpa2UgYSBkYXRlXG4gICAgICByZXR1cm4gL15cXGR7NH0tXFxkezJ9LVxcZHsyfS8udGVzdChjb2wpIHx8IFxuICAgICAgICAgICAgIC9eXFxkezEsMn1cXC9cXGR7MSwyfVxcL1xcZHs0fS8udGVzdChjb2wpIHx8XG4gICAgICAgICAgICAgL15bQS1aXVthLXpdezJ9XFxzK1xcZHsxLDJ9Ly50ZXN0KGNvbClcbiAgICB9KVxuICAgIFxuICAgIGlmIChkYXRlQ29sdW1ucy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBQaXZvdCBmb3JtYXQ6IEVhY2ggcm93IGlzIGVtcGxveWVlLXByb2plY3QsIGNvbHVtbnMgYXJlIHdlZWsgZGF0ZXNcbiAgICAgIGNvbnNvbGUubG9nKCcgIPCfk4ogRGV0ZWN0ZWQgcGl2b3Qtc3R5bGUgZm9ybWF0IHdpdGggZGF0ZSBjb2x1bW5zOicsIGRhdGVDb2x1bW5zLnNsaWNlKDAsIDMpKVxuICAgICAgcmVzdWx0LmFzc2lnbm1lbnRzID0gW11cbiAgICAgIFxuICAgICAgc2hlZXQuZm9yRWFjaCgocm93OiBhbnksIHJvd0luZGV4OiBudW1iZXIpID0+IHtcbiAgICAgICAgY29uc3QgZW1wbG95ZWVJZCA9IHJvdy5FbXBsb3llZSB8fCByb3dbJ0VtcGxveWVlJ10gfHwgcm93WydFbXBsb3llZSBJRCddIHx8ICcnXG4gICAgICAgIGNvbnN0IHByb2plY3RJZCA9IHJvdy5Qcm9qZWN0IHx8IHJvd1snUHJvamVjdCddIHx8IHJvd1snUHJvamVjdCBJRCddIHx8ICcnXG4gICAgICAgIFxuICAgICAgICBpZiAoIWVtcGxveWVlSWQgfHwgIXByb2plY3RJZCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGAgIOKaoO+4jyBTa2lwcGluZyByb3cgJHtyb3dJbmRleCArIDF9OiBtaXNzaW5nIGVtcGxveWVlIG9yIHByb2plY3RgKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBQcm9jZXNzIGVhY2ggZGF0ZSBjb2x1bW5cbiAgICAgICAgZGF0ZUNvbHVtbnMuZm9yRWFjaChkYXRlQ29sID0+IHtcbiAgICAgICAgICBjb25zdCBob3VycyA9IHJvd1tkYXRlQ29sXVxuICAgICAgICAgIGlmIChob3VycyAmJiBOdW1iZXIoaG91cnMpID4gMCkge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRlLCB3ZWVrIH0gPSBub3JtYWxpemVEYXRlVG9Nb25kYXkoZGF0ZUNvbClcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgYXNzaWdubWVudDogQXNzaWdubWVudCA9IHtcbiAgICAgICAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgICAgICAgZW1wbG95ZWVJZDogZW1wbG95ZWVJZCxcbiAgICAgICAgICAgICAgcHJvamVjdElkOiBwcm9qZWN0SWQsXG4gICAgICAgICAgICAgIGhvdXJzOiBOdW1iZXIoaG91cnMpLFxuICAgICAgICAgICAgICB3ZWVrOiB3ZWVrLFxuICAgICAgICAgICAgICBkYXRlOiBkYXRlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJlc3VsdC5hc3NpZ25tZW50cy5wdXNoKGFzc2lnbm1lbnQpXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIERlYnVnIGZpcnN0IGZld1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5hc3NpZ25tZW50cy5sZW5ndGggPD0gMykge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgICBBc3NpZ25tZW50ICR7cmVzdWx0LmFzc2lnbm1lbnRzLmxlbmd0aH06YCwge1xuICAgICAgICAgICAgICAgIGVtcGxveWVlOiBlbXBsb3llZUlkLFxuICAgICAgICAgICAgICAgIHByb2plY3Q6IHByb2plY3RJZCxcbiAgICAgICAgICAgICAgICBkYXRlOiBkYXRlLFxuICAgICAgICAgICAgICAgIHdlZWs6IHdlZWssXG4gICAgICAgICAgICAgICAgaG91cnM6IGhvdXJzXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYCAg4pyTIENvbnZlcnRlZCBwaXZvdCBmb3JtYXQgdG8gJHtyZXN1bHQuYXNzaWdubWVudHMubGVuZ3RofSBhc3NpZ25tZW50c2ApXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRyYWRpdGlvbmFsIGZvcm1hdDogRWFjaCByb3cgaXMgb25lIGFzc2lnbm1lbnRcbiAgICAgIHJlc3VsdC5hc3NpZ25tZW50cyA9IHNoZWV0Lm1hcCgocm93OiBhbnksIGluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgICAgLy8gQ2hlY2sgYWxsIHBvc3NpYmxlIGNvbHVtbiBuYW1lcyBmb3Igd2Vlay9kYXRlXG4gICAgICAgIGNvbnN0IHJhd0RhdGUgPSByb3cuV2VlayB8fCByb3dbJ1dlZWsnXSB8fCByb3cuRGF0ZSB8fCByb3dbJ0RhdGUnXSB8fCByb3cud2VlayB8fCByb3cuZGF0ZVxuICAgICAgICBjb25zdCB7IGRhdGUsIHdlZWsgfSA9IG5vcm1hbGl6ZURhdGVUb01vbmRheShyYXdEYXRlKVxuICAgICAgICBcbiAgICAgICAgLy8gUGFyc2UgaG91cnMgd2l0aCBiZXR0ZXIgaGFuZGxpbmdcbiAgICAgICAgY29uc3QgcmF3SG91cnMgPSByb3cuSG91cnMgfHwgcm93WydIb3VycyddIHx8IHJvdy5ob3VycyB8fCAwXG4gICAgICAgIGNvbnN0IHBhcnNlZEhvdXJzID0gdHlwZW9mIHJhd0hvdXJzID09PSAnc3RyaW5nJyA/IHBhcnNlRmxvYXQocmF3SG91cnMpIHx8IDAgOiBOdW1iZXIocmF3SG91cnMpIHx8IDBcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGFzc2lnbm1lbnQ6IEFzc2lnbm1lbnQgPSB7XG4gICAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgICBlbXBsb3llZUlkOiByb3dbJ0VtcGxveWVlIElEJ10gfHwgcm93LkVtcGxveWVlIHx8IHJvd1snRW1wbG95ZWUnXSB8fCByb3dbJ2VtcGxveWVlJ10gfHwgJycsXG4gICAgICAgICAgcHJvamVjdElkOiByb3dbJ1Byb2plY3QgSUQnXSB8fCByb3cuUHJvamVjdCB8fCByb3dbJ1Byb2plY3QnXSB8fCByb3dbJ3Byb2plY3QnXSB8fCAnJyxcbiAgICAgICAgICBob3VyczogcGFyc2VkSG91cnMsXG4gICAgICAgICAgd2Vlazogd2VlaywgIC8vIEtlZXAgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgZGF0ZTogZGF0ZSAgIC8vIE5ldzogU3RvcmUgZnVsbCBkYXRlIGluIHl5eXktTU0tZGQgZm9ybWF0XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIERlYnVnIGxvZyBmb3IgZmlyc3QgZmV3IGFzc2lnbm1lbnRzXG4gICAgICAgIGlmIChpbmRleCA8IDMpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgICBBc3NpZ25tZW50ICR7aW5kZXggKyAxfTpgLCB7XG4gICAgICAgICAgICBlbXBsb3llZUlkOiBhc3NpZ25tZW50LmVtcGxveWVlSWQsXG4gICAgICAgICAgICBwcm9qZWN0SWQ6IGFzc2lnbm1lbnQucHJvamVjdElkLFxuICAgICAgICAgICAgaG91cnM6IGAke2Fzc2lnbm1lbnQuaG91cnN9IChyYXc6IFwiJHtyYXdIb3Vyc31cIiwgdHlwZTogJHt0eXBlb2YgcmF3SG91cnN9KWAsXG4gICAgICAgICAgICByYXdEYXRlOiByYXdEYXRlLFxuICAgICAgICAgICAgc3RvcmVkRGF0ZTogYXNzaWdubWVudC5kYXRlLFxuICAgICAgICAgICAgZGlzcGxheVdlZWs6IGFzc2lnbm1lbnQud2VlayxcbiAgICAgICAgICAgIGFsbENvbHVtbnM6IE9iamVjdC5rZXlzKHJvdykuam9pbignLCAnKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBhc3NpZ25tZW50XG4gICAgICB9KVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhgICDinJMgUGFyc2VkICR7cmVzdWx0LmFzc2lnbm1lbnRzLmxlbmd0aH0gYXNzaWdubWVudHNgKVxuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZygnICBVbmlxdWUgd2Vla3MgZm91bmQ6JywgWy4uLm5ldyBTZXQocmVzdWx0LmFzc2lnbm1lbnRzLm1hcChhID0+IGEud2VlaykpXSlcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmxvZygn4pqg77iPIE5vIEFzc2lnbm1lbnRzIHNoZWV0IGZvdW5kIGluIHdvcmtib29rJylcbiAgfVxuXG4gIC8vIFBhcnNlIFNraWxscyBzaGVldCAob3B0aW9uYWwpXG4gIGlmICh3b3JrYm9vay5TaGVldHNbJ1NraWxscyddKSB7XG4gICAgY29uc3Qgc2hlZXQgPSBYTFNYLnV0aWxzLnNoZWV0X3RvX2pzb24od29ya2Jvb2suU2hlZXRzWydTa2lsbHMnXSlcbiAgICBjb25zdCBza2lsbFNldCA9IG5ldyBTZXQ8c3RyaW5nPigpXG4gICAgXG4gICAgc2hlZXQuZm9yRWFjaCgocm93OiBhbnkpID0+IHtcbiAgICAgIE9iamVjdC5rZXlzKHJvdykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBpZiAoa2V5ICE9PSAnRW1wbG95ZWUnICYmIGtleSAhPT0gJ0lEJyAmJiBrZXkgIT09ICdOYW1lJykge1xuICAgICAgICAgIHNraWxsU2V0LmFkZChrZXkpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgICBcbiAgICByZXN1bHQuc2tpbGxzID0gQXJyYXkuZnJvbShza2lsbFNldClcbiAgfSBlbHNlIHtcbiAgICAvLyBFeHRyYWN0IHNraWxscyBmcm9tIGVtcGxveWVlc1xuICAgIGNvbnN0IHNraWxsU2V0ID0gbmV3IFNldDxzdHJpbmc+KClcbiAgICByZXN1bHQuZW1wbG95ZWVzLmZvckVhY2goZW1wID0+IHtcbiAgICAgIE9iamVjdC5rZXlzKGVtcC5za2lsbHMpLmZvckVhY2goc2tpbGwgPT4gc2tpbGxTZXQuYWRkKHNraWxsKSlcbiAgICB9KVxuICAgIHJlc3VsdC5za2lsbHMgPSBBcnJheS5mcm9tKHNraWxsU2V0KVxuICB9XG5cbiAgLy8gRXh0cmFjdCB0ZWFtc1xuICBjb25zdCB0ZWFtU2V0ID0gbmV3IFNldChbJ0FsbCBUZWFtcyddKVxuICByZXN1bHQuZW1wbG95ZWVzLmZvckVhY2goZW1wID0+IHtcbiAgICBpZiAoZW1wLnRlYW0pIHRlYW1TZXQuYWRkKGVtcC50ZWFtKVxuICB9KVxuICByZXN1bHQudGVhbXMgPSBBcnJheS5mcm9tKHRlYW1TZXQpXG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBwYXJzZVNraWxscyhyb3c6IGFueSk6IFJlY29yZDxzdHJpbmcsIFByb2ZpY2llbmN5TGV2ZWw+IHtcbiAgY29uc3Qgc2tpbGxzOiBSZWNvcmQ8c3RyaW5nLCBQcm9maWNpZW5jeUxldmVsPiA9IHt9XG4gIGNvbnN0IGV4Y2x1ZGVGaWVsZHMgPSBbJ05hbWUnLCAnRW1wbG95ZWUnLCAnRW1haWwnLCAnSUQnLCAnaWQnLCAnTWF4IEhvdXJzJywgJ1RlYW0nXVxuICBcbiAgT2JqZWN0LmtleXMocm93KS5mb3JFYWNoKGtleSA9PiB7XG4gICAgaWYgKCFleGNsdWRlRmllbGRzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gcm93W2tleV1cbiAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZSAhPT0gJ05vbmUnICYmIHZhbHVlICE9PSAnJykge1xuICAgICAgICAvLyBUcnkgdG8gcGFyc2UgYXMgcHJvZmljaWVuY3kgbGV2ZWxcbiAgICAgICAgaWYgKFsnQmVnaW5uZXInLCAnSW50ZXJtZWRpYXRlJywgJ0V4cGVydCddLmluY2x1ZGVzKHZhbHVlKSkge1xuICAgICAgICAgIHNraWxsc1trZXldID0gdmFsdWUgYXMgUHJvZmljaWVuY3lMZXZlbFxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAvLyBDb252ZXJ0IG51bWVyaWMgdmFsdWVzIHRvIHByb2ZpY2llbmN5IGxldmVsc1xuICAgICAgICAgIGlmICh2YWx1ZSA+PSAzKSBza2lsbHNba2V5XSA9ICdFeHBlcnQnXG4gICAgICAgICAgZWxzZSBpZiAodmFsdWUgPj0gMikgc2tpbGxzW2tleV0gPSAnSW50ZXJtZWRpYXRlJ1xuICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID49IDEpIHNraWxsc1trZXldID0gJ0JlZ2lubmVyJ1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgLy8gRGVmYXVsdCB0byBJbnRlcm1lZGlhdGUgZm9yIGFueSBvdGhlciBub24tZW1wdHkgdmFsdWVcbiAgICAgICAgICBza2lsbHNba2V5XSA9ICdJbnRlcm1lZGlhdGUnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIFxuICByZXR1cm4gc2tpbGxzXG59Il0sIm5hbWVzIjpbIlhMU1giLCJnZW5lcmF0ZUlkIiwicGFyc2VEYXRlIiwiZm9ybWF0IiwicGFyc2UiLCJpc1ZhbGlkIiwic3RhcnRPZldlZWsiLCJub3JtYWxpemVEYXRlVG9Nb25kYXkiLCJkYXRlVmFsdWUiLCJwYXJzZWREYXRlIiwiRGF0ZSIsImNvbnNvbGUiLCJsb2ciLCJkYXRlU3RyIiwidHJpbSIsInRlc3QiLCJkYXRlT25seSIsInNwbGl0IiwiZm9ybWF0cyIsImZtdCIsInBhcnNlZCIsIndhcm4iLCJtb25kYXkiLCJ3ZWVrU3RhcnRzT24iLCJkYXRlRm9ybWF0dGVkIiwid2Vla0Zvcm1hdHRlZCIsInRvVXBwZXJDYXNlIiwiZGF5TmFtZSIsImdldERheSIsImRhdGUiLCJ3ZWVrIiwicGFyc2VFeGNlbEZpbGUiLCJmaWxlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwib25sb2FkIiwiZSIsImRhdGEiLCJVaW50OEFycmF5IiwidGFyZ2V0IiwicmVzdWx0Iiwid29ya2Jvb2siLCJyZWFkIiwidHlwZSIsImNlbGxEYXRlcyIsIk9iamVjdCIsImtleXMiLCJTaGVldHMiLCJwYXJzZVdvcmtib29rIiwiZW1wbG95ZWVzIiwibGVuZ3RoIiwicHJvamVjdHMiLCJhc3NpZ25tZW50cyIsInNraWxscyIsInRlYW1zIiwiZXJyb3IiLCJvbmVycm9yIiwiRXJyb3IiLCJyZWFkQXNBcnJheUJ1ZmZlciIsInNoZWV0IiwidXRpbHMiLCJzaGVldF90b19qc29uIiwibWFwIiwicm93IiwiaWQiLCJJRCIsIm5hbWUiLCJOYW1lIiwiRW1wbG95ZWUiLCJlbWFpbCIsIkVtYWlsIiwibWF4SG91cnMiLCJOdW1iZXIiLCJ0ZWFtIiwiVGVhbSIsInBhcnNlU2tpbGxzIiwiUHJvamVjdCIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJyZXF1aXJlZFNraWxscyIsIlN0cmluZyIsInMiLCJwb3J0Zm9saW8iLCJQb3J0Zm9saW8iLCJmaXJzdFJvdyIsImNvbHVtbnMiLCJkYXRlQ29sdW1ucyIsImZpbHRlciIsImNvbCIsInNsaWNlIiwiZm9yRWFjaCIsInJvd0luZGV4IiwiZW1wbG95ZWVJZCIsInByb2plY3RJZCIsImRhdGVDb2wiLCJob3VycyIsImFzc2lnbm1lbnQiLCJwdXNoIiwiZW1wbG95ZWUiLCJwcm9qZWN0IiwiaW5kZXgiLCJyYXdEYXRlIiwiV2VlayIsInJhd0hvdXJzIiwiSG91cnMiLCJwYXJzZWRIb3VycyIsInBhcnNlRmxvYXQiLCJzdG9yZWREYXRlIiwiZGlzcGxheVdlZWsiLCJhbGxDb2x1bW5zIiwiam9pbiIsIlNldCIsImEiLCJza2lsbFNldCIsImtleSIsImFkZCIsIkFycmF5IiwiZnJvbSIsImVtcCIsInNraWxsIiwidGVhbVNldCIsImV4Y2x1ZGVGaWVsZHMiLCJpbmNsdWRlcyIsInZhbHVlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/excel/parser.ts\n"));

/***/ })

});