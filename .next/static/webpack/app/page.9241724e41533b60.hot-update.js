"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/excel/parser.ts":
/*!*****************************!*\
  !*** ./lib/excel/parser.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseExcelFile: () => (/* binding */ parseExcelFile)\n/* harmony export */ });\n/* harmony import */ var xlsx__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! xlsx */ \"(app-pages-browser)/./node_modules/xlsx/xlsx.mjs\");\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/utils */ \"(app-pages-browser)/./lib/utils.ts\");\n/* harmony import */ var _barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! __barrel_optimize__?names=format,isValid,parse,startOfWeek!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/isValid.js\");\n/* harmony import */ var _barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! __barrel_optimize__?names=format,isValid,parse,startOfWeek!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/startOfWeek.js\");\n/* harmony import */ var _barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! __barrel_optimize__?names=format,isValid,parse,startOfWeek!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/format.js\");\n/* harmony import */ var _barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=format,isValid,parse,startOfWeek!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/parse.js\");\n\n\n\n// Function to normalize date to yyyy-MM-dd format (Monday of the week)\nfunction normalizeDateToMonday(weekValue) {\n    if (!weekValue) return (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.getCurrentWeek)();\n    // Handle Date objects from Excel parsing\n    if (weekValue instanceof Date && (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_1__.isValid)(weekValue)) {\n        const monday = (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_2__.startOfWeek)(weekValue, {\n            weekStartsOn: 1\n        });\n        const formatted = (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_3__.format)(monday, 'MMM d').toUpperCase();\n        console.log('    \\uD83D\\uDCC5 Date object week -> Monday: \"'.concat(formatted, '\"'));\n        return formatted;\n    }\n    // Handle Excel date numbers\n    if (typeof weekValue === 'number' && weekValue > 0) {\n        const excelDate = new Date((weekValue - 25569) * 86400 * 1000);\n        if ((0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_1__.isValid)(excelDate)) {\n            const monday = (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_2__.startOfWeek)(excelDate, {\n                weekStartsOn: 1\n            });\n            const formatted = (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_3__.format)(monday, 'MMM d').toUpperCase();\n            console.log(\"    \\uD83D\\uDCC5 Excel number \".concat(weekValue, ' -> Monday: \"').concat(formatted, '\"'));\n            return formatted;\n        }\n    }\n    const weekStr = String(weekValue).trim();\n    // Priority: yyyy-MM-dd format (most common in Excel)\n    if (/^\\d{4}-\\d{2}-\\d{2}/.test(weekStr)) {\n        try {\n            // Handle both yyyy-MM-dd and potential datetime strings\n            const dateOnly = weekStr.split('T')[0] // Remove time if present\n            ;\n            const parsed = (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_4__.parse)(dateOnly, 'yyyy-MM-dd', new Date());\n            if ((0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_1__.isValid)(parsed)) {\n                // If it's already a Monday, use it directly; otherwise convert to Monday\n                const dayOfWeek = parsed.getDay();\n                const isMonday = dayOfWeek === 1;\n                const targetDate = isMonday ? parsed : (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_2__.startOfWeek)(parsed, {\n                    weekStartsOn: 1\n                });\n                const formatted = (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_3__.format)(targetDate, 'MMM d').toUpperCase();\n                if (isMonday) {\n                    console.log('    \\uD83D\\uDCC5 Date \"'.concat(dateOnly, '\" is already Monday -> \"').concat(formatted, '\"'));\n                } else {\n                    console.log('    \\uD83D\\uDCC5 Converted \"'.concat(dateOnly, '\" (').concat((0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_3__.format)(parsed, 'EEEE'), ') -> Monday: \"').concat(formatted, '\"'));\n                }\n                return formatted;\n            }\n        } catch (e) {\n            console.warn('    âš ï¸ Failed to parse yyyy-MM-dd format: \"'.concat(weekStr, '\"'), e);\n        }\n    }\n    // Try other date formats\n    const dateFormats = [\n        'MM/dd/yyyy',\n        'M/d/yyyy',\n        'MMM d yyyy',\n        'MMM d',\n        'd-MMM',\n        'd-MMM-yy',\n        'd-MMM-yyyy'\n    ];\n    for (const fmt of dateFormats){\n        try {\n            const parsed = (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_4__.parse)(weekStr, fmt, new Date());\n            if ((0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_1__.isValid)(parsed)) {\n                // Convert to Monday of that week to match HoursGrid\n                const monday = (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_2__.startOfWeek)(parsed, {\n                    weekStartsOn: 1\n                });\n                const formatted = (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_3__.format)(monday, 'MMM d').toUpperCase();\n                console.log('    \\uD83D\\uDCC5 Parsed week \"'.concat(weekStr, '\" (format: ').concat(fmt, ') -> Monday: \"').concat(formatted, '\"'));\n                return formatted;\n            }\n        } catch (e) {\n        // Continue to next format\n        }\n    }\n    // If week is already in the expected format (e.g., \"JAN 15\")\n    if (/^[A-Z]{3}\\s+\\d{1,2}$/i.test(weekStr)) {\n        // Parse it and convert to Monday of that week\n        try {\n            const parsed = (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_4__.parse)(weekStr, 'MMM d', new Date());\n            if ((0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_1__.isValid)(parsed)) {\n                const monday = (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_2__.startOfWeek)(parsed, {\n                    weekStartsOn: 1\n                });\n                const formatted = (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_3__.format)(monday, 'MMM d').toUpperCase();\n                console.log('    \\uD83D\\uDCC5 Normalized week \"'.concat(weekStr, '\" -> Monday: \"').concat(formatted, '\"'));\n                return formatted;\n            }\n        } catch (e) {\n            // If parsing fails, return as is\n            return weekStr.toUpperCase();\n        }\n    }\n    // If it's a Date object\n    if (weekValue instanceof Date && (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_1__.isValid)(weekValue)) {\n        const monday = (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_2__.startOfWeek)(weekValue, {\n            weekStartsOn: 1\n        });\n        return (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_3__.format)(monday, 'MMM d').toUpperCase();\n    }\n    // If it's an Excel date number\n    if (typeof weekValue === 'number' && weekValue > 0) {\n        const excelDate = new Date((weekValue - 25569) * 86400 * 1000);\n        if ((0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_1__.isValid)(excelDate)) {\n            const monday = (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_2__.startOfWeek)(excelDate, {\n                weekStartsOn: 1\n            });\n            return (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_3__.format)(monday, 'MMM d').toUpperCase();\n        }\n    }\n    console.warn('  âš ï¸ Could not parse week format: \"'.concat(weekStr, '\", using current week'));\n    return (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.getCurrentWeek)();\n}\nasync function parseExcelFile(file) {\n    return new Promise((resolve, reject)=>{\n        const reader = new FileReader();\n        reader.onload = (e)=>{\n            try {\n                var _e_target;\n                console.log('ðŸ“Š Starting Excel parsing...');\n                const data = new Uint8Array((_e_target = e.target) === null || _e_target === void 0 ? void 0 : _e_target.result);\n                const workbook = xlsx__WEBPACK_IMPORTED_MODULE_5__.read(data, {\n                    type: 'array',\n                    cellDates: true\n                });\n                console.log('ðŸ“‹ Workbook sheets found:', Object.keys(workbook.Sheets));\n                const result = parseWorkbook(workbook);\n                console.log('âœ… Parsing complete:', {\n                    employees: result.employees.length,\n                    projects: result.projects.length,\n                    assignments: result.assignments.length,\n                    skills: result.skills.length,\n                    teams: result.teams.length\n                });\n                resolve(result);\n            } catch (error) {\n                console.error('âŒ Error parsing Excel:', error);\n                reject(error);\n            }\n        };\n        reader.onerror = ()=>reject(new Error('Failed to read file'));\n        reader.readAsArrayBuffer(file);\n    });\n}\nfunction parseWorkbook(workbook) {\n    const result = {\n        employees: [],\n        projects: [],\n        assignments: [],\n        skills: [],\n        teams: [\n            'All Teams'\n        ]\n    };\n    // Parse Employees sheet\n    if (workbook.Sheets['Employees']) {\n        const sheet = xlsx__WEBPACK_IMPORTED_MODULE_5__.utils.sheet_to_json(workbook.Sheets['Employees']);\n        result.employees = sheet.map((row)=>({\n                id: row.ID || row.id || (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.generateId)(),\n                name: row.Name || row.Employee || '',\n                email: row.Email || '',\n                maxHours: Number(row['Max Hours']) || 40,\n                team: row.Team || 'Default',\n                skills: parseSkills(row)\n            }));\n    }\n    // Parse Projects sheet\n    if (workbook.Sheets['Projects']) {\n        const sheet = xlsx__WEBPACK_IMPORTED_MODULE_5__.utils.sheet_to_json(workbook.Sheets['Projects']);\n        result.projects = sheet.map((row)=>({\n                id: row.ID || row.id || (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.generateId)(),\n                name: row.Name || row.Project || '',\n                startDate: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.parseDate)(row['Start Date']) || new Date(),\n                endDate: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.parseDate)(row['End Date']) || new Date(),\n                requiredSkills: row['Required Skills'] ? String(row['Required Skills']).split(',').map((s)=>s.trim()) : [],\n                portfolio: row.Portfolio || ''\n            }));\n    }\n    // Parse Assignments sheet\n    if (workbook.Sheets['Assignments']) {\n        console.log('ðŸ“… Parsing Assignments sheet...');\n        const sheet = xlsx__WEBPACK_IMPORTED_MODULE_5__.utils.sheet_to_json(workbook.Sheets['Assignments']);\n        console.log(\"  Found \".concat(sheet.length, \" assignment rows\"));\n        // Log first few rows for debugging\n        if (sheet.length > 0) {\n            console.log('  Sample assignment row:', sheet[0]);\n            console.log('  Assignment column headers:', Object.keys(sheet[0]));\n        }\n        result.assignments = sheet.map((row, index)=>{\n            // Check all possible column names for week/date\n            const rawWeek = row.Week || row['Week'] || row.Date || row['Date'] || row.week || row.date;\n            const normalizedWeek = normalizeWeekFormat(rawWeek);\n            // Parse hours with better handling\n            const rawHours = row.Hours || row['Hours'] || row.hours || 0;\n            const parsedHours = typeof rawHours === 'string' ? parseFloat(rawHours) || 0 : Number(rawHours) || 0;\n            const assignment = {\n                id: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.generateId)(),\n                employeeId: row['Employee ID'] || row.Employee || row['Employee'] || row['employee'] || '',\n                projectId: row['Project ID'] || row.Project || row['Project'] || row['project'] || '',\n                hours: parsedHours,\n                week: normalizedWeek\n            };\n            // Debug log for first few assignments\n            if (index < 3) {\n                console.log(\"  Assignment \".concat(index + 1, \":\"), {\n                    employeeId: assignment.employeeId,\n                    projectId: assignment.projectId,\n                    hours: \"\".concat(assignment.hours, ' (raw: \"').concat(rawHours, '\", type: ').concat(typeof rawHours, \")\"),\n                    rawWeek: rawWeek,\n                    normalizedWeek: assignment.week,\n                    allColumns: Object.keys(row).join(', ')\n                });\n            }\n            return assignment;\n        });\n        console.log(\"  âœ“ Parsed \".concat(result.assignments.length, \" assignments\"));\n        console.log('  Unique weeks found:', [\n            ...new Set(result.assignments.map((a)=>a.week))\n        ]);\n    } else {\n        console.log('âš ï¸ No Assignments sheet found in workbook');\n    }\n    // Parse Skills sheet (optional)\n    if (workbook.Sheets['Skills']) {\n        const sheet = xlsx__WEBPACK_IMPORTED_MODULE_5__.utils.sheet_to_json(workbook.Sheets['Skills']);\n        const skillSet = new Set();\n        sheet.forEach((row)=>{\n            Object.keys(row).forEach((key)=>{\n                if (key !== 'Employee' && key !== 'ID' && key !== 'Name') {\n                    skillSet.add(key);\n                }\n            });\n        });\n        result.skills = Array.from(skillSet);\n    } else {\n        // Extract skills from employees\n        const skillSet = new Set();\n        result.employees.forEach((emp)=>{\n            Object.keys(emp.skills).forEach((skill)=>skillSet.add(skill));\n        });\n        result.skills = Array.from(skillSet);\n    }\n    // Extract teams\n    const teamSet = new Set([\n        'All Teams'\n    ]);\n    result.employees.forEach((emp)=>{\n        if (emp.team) teamSet.add(emp.team);\n    });\n    result.teams = Array.from(teamSet);\n    return result;\n}\nfunction parseSkills(row) {\n    const skills = {};\n    const excludeFields = [\n        'Name',\n        'Employee',\n        'Email',\n        'ID',\n        'id',\n        'Max Hours',\n        'Team'\n    ];\n    Object.keys(row).forEach((key)=>{\n        if (!excludeFields.includes(key)) {\n            const value = row[key];\n            if (value && value !== 'None' && value !== '') {\n                // Try to parse as proficiency level\n                if ([\n                    'Beginner',\n                    'Intermediate',\n                    'Expert'\n                ].includes(value)) {\n                    skills[key] = value;\n                } else if (typeof value === 'number') {\n                    // Convert numeric values to proficiency levels\n                    if (value >= 3) skills[key] = 'Expert';\n                    else if (value >= 2) skills[key] = 'Intermediate';\n                    else if (value >= 1) skills[key] = 'Beginner';\n                } else if (value) {\n                    // Default to Intermediate for any other non-empty value\n                    skills[key] = 'Intermediate';\n                }\n            }\n        }\n    });\n    return skills;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QVNBLFVBQVUsVUFBVUEsVUFBVSxJQUFJO2dCQUM3QyxvQ0FBb0M7Z0JBQ3BDLElBQUk7b0JBQUM7b0JBQVk7b0JBQWdCO2lCQUFTLENBQUNELFFBQVEsQ0FBQ0MsUUFBUTtvQkFDMUQ1RCxNQUFNLENBQUNtRCxJQUFJLEdBQUdTO2dCQUNoQixPQUFPLElBQUksT0FBT0EsVUFBVSxVQUFVO29CQUNwQywrQ0FBK0M7b0JBQy9DLElBQUlBLFNBQVMsR0FBRzVELE1BQU0sQ0FBQ21ELElBQUksR0FBRzt5QkFDekIsSUFBSVMsU0FBUyxHQUFHNUQsTUFBTSxDQUFDbUQsSUFBSSxHQUFHO3lCQUM5QixJQUFJUyxTQUFTLEdBQUc1RCxNQUFNLENBQUNtRCxJQUFJLEdBQUc7Z0JBQ3JDLE9BQU8sSUFBSVMsT0FBTztvQkFDaEIsd0RBQXdEO29CQUN4RDVELE1BQU0sQ0FBQ21ELElBQUksR0FBRztnQkFDaEI7WUFDRjtRQUNGO0lBQ0Y7SUFFQSxPQUFPbkQ7QUFDVCIsInNvdXJjZXMiOlsiL2hvbWUvcDQ3Mi9TY2hlZHVsZXIvbGliL2V4Y2VsL3BhcnNlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBYTFNYIGZyb20gJ3hsc3gnXG5pbXBvcnQgeyBTY2hlZHVsZURhdGEsIEVtcGxveWVlLCBQcm9qZWN0LCBBc3NpZ25tZW50LCBQcm9maWNpZW5jeUxldmVsIH0gZnJvbSAnQC90eXBlcy9zY2hlZHVsZSdcbmltcG9ydCB7IGdlbmVyYXRlSWQsIHBhcnNlRGF0ZSwgZ2V0Q3VycmVudFdlZWsgfSBmcm9tICdAL2xpYi91dGlscydcbmltcG9ydCB7IGZvcm1hdCwgcGFyc2UsIGlzVmFsaWQsIHN0YXJ0T2ZXZWVrIH0gZnJvbSAnZGF0ZS1mbnMnXG5cbi8vIEZ1bmN0aW9uIHRvIG5vcm1hbGl6ZSBkYXRlIHRvIHl5eXktTU0tZGQgZm9ybWF0IChNb25kYXkgb2YgdGhlIHdlZWspXG5mdW5jdGlvbiBub3JtYWxpemVEYXRlVG9Nb25kYXkod2Vla1ZhbHVlOiBhbnkpOiB7IGRhdGU6IHN0cmluZywgd2Vlazogc3RyaW5nIH0ge1xuICBpZiAoIXdlZWtWYWx1ZSkgcmV0dXJuIGdldEN1cnJlbnRXZWVrKClcbiAgXG4gIC8vIEhhbmRsZSBEYXRlIG9iamVjdHMgZnJvbSBFeGNlbCBwYXJzaW5nXG4gIGlmICh3ZWVrVmFsdWUgaW5zdGFuY2VvZiBEYXRlICYmIGlzVmFsaWQod2Vla1ZhbHVlKSkge1xuICAgIGNvbnN0IG1vbmRheSA9IHN0YXJ0T2ZXZWVrKHdlZWtWYWx1ZSwgeyB3ZWVrU3RhcnRzT246IDEgfSlcbiAgICBjb25zdCBmb3JtYXR0ZWQgPSBmb3JtYXQobW9uZGF5LCAnTU1NIGQnKS50b1VwcGVyQ2FzZSgpXG4gICAgY29uc29sZS5sb2coYCAgICDwn5OFIERhdGUgb2JqZWN0IHdlZWsgLT4gTW9uZGF5OiBcIiR7Zm9ybWF0dGVkfVwiYClcbiAgICByZXR1cm4gZm9ybWF0dGVkXG4gIH1cbiAgXG4gIC8vIEhhbmRsZSBFeGNlbCBkYXRlIG51bWJlcnNcbiAgaWYgKHR5cGVvZiB3ZWVrVmFsdWUgPT09ICdudW1iZXInICYmIHdlZWtWYWx1ZSA+IDApIHtcbiAgICBjb25zdCBleGNlbERhdGUgPSBuZXcgRGF0ZSgod2Vla1ZhbHVlIC0gMjU1NjkpICogODY0MDAgKiAxMDAwKVxuICAgIGlmIChpc1ZhbGlkKGV4Y2VsRGF0ZSkpIHtcbiAgICAgIGNvbnN0IG1vbmRheSA9IHN0YXJ0T2ZXZWVrKGV4Y2VsRGF0ZSwgeyB3ZWVrU3RhcnRzT246IDEgfSlcbiAgICAgIGNvbnN0IGZvcm1hdHRlZCA9IGZvcm1hdChtb25kYXksICdNTU0gZCcpLnRvVXBwZXJDYXNlKClcbiAgICAgIGNvbnNvbGUubG9nKGAgICAg8J+ThSBFeGNlbCBudW1iZXIgJHt3ZWVrVmFsdWV9IC0+IE1vbmRheTogXCIke2Zvcm1hdHRlZH1cImApXG4gICAgICByZXR1cm4gZm9ybWF0dGVkXG4gICAgfVxuICB9XG4gIFxuICBjb25zdCB3ZWVrU3RyID0gU3RyaW5nKHdlZWtWYWx1ZSkudHJpbSgpXG4gIFxuICAvLyBQcmlvcml0eTogeXl5eS1NTS1kZCBmb3JtYXQgKG1vc3QgY29tbW9uIGluIEV4Y2VsKVxuICBpZiAoL15cXGR7NH0tXFxkezJ9LVxcZHsyfS8udGVzdCh3ZWVrU3RyKSkge1xuICAgIHRyeSB7XG4gICAgICAvLyBIYW5kbGUgYm90aCB5eXl5LU1NLWRkIGFuZCBwb3RlbnRpYWwgZGF0ZXRpbWUgc3RyaW5nc1xuICAgICAgY29uc3QgZGF0ZU9ubHkgPSB3ZWVrU3RyLnNwbGl0KCdUJylbMF0gLy8gUmVtb3ZlIHRpbWUgaWYgcHJlc2VudFxuICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2UoZGF0ZU9ubHksICd5eXl5LU1NLWRkJywgbmV3IERhdGUoKSlcbiAgICAgIGlmIChpc1ZhbGlkKHBhcnNlZCkpIHtcbiAgICAgICAgLy8gSWYgaXQncyBhbHJlYWR5IGEgTW9uZGF5LCB1c2UgaXQgZGlyZWN0bHk7IG90aGVyd2lzZSBjb252ZXJ0IHRvIE1vbmRheVxuICAgICAgICBjb25zdCBkYXlPZldlZWsgPSBwYXJzZWQuZ2V0RGF5KClcbiAgICAgICAgY29uc3QgaXNNb25kYXkgPSBkYXlPZldlZWsgPT09IDFcbiAgICAgICAgY29uc3QgdGFyZ2V0RGF0ZSA9IGlzTW9uZGF5ID8gcGFyc2VkIDogc3RhcnRPZldlZWsocGFyc2VkLCB7IHdlZWtTdGFydHNPbjogMSB9KVxuICAgICAgICBjb25zdCBmb3JtYXR0ZWQgPSBmb3JtYXQodGFyZ2V0RGF0ZSwgJ01NTSBkJykudG9VcHBlckNhc2UoKVxuICAgICAgICBcbiAgICAgICAgaWYgKGlzTW9uZGF5KSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYCAgICDwn5OFIERhdGUgXCIke2RhdGVPbmx5fVwiIGlzIGFscmVhZHkgTW9uZGF5IC0+IFwiJHtmb3JtYXR0ZWR9XCJgKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGAgICAg8J+ThSBDb252ZXJ0ZWQgXCIke2RhdGVPbmx5fVwiICgke2Zvcm1hdChwYXJzZWQsICdFRUVFJyl9KSAtPiBNb25kYXk6IFwiJHtmb3JtYXR0ZWR9XCJgKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWRcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLndhcm4oYCAgICDimqDvuI8gRmFpbGVkIHRvIHBhcnNlIHl5eXktTU0tZGQgZm9ybWF0OiBcIiR7d2Vla1N0cn1cImAsIGUpXG4gICAgfVxuICB9XG4gIFxuICAvLyBUcnkgb3RoZXIgZGF0ZSBmb3JtYXRzXG4gIGNvbnN0IGRhdGVGb3JtYXRzID0gW1xuICAgICdNTS9kZC95eXl5JyxcbiAgICAnTS9kL3l5eXknLFxuICAgICdNTU0gZCB5eXl5JyxcbiAgICAnTU1NIGQnLFxuICAgICdkLU1NTScsXG4gICAgJ2QtTU1NLXl5JyxcbiAgICAnZC1NTU0teXl5eSdcbiAgXVxuICBcbiAgZm9yIChjb25zdCBmbXQgb2YgZGF0ZUZvcm1hdHMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2Uod2Vla1N0ciwgZm10LCBuZXcgRGF0ZSgpKVxuICAgICAgaWYgKGlzVmFsaWQocGFyc2VkKSkge1xuICAgICAgICAvLyBDb252ZXJ0IHRvIE1vbmRheSBvZiB0aGF0IHdlZWsgdG8gbWF0Y2ggSG91cnNHcmlkXG4gICAgICAgIGNvbnN0IG1vbmRheSA9IHN0YXJ0T2ZXZWVrKHBhcnNlZCwgeyB3ZWVrU3RhcnRzT246IDEgfSlcbiAgICAgICAgY29uc3QgZm9ybWF0dGVkID0gZm9ybWF0KG1vbmRheSwgJ01NTSBkJykudG9VcHBlckNhc2UoKVxuICAgICAgICBjb25zb2xlLmxvZyhgICAgIPCfk4UgUGFyc2VkIHdlZWsgXCIke3dlZWtTdHJ9XCIgKGZvcm1hdDogJHtmbXR9KSAtPiBNb25kYXk6IFwiJHtmb3JtYXR0ZWR9XCJgKVxuICAgICAgICByZXR1cm4gZm9ybWF0dGVkXG4gICAgICB9XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyBDb250aW51ZSB0byBuZXh0IGZvcm1hdFxuICAgIH1cbiAgfVxuICBcbiAgLy8gSWYgd2VlayBpcyBhbHJlYWR5IGluIHRoZSBleHBlY3RlZCBmb3JtYXQgKGUuZy4sIFwiSkFOIDE1XCIpXG4gIGlmICgvXltBLVpdezN9XFxzK1xcZHsxLDJ9JC9pLnRlc3Qod2Vla1N0cikpIHtcbiAgICAvLyBQYXJzZSBpdCBhbmQgY29udmVydCB0byBNb25kYXkgb2YgdGhhdCB3ZWVrXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlKHdlZWtTdHIsICdNTU0gZCcsIG5ldyBEYXRlKCkpXG4gICAgICBpZiAoaXNWYWxpZChwYXJzZWQpKSB7XG4gICAgICAgIGNvbnN0IG1vbmRheSA9IHN0YXJ0T2ZXZWVrKHBhcnNlZCwgeyB3ZWVrU3RhcnRzT246IDEgfSlcbiAgICAgICAgY29uc3QgZm9ybWF0dGVkID0gZm9ybWF0KG1vbmRheSwgJ01NTSBkJykudG9VcHBlckNhc2UoKVxuICAgICAgICBjb25zb2xlLmxvZyhgICAgIPCfk4UgTm9ybWFsaXplZCB3ZWVrIFwiJHt3ZWVrU3RyfVwiIC0+IE1vbmRheTogXCIke2Zvcm1hdHRlZH1cImApXG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWRcbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICAgIC8vIElmIHBhcnNpbmcgZmFpbHMsIHJldHVybiBhcyBpc1xuICAgICAgcmV0dXJuIHdlZWtTdHIudG9VcHBlckNhc2UoKVxuICAgIH1cbiAgfVxuICBcbiAgLy8gSWYgaXQncyBhIERhdGUgb2JqZWN0XG4gIGlmICh3ZWVrVmFsdWUgaW5zdGFuY2VvZiBEYXRlICYmIGlzVmFsaWQod2Vla1ZhbHVlKSkge1xuICAgIGNvbnN0IG1vbmRheSA9IHN0YXJ0T2ZXZWVrKHdlZWtWYWx1ZSwgeyB3ZWVrU3RhcnRzT246IDEgfSlcbiAgICByZXR1cm4gZm9ybWF0KG1vbmRheSwgJ01NTSBkJykudG9VcHBlckNhc2UoKVxuICB9XG4gIFxuICAvLyBJZiBpdCdzIGFuIEV4Y2VsIGRhdGUgbnVtYmVyXG4gIGlmICh0eXBlb2Ygd2Vla1ZhbHVlID09PSAnbnVtYmVyJyAmJiB3ZWVrVmFsdWUgPiAwKSB7XG4gICAgY29uc3QgZXhjZWxEYXRlID0gbmV3IERhdGUoKHdlZWtWYWx1ZSAtIDI1NTY5KSAqIDg2NDAwICogMTAwMClcbiAgICBpZiAoaXNWYWxpZChleGNlbERhdGUpKSB7XG4gICAgICBjb25zdCBtb25kYXkgPSBzdGFydE9mV2VlayhleGNlbERhdGUsIHsgd2Vla1N0YXJ0c09uOiAxIH0pXG4gICAgICByZXR1cm4gZm9ybWF0KG1vbmRheSwgJ01NTSBkJykudG9VcHBlckNhc2UoKVxuICAgIH1cbiAgfVxuICBcbiAgY29uc29sZS53YXJuKGAgIOKaoO+4jyBDb3VsZCBub3QgcGFyc2Ugd2VlayBmb3JtYXQ6IFwiJHt3ZWVrU3RyfVwiLCB1c2luZyBjdXJyZW50IHdlZWtgKVxuICByZXR1cm4gZ2V0Q3VycmVudFdlZWsoKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGFyc2VFeGNlbEZpbGUoZmlsZTogRmlsZSk6IFByb21pc2U8U2NoZWR1bGVEYXRhPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICAgIFxuICAgIHJlYWRlci5vbmxvYWQgPSAoZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfk4ogU3RhcnRpbmcgRXhjZWwgcGFyc2luZy4uLicpXG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShlLnRhcmdldD8ucmVzdWx0IGFzIEFycmF5QnVmZmVyKVxuICAgICAgICBjb25zdCB3b3JrYm9vayA9IFhMU1gucmVhZChkYXRhLCB7IHR5cGU6ICdhcnJheScsIGNlbGxEYXRlczogdHJ1ZSB9KVxuICAgICAgICBjb25zb2xlLmxvZygn8J+TiyBXb3JrYm9vayBzaGVldHMgZm91bmQ6JywgT2JqZWN0LmtleXMod29ya2Jvb2suU2hlZXRzKSlcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VXb3JrYm9vayh3b3JrYm9vaylcbiAgICAgICAgY29uc29sZS5sb2coJ+KchSBQYXJzaW5nIGNvbXBsZXRlOicsIHtcbiAgICAgICAgICBlbXBsb3llZXM6IHJlc3VsdC5lbXBsb3llZXMubGVuZ3RoLFxuICAgICAgICAgIHByb2plY3RzOiByZXN1bHQucHJvamVjdHMubGVuZ3RoLFxuICAgICAgICAgIGFzc2lnbm1lbnRzOiByZXN1bHQuYXNzaWdubWVudHMubGVuZ3RoLFxuICAgICAgICAgIHNraWxsczogcmVzdWx0LnNraWxscy5sZW5ndGgsXG4gICAgICAgICAgdGVhbXM6IHJlc3VsdC50ZWFtcy5sZW5ndGhcbiAgICAgICAgfSlcbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgcGFyc2luZyBFeGNlbDonLCBlcnJvcilcbiAgICAgICAgcmVqZWN0KGVycm9yKVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZWFkZXIub25lcnJvciA9ICgpID0+IHJlamVjdChuZXcgRXJyb3IoJ0ZhaWxlZCB0byByZWFkIGZpbGUnKSlcbiAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoZmlsZSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gcGFyc2VXb3JrYm9vayh3b3JrYm9vazogWExTWC5Xb3JrQm9vayk6IFNjaGVkdWxlRGF0YSB7XG4gIGNvbnN0IHJlc3VsdDogU2NoZWR1bGVEYXRhID0ge1xuICAgIGVtcGxveWVlczogW10sXG4gICAgcHJvamVjdHM6IFtdLFxuICAgIGFzc2lnbm1lbnRzOiBbXSxcbiAgICBza2lsbHM6IFtdLFxuICAgIHRlYW1zOiBbJ0FsbCBUZWFtcyddLFxuICB9XG5cbiAgLy8gUGFyc2UgRW1wbG95ZWVzIHNoZWV0XG4gIGlmICh3b3JrYm9vay5TaGVldHNbJ0VtcGxveWVlcyddKSB7XG4gICAgY29uc3Qgc2hlZXQgPSBYTFNYLnV0aWxzLnNoZWV0X3RvX2pzb24od29ya2Jvb2suU2hlZXRzWydFbXBsb3llZXMnXSlcbiAgICByZXN1bHQuZW1wbG95ZWVzID0gc2hlZXQubWFwKChyb3c6IGFueSkgPT4gKHtcbiAgICAgIGlkOiByb3cuSUQgfHwgcm93LmlkIHx8IGdlbmVyYXRlSWQoKSxcbiAgICAgIG5hbWU6IHJvdy5OYW1lIHx8IHJvdy5FbXBsb3llZSB8fCAnJyxcbiAgICAgIGVtYWlsOiByb3cuRW1haWwgfHwgJycsXG4gICAgICBtYXhIb3VyczogTnVtYmVyKHJvd1snTWF4IEhvdXJzJ10pIHx8IDQwLFxuICAgICAgdGVhbTogcm93LlRlYW0gfHwgJ0RlZmF1bHQnLFxuICAgICAgc2tpbGxzOiBwYXJzZVNraWxscyhyb3cpLFxuICAgIH0pKVxuICB9XG5cbiAgLy8gUGFyc2UgUHJvamVjdHMgc2hlZXRcbiAgaWYgKHdvcmtib29rLlNoZWV0c1snUHJvamVjdHMnXSkge1xuICAgIGNvbnN0IHNoZWV0ID0gWExTWC51dGlscy5zaGVldF90b19qc29uKHdvcmtib29rLlNoZWV0c1snUHJvamVjdHMnXSlcbiAgICByZXN1bHQucHJvamVjdHMgPSBzaGVldC5tYXAoKHJvdzogYW55KSA9PiAoe1xuICAgICAgaWQ6IHJvdy5JRCB8fCByb3cuaWQgfHwgZ2VuZXJhdGVJZCgpLFxuICAgICAgbmFtZTogcm93Lk5hbWUgfHwgcm93LlByb2plY3QgfHwgJycsXG4gICAgICBzdGFydERhdGU6IHBhcnNlRGF0ZShyb3dbJ1N0YXJ0IERhdGUnXSkgfHwgbmV3IERhdGUoKSxcbiAgICAgIGVuZERhdGU6IHBhcnNlRGF0ZShyb3dbJ0VuZCBEYXRlJ10pIHx8IG5ldyBEYXRlKCksXG4gICAgICByZXF1aXJlZFNraWxsczogcm93WydSZXF1aXJlZCBTa2lsbHMnXSBcbiAgICAgICAgPyBTdHJpbmcocm93WydSZXF1aXJlZCBTa2lsbHMnXSkuc3BsaXQoJywnKS5tYXAocyA9PiBzLnRyaW0oKSlcbiAgICAgICAgOiBbXSxcbiAgICAgIHBvcnRmb2xpbzogcm93LlBvcnRmb2xpbyB8fCAnJyxcbiAgICB9KSlcbiAgfVxuXG4gIC8vIFBhcnNlIEFzc2lnbm1lbnRzIHNoZWV0XG4gIGlmICh3b3JrYm9vay5TaGVldHNbJ0Fzc2lnbm1lbnRzJ10pIHtcbiAgICBjb25zb2xlLmxvZygn8J+ThSBQYXJzaW5nIEFzc2lnbm1lbnRzIHNoZWV0Li4uJylcbiAgICBjb25zdCBzaGVldCA9IFhMU1gudXRpbHMuc2hlZXRfdG9fanNvbih3b3JrYm9vay5TaGVldHNbJ0Fzc2lnbm1lbnRzJ10pXG4gICAgY29uc29sZS5sb2coYCAgRm91bmQgJHtzaGVldC5sZW5ndGh9IGFzc2lnbm1lbnQgcm93c2ApXG4gICAgXG4gICAgLy8gTG9nIGZpcnN0IGZldyByb3dzIGZvciBkZWJ1Z2dpbmdcbiAgICBpZiAoc2hlZXQubGVuZ3RoID4gMCkge1xuICAgICAgY29uc29sZS5sb2coJyAgU2FtcGxlIGFzc2lnbm1lbnQgcm93OicsIHNoZWV0WzBdKVxuICAgICAgY29uc29sZS5sb2coJyAgQXNzaWdubWVudCBjb2x1bW4gaGVhZGVyczonLCBPYmplY3Qua2V5cyhzaGVldFswXSkpXG4gICAgfVxuICAgIFxuICAgIHJlc3VsdC5hc3NpZ25tZW50cyA9IHNoZWV0Lm1hcCgocm93OiBhbnksIGluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgIC8vIENoZWNrIGFsbCBwb3NzaWJsZSBjb2x1bW4gbmFtZXMgZm9yIHdlZWsvZGF0ZVxuICAgICAgY29uc3QgcmF3V2VlayA9IHJvdy5XZWVrIHx8IHJvd1snV2VlayddIHx8IHJvdy5EYXRlIHx8IHJvd1snRGF0ZSddIHx8IHJvdy53ZWVrIHx8IHJvdy5kYXRlXG4gICAgICBjb25zdCBub3JtYWxpemVkV2VlayA9IG5vcm1hbGl6ZVdlZWtGb3JtYXQocmF3V2VlaylcbiAgICAgIFxuICAgICAgLy8gUGFyc2UgaG91cnMgd2l0aCBiZXR0ZXIgaGFuZGxpbmdcbiAgICAgIGNvbnN0IHJhd0hvdXJzID0gcm93LkhvdXJzIHx8IHJvd1snSG91cnMnXSB8fCByb3cuaG91cnMgfHwgMFxuICAgICAgY29uc3QgcGFyc2VkSG91cnMgPSB0eXBlb2YgcmF3SG91cnMgPT09ICdzdHJpbmcnID8gcGFyc2VGbG9hdChyYXdIb3VycykgfHwgMCA6IE51bWJlcihyYXdIb3VycykgfHwgMFxuICAgICAgXG4gICAgICBjb25zdCBhc3NpZ25tZW50ID0ge1xuICAgICAgICBpZDogZ2VuZXJhdGVJZCgpLFxuICAgICAgICBlbXBsb3llZUlkOiByb3dbJ0VtcGxveWVlIElEJ10gfHwgcm93LkVtcGxveWVlIHx8IHJvd1snRW1wbG95ZWUnXSB8fCByb3dbJ2VtcGxveWVlJ10gfHwgJycsXG4gICAgICAgIHByb2plY3RJZDogcm93WydQcm9qZWN0IElEJ10gfHwgcm93LlByb2plY3QgfHwgcm93WydQcm9qZWN0J10gfHwgcm93Wydwcm9qZWN0J10gfHwgJycsXG4gICAgICAgIGhvdXJzOiBwYXJzZWRIb3VycyxcbiAgICAgICAgd2Vlazogbm9ybWFsaXplZFdlZWssXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIERlYnVnIGxvZyBmb3IgZmlyc3QgZmV3IGFzc2lnbm1lbnRzXG4gICAgICBpZiAoaW5kZXggPCAzKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGAgIEFzc2lnbm1lbnQgJHtpbmRleCArIDF9OmAsIHtcbiAgICAgICAgICBlbXBsb3llZUlkOiBhc3NpZ25tZW50LmVtcGxveWVlSWQsXG4gICAgICAgICAgcHJvamVjdElkOiBhc3NpZ25tZW50LnByb2plY3RJZCxcbiAgICAgICAgICBob3VyczogYCR7YXNzaWdubWVudC5ob3Vyc30gKHJhdzogXCIke3Jhd0hvdXJzfVwiLCB0eXBlOiAke3R5cGVvZiByYXdIb3Vyc30pYCxcbiAgICAgICAgICByYXdXZWVrOiByYXdXZWVrLFxuICAgICAgICAgIG5vcm1hbGl6ZWRXZWVrOiBhc3NpZ25tZW50LndlZWssXG4gICAgICAgICAgYWxsQ29sdW1uczogT2JqZWN0LmtleXMocm93KS5qb2luKCcsICcpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBhc3NpZ25tZW50XG4gICAgfSlcbiAgICBcbiAgICBjb25zb2xlLmxvZyhgICDinJMgUGFyc2VkICR7cmVzdWx0LmFzc2lnbm1lbnRzLmxlbmd0aH0gYXNzaWdubWVudHNgKVxuICAgIGNvbnNvbGUubG9nKCcgIFVuaXF1ZSB3ZWVrcyBmb3VuZDonLCBbLi4ubmV3IFNldChyZXN1bHQuYXNzaWdubWVudHMubWFwKGEgPT4gYS53ZWVrKSldKVxuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUubG9nKCfimqDvuI8gTm8gQXNzaWdubWVudHMgc2hlZXQgZm91bmQgaW4gd29ya2Jvb2snKVxuICB9XG5cbiAgLy8gUGFyc2UgU2tpbGxzIHNoZWV0IChvcHRpb25hbClcbiAgaWYgKHdvcmtib29rLlNoZWV0c1snU2tpbGxzJ10pIHtcbiAgICBjb25zdCBzaGVldCA9IFhMU1gudXRpbHMuc2hlZXRfdG9fanNvbih3b3JrYm9vay5TaGVldHNbJ1NraWxscyddKVxuICAgIGNvbnN0IHNraWxsU2V0ID0gbmV3IFNldDxzdHJpbmc+KClcbiAgICBcbiAgICBzaGVldC5mb3JFYWNoKChyb3c6IGFueSkgPT4ge1xuICAgICAgT2JqZWN0LmtleXMocm93KS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGlmIChrZXkgIT09ICdFbXBsb3llZScgJiYga2V5ICE9PSAnSUQnICYmIGtleSAhPT0gJ05hbWUnKSB7XG4gICAgICAgICAgc2tpbGxTZXQuYWRkKGtleSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICAgIFxuICAgIHJlc3VsdC5za2lsbHMgPSBBcnJheS5mcm9tKHNraWxsU2V0KVxuICB9IGVsc2Uge1xuICAgIC8vIEV4dHJhY3Qgc2tpbGxzIGZyb20gZW1wbG95ZWVzXG4gICAgY29uc3Qgc2tpbGxTZXQgPSBuZXcgU2V0PHN0cmluZz4oKVxuICAgIHJlc3VsdC5lbXBsb3llZXMuZm9yRWFjaChlbXAgPT4ge1xuICAgICAgT2JqZWN0LmtleXMoZW1wLnNraWxscykuZm9yRWFjaChza2lsbCA9PiBza2lsbFNldC5hZGQoc2tpbGwpKVxuICAgIH0pXG4gICAgcmVzdWx0LnNraWxscyA9IEFycmF5LmZyb20oc2tpbGxTZXQpXG4gIH1cblxuICAvLyBFeHRyYWN0IHRlYW1zXG4gIGNvbnN0IHRlYW1TZXQgPSBuZXcgU2V0KFsnQWxsIFRlYW1zJ10pXG4gIHJlc3VsdC5lbXBsb3llZXMuZm9yRWFjaChlbXAgPT4ge1xuICAgIGlmIChlbXAudGVhbSkgdGVhbVNldC5hZGQoZW1wLnRlYW0pXG4gIH0pXG4gIHJlc3VsdC50ZWFtcyA9IEFycmF5LmZyb20odGVhbVNldClcblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIHBhcnNlU2tpbGxzKHJvdzogYW55KTogUmVjb3JkPHN0cmluZywgUHJvZmljaWVuY3lMZXZlbD4ge1xuICBjb25zdCBza2lsbHM6IFJlY29yZDxzdHJpbmcsIFByb2ZpY2llbmN5TGV2ZWw+ID0ge31cbiAgY29uc3QgZXhjbHVkZUZpZWxkcyA9IFsnTmFtZScsICdFbXBsb3llZScsICdFbWFpbCcsICdJRCcsICdpZCcsICdNYXggSG91cnMnLCAnVGVhbSddXG4gIFxuICBPYmplY3Qua2V5cyhyb3cpLmZvckVhY2goa2V5ID0+IHtcbiAgICBpZiAoIWV4Y2x1ZGVGaWVsZHMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgY29uc3QgdmFsdWUgPSByb3dba2V5XVxuICAgICAgaWYgKHZhbHVlICYmIHZhbHVlICE9PSAnTm9uZScgJiYgdmFsdWUgIT09ICcnKSB7XG4gICAgICAgIC8vIFRyeSB0byBwYXJzZSBhcyBwcm9maWNpZW5jeSBsZXZlbFxuICAgICAgICBpZiAoWydCZWdpbm5lcicsICdJbnRlcm1lZGlhdGUnLCAnRXhwZXJ0J10uaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgICAgc2tpbGxzW2tleV0gPSB2YWx1ZSBhcyBQcm9maWNpZW5jeUxldmVsXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIC8vIENvbnZlcnQgbnVtZXJpYyB2YWx1ZXMgdG8gcHJvZmljaWVuY3kgbGV2ZWxzXG4gICAgICAgICAgaWYgKHZhbHVlID49IDMpIHNraWxsc1trZXldID0gJ0V4cGVydCdcbiAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA+PSAyKSBza2lsbHNba2V5XSA9ICdJbnRlcm1lZGlhdGUnXG4gICAgICAgICAgZWxzZSBpZiAodmFsdWUgPj0gMSkgc2tpbGxzW2tleV0gPSAnQmVnaW5uZXInXG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICAvLyBEZWZhdWx0IHRvIEludGVybWVkaWF0ZSBmb3IgYW55IG90aGVyIG5vbi1lbXB0eSB2YWx1ZVxuICAgICAgICAgIHNraWxsc1trZXldID0gJ0ludGVybWVkaWF0ZSdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgXG4gIHJldHVybiBza2lsbHNcbn0iXSwibmFtZXMiOlsiWExTWCIsImdlbmVyYXRlSWQiLCJwYXJzZURhdGUiLCJnZXRDdXJyZW50V2VlayIsImZvcm1hdCIsInBhcnNlIiwiaXNWYWxpZCIsInN0YXJ0T2ZXZWVrIiwibm9ybWFsaXplRGF0ZVRvTW9uZGF5Iiwid2Vla1ZhbHVlIiwiRGF0ZSIsIm1vbmRheSIsIndlZWtTdGFydHNPbiIsImZvcm1hdHRlZCIsInRvVXBwZXJDYXNlIiwiY29uc29sZSIsImxvZyIsImV4Y2VsRGF0ZSIsIndlZWtTdHIiLCJTdHJpbmciLCJ0cmltIiwidGVzdCIsImRhdGVPbmx5Iiwic3BsaXQiLCJwYXJzZWQiLCJkYXlPZldlZWsiLCJnZXREYXkiLCJpc01vbmRheSIsInRhcmdldERhdGUiLCJlIiwid2FybiIsImRhdGVGb3JtYXRzIiwiZm10IiwicGFyc2VFeGNlbEZpbGUiLCJmaWxlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwib25sb2FkIiwiZGF0YSIsIlVpbnQ4QXJyYXkiLCJ0YXJnZXQiLCJyZXN1bHQiLCJ3b3JrYm9vayIsInJlYWQiLCJ0eXBlIiwiY2VsbERhdGVzIiwiT2JqZWN0Iiwia2V5cyIsIlNoZWV0cyIsInBhcnNlV29ya2Jvb2siLCJlbXBsb3llZXMiLCJsZW5ndGgiLCJwcm9qZWN0cyIsImFzc2lnbm1lbnRzIiwic2tpbGxzIiwidGVhbXMiLCJlcnJvciIsIm9uZXJyb3IiLCJFcnJvciIsInJlYWRBc0FycmF5QnVmZmVyIiwic2hlZXQiLCJ1dGlscyIsInNoZWV0X3RvX2pzb24iLCJtYXAiLCJyb3ciLCJpZCIsIklEIiwibmFtZSIsIk5hbWUiLCJFbXBsb3llZSIsImVtYWlsIiwiRW1haWwiLCJtYXhIb3VycyIsIk51bWJlciIsInRlYW0iLCJUZWFtIiwicGFyc2VTa2lsbHMiLCJQcm9qZWN0Iiwic3RhcnREYXRlIiwiZW5kRGF0ZSIsInJlcXVpcmVkU2tpbGxzIiwicyIsInBvcnRmb2xpbyIsIlBvcnRmb2xpbyIsImluZGV4IiwicmF3V2VlayIsIldlZWsiLCJ3ZWVrIiwiZGF0ZSIsIm5vcm1hbGl6ZWRXZWVrIiwibm9ybWFsaXplV2Vla0Zvcm1hdCIsInJhd0hvdXJzIiwiSG91cnMiLCJob3VycyIsInBhcnNlZEhvdXJzIiwicGFyc2VGbG9hdCIsImFzc2lnbm1lbnQiLCJlbXBsb3llZUlkIiwicHJvamVjdElkIiwiYWxsQ29sdW1ucyIsImpvaW4iLCJTZXQiLCJhIiwic2tpbGxTZXQiLCJmb3JFYWNoIiwia2V5IiwiYWRkIiwiQXJyYXkiLCJmcm9tIiwiZW1wIiwic2tpbGwiLCJ0ZWFtU2V0IiwiZXhjbHVkZUZpZWxkcyIsImluY2x1ZGVzIiwidmFsdWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/excel/parser.ts\n"));

/***/ })

});