"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("common-_app-pages-browser_lib_utils_ts-_app-pages-browser_store_useScheduleStore_ts",{

/***/ "(app-pages-browser)/./store/useScheduleStore.ts":
/*!***********************************!*\
  !*** ./store/useScheduleStore.ts ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useScheduleStore: () => (/* binding */ useScheduleStore)\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/react.mjs\");\n/* harmony import */ var zustand_middleware__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zustand/middleware */ \"(app-pages-browser)/./node_modules/zustand/esm/middleware.mjs\");\n\n\nconst initialState = {\n    employees: [],\n    projects: [],\n    assignments: [],\n    skills: [],\n    teams: [\n        'All Teams'\n    ]\n};\nconst useScheduleStore = (0,zustand__WEBPACK_IMPORTED_MODULE_0__.create)()((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_1__.persist)((set)=>({\n        ...initialState,\n        selectedTeam: 'All Teams',\n        dateRange: null,\n        hasHydrated: false,\n        overtimeSortTrigger: 0,\n        utilizationSortTrigger: 0,\n        loadData: (data)=>{\n            console.log('ðŸ“¦ Storing data in Zustand:', {\n                employees: data.employees.length,\n                projects: data.projects.length,\n                assignments: data.assignments.length,\n                sampleAssignment: data.assignments[0],\n                assignmentStructure: data.assignments.slice(0, 3).map((a)=>({\n                        employeeId: a.employeeId,\n                        projectId: a.projectId,\n                        week: a.week,\n                        hours: a.hours\n                    }))\n            });\n            return set(()=>({\n                    ...data,\n                    teams: [\n                        'All Teams',\n                        ...Array.from(new Set(data.employees.map((e)=>e.team).filter((t)=>Boolean(t))))\n                    ],\n                    // Reset date range when loading new data so it recalculates based on new project dates\n                    dateRange: null\n                }));\n        },\n        setSelectedTeam: (team)=>set({\n                selectedTeam: team\n            }),\n        setDateRange: (range)=>set({\n                dateRange: range\n            }),\n        updateEmployee: (id, data)=>set((state)=>({\n                    employees: state.employees.map((e)=>e.id === id ? {\n                            ...e,\n                            ...data\n                        } : e)\n                })),\n        updateProject: (id, data)=>set((state)=>{\n                const oldProject = state.projects.find((p)=>p.id === id);\n                if (!oldProject) {\n                    return {\n                        projects: state.projects.map((p)=>p.id === id ? {\n                                ...p,\n                                ...data\n                            } : p)\n                    };\n                }\n                // Check if dates are being changed\n                const datesChanged = data.startDate && data.startDate !== oldProject.startDate || data.endDate && data.endDate !== oldProject.endDate;\n                if (datesChanged) {\n                    const oldStartDate = new Date(oldProject.startDate);\n                    const newStartDate = data.startDate ? new Date(data.startDate) : oldStartDate;\n                    const newEndDate = data.endDate ? new Date(data.endDate) : new Date(oldProject.endDate);\n                    // Calculate the week shift if start date changed\n                    const msPerWeek = 7 * 24 * 60 * 60 * 1000;\n                    const weekDifference = data.startDate ? Math.round((newStartDate.getTime() - oldStartDate.getTime()) / msPerWeek) : 0;\n                    // Update assignments for this project\n                    const updatedAssignments = state.assignments.map((a)=>{\n                        // Check if assignment belongs to this project\n                        if (a.projectId === id || a.projectId === oldProject.name) {\n                            let assignmentDate = null;\n                            let newAssignment = {\n                                ...a\n                            };\n                            // First, shift the assignment date if project moved\n                            if (weekDifference !== 0) {\n                                if (a.date) {\n                                    assignmentDate = new Date(a.date);\n                                    const shiftedDate = new Date(assignmentDate.getTime() + weekDifference * msPerWeek);\n                                    const newDateStr = shiftedDate.toISOString().split('T')[0];\n                                    const newWeekStr = shiftedDate.toLocaleDateString('en-US', {\n                                        month: 'short',\n                                        day: 'numeric'\n                                    }).toUpperCase();\n                                    newAssignment = {\n                                        ...newAssignment,\n                                        date: newDateStr,\n                                        week: newWeekStr\n                                    };\n                                    assignmentDate = shiftedDate;\n                                } else {\n                                    // For older data without date field, try to parse week string\n                                    const currentYear = new Date().getFullYear();\n                                    const monthMap = {\n                                        'JAN': 0,\n                                        'FEB': 1,\n                                        'MAR': 2,\n                                        'APR': 3,\n                                        'MAY': 4,\n                                        'JUN': 5,\n                                        'JUL': 6,\n                                        'AUG': 7,\n                                        'SEP': 8,\n                                        'OCT': 9,\n                                        'NOV': 10,\n                                        'DEC': 11\n                                    };\n                                    const parts = a.week.split(' ');\n                                    if (parts.length === 2) {\n                                        const month = monthMap[parts[0]];\n                                        const day = parseInt(parts[1]);\n                                        if (!isNaN(month) && !isNaN(day)) {\n                                            const oldDate = new Date(currentYear, month, day);\n                                            const projectYear = new Date(oldProject.startDate).getFullYear();\n                                            if (Math.abs(currentYear - projectYear) > 1) {\n                                                oldDate.setFullYear(projectYear);\n                                            }\n                                            const shiftedDate = new Date(oldDate.getTime() + weekDifference * msPerWeek);\n                                            const newDateStr = shiftedDate.toISOString().split('T')[0];\n                                            const newWeekStr = shiftedDate.toLocaleDateString('en-US', {\n                                                month: 'short',\n                                                day: 'numeric'\n                                            }).toUpperCase();\n                                            newAssignment = {\n                                                ...newAssignment,\n                                                date: newDateStr,\n                                                week: newWeekStr\n                                            };\n                                            assignmentDate = shiftedDate;\n                                        }\n                                    }\n                                }\n                            } else {\n                                // No shift, just get the current assignment date\n                                if (newAssignment.date) {\n                                    assignmentDate = new Date(newAssignment.date);\n                                }\n                            }\n                            // Now check if the assignment date is within the new project range\n                            // If not, set hours to 0\n                            if (assignmentDate) {\n                                // Add 6 days to get the end of the week (assignments are for full weeks)\n                                const weekEnd = new Date(assignmentDate.getTime() + 6 * 24 * 60 * 60 * 1000);\n                                // Check if the assignment week is outside the new project date range\n                                if (assignmentDate > newEndDate || weekEnd < newStartDate) {\n                                    // Assignment is completely outside project range - zero out hours\n                                    newAssignment = {\n                                        ...newAssignment,\n                                        hours: 0\n                                    };\n                                }\n                            }\n                            return newAssignment;\n                        }\n                        return a;\n                    });\n                    return {\n                        projects: state.projects.map((p)=>p.id === id ? {\n                                ...p,\n                                ...data\n                            } : p),\n                        assignments: updatedAssignments\n                    };\n                }\n                // If no date change, just update the project\n                return {\n                    projects: state.projects.map((p)=>p.id === id ? {\n                            ...p,\n                            ...data\n                        } : p)\n                };\n            }),\n        addProject: (project)=>set((state)=>{\n                // Generate a unique ID for the new project\n                const newId = \"project_\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substr(2, 9));\n                const newProject = {\n                    ...project,\n                    id: newId\n                };\n                return {\n                    projects: [\n                        ...state.projects,\n                        newProject\n                    ]\n                };\n            }),\n        updateAssignment: (id, data)=>set((state)=>({\n                    assignments: state.assignments.map((a)=>a.id === id ? {\n                            ...a,\n                            ...data\n                        } : a)\n                })),\n        addAssignment: (assignment)=>set((state)=>({\n                    assignments: [\n                        ...state.assignments,\n                        assignment\n                    ]\n                })),\n        removeAssignment: (id)=>set((state)=>({\n                    assignments: state.assignments.filter((a)=>a.id !== id)\n                })),\n        clearData: ()=>set(initialState),\n        setHasHydrated: (state)=>set({\n                hasHydrated: state\n            }),\n        setOvertimeSortTrigger: ()=>set((state)=>({\n                    overtimeSortTrigger: state.overtimeSortTrigger + 1,\n                    utilizationSortTrigger: 0 // Reset utilization trigger\n                })),\n        setUtilizationSortTrigger: ()=>set((state)=>({\n                    utilizationSortTrigger: state.utilizationSortTrigger + 1,\n                    overtimeSortTrigger: 0 // Reset overtime trigger\n                }))\n    }), {\n    name: 'schedule-storage',\n    storage: (0,zustand_middleware__WEBPACK_IMPORTED_MODULE_1__.createJSONStorage)(()=>localStorage),\n    partialize: (state)=>({\n            employees: state.employees,\n            projects: state.projects,\n            assignments: state.assignments,\n            skills: state.skills,\n            teams: state.teams,\n            selectedTeam: state.selectedTeam,\n            dateRange: state.dateRange\n        }),\n    onRehydrateStorage: ()=>(state)=>{\n            // Helper to parse date strings as local dates to avoid timezone issues\n            const parseLocalDate = (dateValue)=>{\n                if (dateValue instanceof Date) return dateValue;\n                const dateStr = String(dateValue);\n                // For YYYY-MM-DD format, parse as local date not UTC\n                if (dateStr.match(/^\\d{4}-\\d{2}-\\d{2}$/)) {\n                    const [year, month, day] = dateStr.split('-').map(Number);\n                    return new Date(year, month - 1, day) // month is 0-indexed\n                    ;\n                }\n                return new Date(dateValue);\n            };\n            // Convert date strings back to Date objects after rehydration\n            if (state === null || state === void 0 ? void 0 : state.dateRange) {\n                state.dateRange = {\n                    startDate: parseLocalDate(state.dateRange.startDate),\n                    endDate: parseLocalDate(state.dateRange.endDate)\n                };\n            }\n            // Convert project dates back to Date objects\n            if (state === null || state === void 0 ? void 0 : state.projects) {\n                state.projects = state.projects.map((project)=>({\n                        ...project,\n                        startDate: parseLocalDate(project.startDate),\n                        endDate: parseLocalDate(project.endDate)\n                    }));\n            }\n            state === null || state === void 0 ? void 0 : state.setHasHydrated(true);\n        }\n}));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3N0b3JlL3VzZVNjaGVkdWxlU3RvcmUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdDO0FBQytCO0FBK0IvRCxNQUFNRyxlQUE2QjtJQUNqQ0MsV0FBVyxFQUFFO0lBQ2JDLFVBQVUsRUFBRTtJQUNaQyxhQUFhLEVBQUU7SUFDZkMsUUFBUSxFQUFFO0lBQ1ZDLE9BQU87UUFBQztLQUFZO0FBQ3RCO0FBRU8sTUFBTUMsbUJBQW1CVCwrQ0FBTUEsR0FDcENDLDJEQUFPQSxDQUNMLENBQUNTLE1BQVM7UUFDUixHQUFHUCxZQUFZO1FBQ2ZRLGNBQWM7UUFDZEMsV0FBVztRQUNYQyxhQUFhO1FBQ2JDLHFCQUFxQjtRQUNyQkMsd0JBQXdCO1FBRXhCQyxVQUFVLENBQUNDO1lBQ1RDLFFBQVFDLEdBQUcsQ0FBQywrQkFBK0I7Z0JBQ3pDZixXQUFXYSxLQUFLYixTQUFTLENBQUNnQixNQUFNO2dCQUNoQ2YsVUFBVVksS0FBS1osUUFBUSxDQUFDZSxNQUFNO2dCQUM5QmQsYUFBYVcsS0FBS1gsV0FBVyxDQUFDYyxNQUFNO2dCQUNwQ0Msa0JBQWtCSixLQUFLWCxXQUFXLENBQUMsRUFBRTtnQkFDckNnQixxQkFBcUJMLEtBQUtYLFdBQVcsQ0FBQ2lCLEtBQUssQ0FBQyxHQUFHLEdBQUdDLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBTTt3QkFDMURDLFlBQVlELEVBQUVDLFVBQVU7d0JBQ3hCQyxXQUFXRixFQUFFRSxTQUFTO3dCQUN0QkMsTUFBTUgsRUFBRUcsSUFBSTt3QkFDWkMsT0FBT0osRUFBRUksS0FBSztvQkFDaEI7WUFDRjtZQUVBLE9BQU9uQixJQUFJLElBQU87b0JBQ2hCLEdBQUdPLElBQUk7b0JBQ1BULE9BQU87d0JBQUM7MkJBQWdCc0IsTUFBTUMsSUFBSSxDQUFDLElBQUlDLElBQUlmLEtBQUtiLFNBQVMsQ0FBQ29CLEdBQUcsQ0FBQ1MsQ0FBQUEsSUFBS0EsRUFBRUMsSUFBSSxFQUFFQyxNQUFNLENBQUMsQ0FBQ0MsSUFBbUJD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Q0MsU0FBU3VELGVBQWVuQixRQUFRcEMsT0FBTztvQkFDekM7WUFDRjtZQUVBUCxrQkFBQUEsNEJBQUFBLE1BQU91RCxjQUFjLENBQUM7UUFDeEI7QUFDRixJQUVIIiwic291cmNlcyI6WyIvaG9tZS9wNDcyL1NjaGVkdWxlci9zdG9yZS91c2VTY2hlZHVsZVN0b3JlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZSB9IGZyb20gJ3p1c3RhbmQnXG5pbXBvcnQgeyBwZXJzaXN0LCBjcmVhdGVKU09OU3RvcmFnZSB9IGZyb20gJ3p1c3RhbmQvbWlkZGxld2FyZSdcbmltcG9ydCB0eXBlIHsgU2NoZWR1bGVEYXRhLCBFbXBsb3llZSwgUHJvamVjdCwgQXNzaWdubWVudCB9IGZyb20gJ0AvdHlwZXMvc2NoZWR1bGUnXG5cbmludGVyZmFjZSBEYXRlUmFuZ2Uge1xuICBzdGFydERhdGU6IERhdGVcbiAgZW5kRGF0ZTogRGF0ZVxufVxuXG5pbnRlcmZhY2UgU2NoZWR1bGVTdGF0ZSBleHRlbmRzIFNjaGVkdWxlRGF0YSB7XG4gIHNlbGVjdGVkVGVhbTogc3RyaW5nXG4gIGRhdGVSYW5nZTogRGF0ZVJhbmdlIHwgbnVsbFxuICBoYXNIeWRyYXRlZDogYm9vbGVhblxuICBvdmVydGltZVNvcnRUcmlnZ2VyOiBudW1iZXJcbiAgdXRpbGl6YXRpb25Tb3J0VHJpZ2dlcjogbnVtYmVyXG4gIFxuICAvLyBBY3Rpb25zXG4gIGxvYWREYXRhOiAoZGF0YTogU2NoZWR1bGVEYXRhKSA9PiB2b2lkXG4gIHNldFNlbGVjdGVkVGVhbTogKHRlYW06IHN0cmluZykgPT4gdm9pZFxuICBzZXREYXRlUmFuZ2U6IChyYW5nZTogRGF0ZVJhbmdlIHwgbnVsbCkgPT4gdm9pZFxuICB1cGRhdGVFbXBsb3llZTogKGlkOiBzdHJpbmcsIGRhdGE6IFBhcnRpYWw8RW1wbG95ZWU+KSA9PiB2b2lkXG4gIHVwZGF0ZVByb2plY3Q6IChpZDogc3RyaW5nLCBkYXRhOiBQYXJ0aWFsPFByb2plY3Q+KSA9PiB2b2lkXG4gIGFkZFByb2plY3Q6IChwcm9qZWN0OiBPbWl0PFByb2plY3QsICdpZCc+KSA9PiB2b2lkXG4gIHVwZGF0ZUFzc2lnbm1lbnQ6IChpZDogc3RyaW5nLCBkYXRhOiBQYXJ0aWFsPEFzc2lnbm1lbnQ+KSA9PiB2b2lkXG4gIGFkZEFzc2lnbm1lbnQ6IChhc3NpZ25tZW50OiBBc3NpZ25tZW50KSA9PiB2b2lkXG4gIHJlbW92ZUFzc2lnbm1lbnQ6IChpZDogc3RyaW5nKSA9PiB2b2lkXG4gIGNsZWFyRGF0YTogKCkgPT4gdm9pZFxuICBzZXRIYXNIeWRyYXRlZDogKHN0YXRlOiBib29sZWFuKSA9PiB2b2lkXG4gIHNldE92ZXJ0aW1lU29ydFRyaWdnZXI6ICgpID0+IHZvaWRcbiAgc2V0VXRpbGl6YXRpb25Tb3J0VHJpZ2dlcjogKCkgPT4gdm9pZFxufVxuXG5jb25zdCBpbml0aWFsU3RhdGU6IFNjaGVkdWxlRGF0YSA9IHtcbiAgZW1wbG95ZWVzOiBbXSxcbiAgcHJvamVjdHM6IFtdLFxuICBhc3NpZ25tZW50czogW10sXG4gIHNraWxsczogW10sXG4gIHRlYW1zOiBbJ0FsbCBUZWFtcyddLFxufVxuXG5leHBvcnQgY29uc3QgdXNlU2NoZWR1bGVTdG9yZSA9IGNyZWF0ZTxTY2hlZHVsZVN0YXRlPigpKFxuICBwZXJzaXN0KFxuICAgIChzZXQpID0+ICh7XG4gICAgICAuLi5pbml0aWFsU3RhdGUsXG4gICAgICBzZWxlY3RlZFRlYW06ICdBbGwgVGVhbXMnLFxuICAgICAgZGF0ZVJhbmdlOiBudWxsLFxuICAgICAgaGFzSHlkcmF0ZWQ6IGZhbHNlLFxuICAgICAgb3ZlcnRpbWVTb3J0VHJpZ2dlcjogMCxcbiAgICAgIHV0aWxpemF0aW9uU29ydFRyaWdnZXI6IDAsXG5cbiAgICAgIGxvYWREYXRhOiAoZGF0YSkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygn8J+TpiBTdG9yaW5nIGRhdGEgaW4gWnVzdGFuZDonLCB7XG4gICAgICAgICAgZW1wbG95ZWVzOiBkYXRhLmVtcGxveWVlcy5sZW5ndGgsXG4gICAgICAgICAgcHJvamVjdHM6IGRhdGEucHJvamVjdHMubGVuZ3RoLFxuICAgICAgICAgIGFzc2lnbm1lbnRzOiBkYXRhLmFzc2lnbm1lbnRzLmxlbmd0aCxcbiAgICAgICAgICBzYW1wbGVBc3NpZ25tZW50OiBkYXRhLmFzc2lnbm1lbnRzWzBdLFxuICAgICAgICAgIGFzc2lnbm1lbnRTdHJ1Y3R1cmU6IGRhdGEuYXNzaWdubWVudHMuc2xpY2UoMCwgMykubWFwKGEgPT4gKHtcbiAgICAgICAgICAgIGVtcGxveWVlSWQ6IGEuZW1wbG95ZWVJZCxcbiAgICAgICAgICAgIHByb2plY3RJZDogYS5wcm9qZWN0SWQsXG4gICAgICAgICAgICB3ZWVrOiBhLndlZWssXG4gICAgICAgICAgICBob3VyczogYS5ob3Vyc1xuICAgICAgICAgIH0pKVxuICAgICAgICB9KVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHNldCgoKSA9PiAoe1xuICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgdGVhbXM6IFsnQWxsIFRlYW1zJywgLi4uQXJyYXkuZnJvbShuZXcgU2V0KGRhdGEuZW1wbG95ZWVzLm1hcChlID0+IGUudGVhbSkuZmlsdGVyKCh0KTogdCBpcyBzdHJpbmcgPT4gQm9vbGVhbih0KSkpKV0sXG4gICAgICAgICAgLy8gUmVzZXQgZGF0ZSByYW5nZSB3aGVuIGxvYWRpbmcgbmV3IGRhdGEgc28gaXQgcmVjYWxjdWxhdGVzIGJhc2VkIG9uIG5ldyBwcm9qZWN0IGRhdGVzXG4gICAgICAgICAgZGF0ZVJhbmdlOiBudWxsLFxuICAgICAgICB9KSlcbiAgICAgIH0sXG5cbiAgICAgIHNldFNlbGVjdGVkVGVhbTogKHRlYW0pID0+IHNldCh7IHNlbGVjdGVkVGVhbTogdGVhbSB9KSxcbiAgICAgIFxuICAgICAgc2V0RGF0ZVJhbmdlOiAocmFuZ2UpID0+IHNldCh7IGRhdGVSYW5nZTogcmFuZ2UgfSksXG5cbiAgICAgIHVwZGF0ZUVtcGxveWVlOiAoaWQsIGRhdGEpID0+IHNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgIGVtcGxveWVlczogc3RhdGUuZW1wbG95ZWVzLm1hcChlID0+IFxuICAgICAgICAgIGUuaWQgPT09IGlkID8geyAuLi5lLCAuLi5kYXRhIH0gOiBlXG4gICAgICAgICksXG4gICAgICB9KSksXG5cbiAgICAgIHVwZGF0ZVByb2plY3Q6IChpZCwgZGF0YSkgPT4gc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCBvbGRQcm9qZWN0ID0gc3RhdGUucHJvamVjdHMuZmluZChwID0+IHAuaWQgPT09IGlkKVxuICAgICAgICBcbiAgICAgICAgaWYgKCFvbGRQcm9qZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByb2plY3RzOiBzdGF0ZS5wcm9qZWN0cy5tYXAocCA9PiBcbiAgICAgICAgICAgICAgcC5pZCA9PT0gaWQgPyB7IC4uLnAsIC4uLmRhdGEgfSA6IHBcbiAgICAgICAgICAgICksXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBpZiBkYXRlcyBhcmUgYmVpbmcgY2hhbmdlZFxuICAgICAgICBjb25zdCBkYXRlc0NoYW5nZWQgPSAoZGF0YS5zdGFydERhdGUgJiYgZGF0YS5zdGFydERhdGUgIT09IG9sZFByb2plY3Quc3RhcnREYXRlKSB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChkYXRhLmVuZERhdGUgJiYgZGF0YS5lbmREYXRlICE9PSBvbGRQcm9qZWN0LmVuZERhdGUpXG4gICAgICAgIFxuICAgICAgICBpZiAoZGF0ZXNDaGFuZ2VkKSB7XG4gICAgICAgICAgY29uc3Qgb2xkU3RhcnREYXRlID0gbmV3IERhdGUob2xkUHJvamVjdC5zdGFydERhdGUpXG4gICAgICAgICAgY29uc3QgbmV3U3RhcnREYXRlID0gZGF0YS5zdGFydERhdGUgPyBuZXcgRGF0ZShkYXRhLnN0YXJ0RGF0ZSkgOiBvbGRTdGFydERhdGVcbiAgICAgICAgICBjb25zdCBuZXdFbmREYXRlID0gZGF0YS5lbmREYXRlID8gbmV3IERhdGUoZGF0YS5lbmREYXRlKSA6IG5ldyBEYXRlKG9sZFByb2plY3QuZW5kRGF0ZSlcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHdlZWsgc2hpZnQgaWYgc3RhcnQgZGF0ZSBjaGFuZ2VkXG4gICAgICAgICAgY29uc3QgbXNQZXJXZWVrID0gNyAqIDI0ICogNjAgKiA2MCAqIDEwMDBcbiAgICAgICAgICBjb25zdCB3ZWVrRGlmZmVyZW5jZSA9IGRhdGEuc3RhcnREYXRlID8gXG4gICAgICAgICAgICBNYXRoLnJvdW5kKChuZXdTdGFydERhdGUuZ2V0VGltZSgpIC0gb2xkU3RhcnREYXRlLmdldFRpbWUoKSkgLyBtc1BlcldlZWspIDogMFxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFVwZGF0ZSBhc3NpZ25tZW50cyBmb3IgdGhpcyBwcm9qZWN0XG4gICAgICAgICAgY29uc3QgdXBkYXRlZEFzc2lnbm1lbnRzID0gc3RhdGUuYXNzaWdubWVudHMubWFwKGEgPT4ge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYXNzaWdubWVudCBiZWxvbmdzIHRvIHRoaXMgcHJvamVjdFxuICAgICAgICAgICAgaWYgKGEucHJvamVjdElkID09PSBpZCB8fCBhLnByb2plY3RJZCA9PT0gb2xkUHJvamVjdC5uYW1lKSB7XG4gICAgICAgICAgICAgIGxldCBhc3NpZ25tZW50RGF0ZTogRGF0ZSB8IG51bGwgPSBudWxsXG4gICAgICAgICAgICAgIGxldCBuZXdBc3NpZ25tZW50ID0geyAuLi5hIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIEZpcnN0LCBzaGlmdCB0aGUgYXNzaWdubWVudCBkYXRlIGlmIHByb2plY3QgbW92ZWRcbiAgICAgICAgICAgICAgaWYgKHdlZWtEaWZmZXJlbmNlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGEuZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgYXNzaWdubWVudERhdGUgPSBuZXcgRGF0ZShhLmRhdGUpXG4gICAgICAgICAgICAgICAgICBjb25zdCBzaGlmdGVkRGF0ZSA9IG5ldyBEYXRlKGFzc2lnbm1lbnREYXRlLmdldFRpbWUoKSArICh3ZWVrRGlmZmVyZW5jZSAqIG1zUGVyV2VlaykpXG4gICAgICAgICAgICAgICAgICBjb25zdCBuZXdEYXRlU3RyID0gc2hpZnRlZERhdGUudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdXG4gICAgICAgICAgICAgICAgICBjb25zdCBuZXdXZWVrU3RyID0gc2hpZnRlZERhdGUudG9Mb2NhbGVEYXRlU3RyaW5nKCdlbi1VUycsIHsgXG4gICAgICAgICAgICAgICAgICAgIG1vbnRoOiAnc2hvcnQnLCBcbiAgICAgICAgICAgICAgICAgICAgZGF5OiAnbnVtZXJpYycgXG4gICAgICAgICAgICAgICAgICB9KS50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIG5ld0Fzc2lnbm1lbnQgPSB7IC4uLm5ld0Fzc2lnbm1lbnQsIGRhdGU6IG5ld0RhdGVTdHIsIHdlZWs6IG5ld1dlZWtTdHIgfVxuICAgICAgICAgICAgICAgICAgYXNzaWdubWVudERhdGUgPSBzaGlmdGVkRGF0ZVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBGb3Igb2xkZXIgZGF0YSB3aXRob3V0IGRhdGUgZmllbGQsIHRyeSB0byBwYXJzZSB3ZWVrIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFllYXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKClcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG1vbnRoTWFwOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge1xuICAgICAgICAgICAgICAgICAgICAnSkFOJzogMCwgJ0ZFQic6IDEsICdNQVInOiAyLCAnQVBSJzogMywgJ01BWSc6IDQsICdKVU4nOiA1LFxuICAgICAgICAgICAgICAgICAgICAnSlVMJzogNiwgJ0FVRyc6IDcsICdTRVAnOiA4LCAnT0NUJzogOSwgJ05PVic6IDEwLCAnREVDJzogMTFcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBhLndlZWsuc3BsaXQoJyAnKVxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtb250aCA9IG1vbnRoTWFwW3BhcnRzWzBdXVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXkgPSBwYXJzZUludChwYXJ0c1sxXSlcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOYU4obW9udGgpICYmICFpc05hTihkYXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2xkRGF0ZSA9IG5ldyBEYXRlKGN1cnJlbnRZZWFyLCBtb250aCwgZGF5KVxuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb2plY3RZZWFyID0gbmV3IERhdGUob2xkUHJvamVjdC5zdGFydERhdGUpLmdldEZ1bGxZZWFyKClcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoY3VycmVudFllYXIgLSBwcm9qZWN0WWVhcikgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbGREYXRlLnNldEZ1bGxZZWFyKHByb2plY3RZZWFyKVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaGlmdGVkRGF0ZSA9IG5ldyBEYXRlKG9sZERhdGUuZ2V0VGltZSgpICsgKHdlZWtEaWZmZXJlbmNlICogbXNQZXJXZWVrKSlcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdEYXRlU3RyID0gc2hpZnRlZERhdGUudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdXG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3V2Vla1N0ciA9IHNoaWZ0ZWREYXRlLnRvTG9jYWxlRGF0ZVN0cmluZygnZW4tVVMnLCB7IFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9udGg6ICdzaG9ydCcsIFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF5OiAnbnVtZXJpYycgXG4gICAgICAgICAgICAgICAgICAgICAgfSkudG9VcHBlckNhc2UoKVxuICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgIG5ld0Fzc2lnbm1lbnQgPSB7IC4uLm5ld0Fzc2lnbm1lbnQsIGRhdGU6IG5ld0RhdGVTdHIsIHdlZWs6IG5ld1dlZWtTdHIgfVxuICAgICAgICAgICAgICAgICAgICAgIGFzc2lnbm1lbnREYXRlID0gc2hpZnRlZERhdGVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBObyBzaGlmdCwganVzdCBnZXQgdGhlIGN1cnJlbnQgYXNzaWdubWVudCBkYXRlXG4gICAgICAgICAgICAgICAgaWYgKG5ld0Fzc2lnbm1lbnQuZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgYXNzaWdubWVudERhdGUgPSBuZXcgRGF0ZShuZXdBc3NpZ25tZW50LmRhdGUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBOb3cgY2hlY2sgaWYgdGhlIGFzc2lnbm1lbnQgZGF0ZSBpcyB3aXRoaW4gdGhlIG5ldyBwcm9qZWN0IHJhbmdlXG4gICAgICAgICAgICAgIC8vIElmIG5vdCwgc2V0IGhvdXJzIHRvIDBcbiAgICAgICAgICAgICAgaWYgKGFzc2lnbm1lbnREYXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIDYgZGF5cyB0byBnZXQgdGhlIGVuZCBvZiB0aGUgd2VlayAoYXNzaWdubWVudHMgYXJlIGZvciBmdWxsIHdlZWtzKVxuICAgICAgICAgICAgICAgIGNvbnN0IHdlZWtFbmQgPSBuZXcgRGF0ZShhc3NpZ25tZW50RGF0ZS5nZXRUaW1lKCkgKyAoNiAqIDI0ICogNjAgKiA2MCAqIDEwMDApKVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBhc3NpZ25tZW50IHdlZWsgaXMgb3V0c2lkZSB0aGUgbmV3IHByb2plY3QgZGF0ZSByYW5nZVxuICAgICAgICAgICAgICAgIGlmIChhc3NpZ25tZW50RGF0ZSA+IG5ld0VuZERhdGUgfHwgd2Vla0VuZCA8IG5ld1N0YXJ0RGF0ZSkge1xuICAgICAgICAgICAgICAgICAgLy8gQXNzaWdubWVudCBpcyBjb21wbGV0ZWx5IG91dHNpZGUgcHJvamVjdCByYW5nZSAtIHplcm8gb3V0IGhvdXJzXG4gICAgICAgICAgICAgICAgICBuZXdBc3NpZ25tZW50ID0geyAuLi5uZXdBc3NpZ25tZW50LCBob3VyczogMCB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICByZXR1cm4gbmV3QXNzaWdubWVudFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFcbiAgICAgICAgICB9KVxuICAgICAgICAgIFxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcm9qZWN0czogc3RhdGUucHJvamVjdHMubWFwKHAgPT4gXG4gICAgICAgICAgICAgIHAuaWQgPT09IGlkID8geyAuLi5wLCAuLi5kYXRhIH0gOiBwXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYXNzaWdubWVudHM6IHVwZGF0ZWRBc3NpZ25tZW50c1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gSWYgbm8gZGF0ZSBjaGFuZ2UsIGp1c3QgdXBkYXRlIHRoZSBwcm9qZWN0XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcHJvamVjdHM6IHN0YXRlLnByb2plY3RzLm1hcChwID0+IFxuICAgICAgICAgICAgcC5pZCA9PT0gaWQgPyB7IC4uLnAsIC4uLmRhdGEgfSA6IHBcbiAgICAgICAgICApLFxuICAgICAgICB9XG4gICAgICB9KSxcblxuICAgICAgYWRkUHJvamVjdDogKHByb2plY3QpID0+IHNldCgoc3RhdGUpID0+IHtcbiAgICAgICAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgSUQgZm9yIHRoZSBuZXcgcHJvamVjdFxuICAgICAgICBjb25zdCBuZXdJZCA9IGBwcm9qZWN0XyR7RGF0ZS5ub3coKX1fJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOSl9YFxuICAgICAgICBjb25zdCBuZXdQcm9qZWN0OiBQcm9qZWN0ID0ge1xuICAgICAgICAgIC4uLnByb2plY3QsXG4gICAgICAgICAgaWQ6IG5ld0lkXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwcm9qZWN0czogWy4uLnN0YXRlLnByb2plY3RzLCBuZXdQcm9qZWN0XVxuICAgICAgICB9XG4gICAgICB9KSxcblxuICAgICAgdXBkYXRlQXNzaWdubWVudDogKGlkLCBkYXRhKSA9PiBzZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgICBhc3NpZ25tZW50czogc3RhdGUuYXNzaWdubWVudHMubWFwKGEgPT4gXG4gICAgICAgICAgYS5pZCA9PT0gaWQgPyB7IC4uLmEsIC4uLmRhdGEgfSA6IGFcbiAgICAgICAgKSxcbiAgICAgIH0pKSxcblxuICAgICAgYWRkQXNzaWdubWVudDogKGFzc2lnbm1lbnQpID0+IHNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgIGFzc2lnbm1lbnRzOiBbLi4uc3RhdGUuYXNzaWdubWVudHMsIGFzc2lnbm1lbnRdLFxuICAgICAgfSkpLFxuXG4gICAgICByZW1vdmVBc3NpZ25tZW50OiAoaWQpID0+IHNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgIGFzc2lnbm1lbnRzOiBzdGF0ZS5hc3NpZ25tZW50cy5maWx0ZXIoYSA9PiBhLmlkICE9PSBpZCksXG4gICAgICB9KSksXG5cbiAgICAgIGNsZWFyRGF0YTogKCkgPT4gc2V0KGluaXRpYWxTdGF0ZSksXG4gICAgICBcbiAgICAgIHNldEhhc0h5ZHJhdGVkOiAoc3RhdGUpID0+IHNldCh7IGhhc0h5ZHJhdGVkOiBzdGF0ZSB9KSxcbiAgICAgIFxuICAgICAgc2V0T3ZlcnRpbWVTb3J0VHJpZ2dlcjogKCkgPT4gc2V0KChzdGF0ZSkgPT4gKHsgXG4gICAgICAgIG92ZXJ0aW1lU29ydFRyaWdnZXI6IHN0YXRlLm92ZXJ0aW1lU29ydFRyaWdnZXIgKyAxLFxuICAgICAgICB1dGlsaXphdGlvblNvcnRUcmlnZ2VyOiAwICAvLyBSZXNldCB1dGlsaXphdGlvbiB0cmlnZ2VyXG4gICAgICB9KSksXG4gICAgICBcbiAgICAgIHNldFV0aWxpemF0aW9uU29ydFRyaWdnZXI6ICgpID0+IHNldCgoc3RhdGUpID0+ICh7IFxuICAgICAgICB1dGlsaXphdGlvblNvcnRUcmlnZ2VyOiBzdGF0ZS51dGlsaXphdGlvblNvcnRUcmlnZ2VyICsgMSxcbiAgICAgICAgb3ZlcnRpbWVTb3J0VHJpZ2dlcjogMCAgLy8gUmVzZXQgb3ZlcnRpbWUgdHJpZ2dlclxuICAgICAgfSkpLFxuICAgIH0pLFxuICAgIHtcbiAgICAgIG5hbWU6ICdzY2hlZHVsZS1zdG9yYWdlJyxcbiAgICAgIHN0b3JhZ2U6IGNyZWF0ZUpTT05TdG9yYWdlKCgpID0+IGxvY2FsU3RvcmFnZSksXG4gICAgICBwYXJ0aWFsaXplOiAoc3RhdGUpID0+ICh7XG4gICAgICAgIGVtcGxveWVlczogc3RhdGUuZW1wbG95ZWVzLFxuICAgICAgICBwcm9qZWN0czogc3RhdGUucHJvamVjdHMsXG4gICAgICAgIGFzc2lnbm1lbnRzOiBzdGF0ZS5hc3NpZ25tZW50cyxcbiAgICAgICAgc2tpbGxzOiBzdGF0ZS5za2lsbHMsXG4gICAgICAgIHRlYW1zOiBzdGF0ZS50ZWFtcyxcbiAgICAgICAgc2VsZWN0ZWRUZWFtOiBzdGF0ZS5zZWxlY3RlZFRlYW0sXG4gICAgICAgIGRhdGVSYW5nZTogc3RhdGUuZGF0ZVJhbmdlLFxuICAgICAgfSksXG4gICAgICBvblJlaHlkcmF0ZVN0b3JhZ2U6ICgpID0+IChzdGF0ZSkgPT4ge1xuICAgICAgICAvLyBIZWxwZXIgdG8gcGFyc2UgZGF0ZSBzdHJpbmdzIGFzIGxvY2FsIGRhdGVzIHRvIGF2b2lkIHRpbWV6b25lIGlzc3Vlc1xuICAgICAgICBjb25zdCBwYXJzZUxvY2FsRGF0ZSA9IChkYXRlVmFsdWU6IGFueSk6IERhdGUgPT4ge1xuICAgICAgICAgIGlmIChkYXRlVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSByZXR1cm4gZGF0ZVZhbHVlXG4gICAgICAgICAgY29uc3QgZGF0ZVN0ciA9IFN0cmluZyhkYXRlVmFsdWUpXG4gICAgICAgICAgLy8gRm9yIFlZWVktTU0tREQgZm9ybWF0LCBwYXJzZSBhcyBsb2NhbCBkYXRlIG5vdCBVVENcbiAgICAgICAgICBpZiAoZGF0ZVN0ci5tYXRjaCgvXlxcZHs0fS1cXGR7Mn0tXFxkezJ9JC8pKSB7XG4gICAgICAgICAgICBjb25zdCBbeWVhciwgbW9udGgsIGRheV0gPSBkYXRlU3RyLnNwbGl0KCctJykubWFwKE51bWJlcilcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh5ZWFyLCBtb250aCAtIDEsIGRheSkgLy8gbW9udGggaXMgMC1pbmRleGVkXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlVmFsdWUpXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENvbnZlcnQgZGF0ZSBzdHJpbmdzIGJhY2sgdG8gRGF0ZSBvYmplY3RzIGFmdGVyIHJlaHlkcmF0aW9uXG4gICAgICAgIGlmIChzdGF0ZT8uZGF0ZVJhbmdlKSB7XG4gICAgICAgICAgc3RhdGUuZGF0ZVJhbmdlID0ge1xuICAgICAgICAgICAgc3RhcnREYXRlOiBwYXJzZUxvY2FsRGF0ZShzdGF0ZS5kYXRlUmFuZ2Uuc3RhcnREYXRlKSxcbiAgICAgICAgICAgIGVuZERhdGU6IHBhcnNlTG9jYWxEYXRlKHN0YXRlLmRhdGVSYW5nZS5lbmREYXRlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ29udmVydCBwcm9qZWN0IGRhdGVzIGJhY2sgdG8gRGF0ZSBvYmplY3RzXG4gICAgICAgIGlmIChzdGF0ZT8ucHJvamVjdHMpIHtcbiAgICAgICAgICBzdGF0ZS5wcm9qZWN0cyA9IHN0YXRlLnByb2plY3RzLm1hcChwcm9qZWN0ID0+ICh7XG4gICAgICAgICAgICAuLi5wcm9qZWN0LFxuICAgICAgICAgICAgc3RhcnREYXRlOiBwYXJzZUxvY2FsRGF0ZShwcm9qZWN0LnN0YXJ0RGF0ZSksXG4gICAgICAgICAgICBlbmREYXRlOiBwYXJzZUxvY2FsRGF0ZShwcm9qZWN0LmVuZERhdGUpXG4gICAgICAgICAgfSkpXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHN0YXRlPy5zZXRIYXNIeWRyYXRlZCh0cnVlKVxuICAgICAgfSxcbiAgICB9XG4gIClcbikiXSwibmFtZXMiOlsiY3JlYXRlIiwicGVyc2lzdCIsImNyZWF0ZUpTT05TdG9yYWdlIiwiaW5pdGlhbFN0YXRlIiwiZW1wbG95ZWVzIiwicHJvamVjdHMiLCJhc3NpZ25tZW50cyIsInNraWxscyIsInRlYW1zIiwidXNlU2NoZWR1bGVTdG9yZSIsInNldCIsInNlbGVjdGVkVGVhbSIsImRhdGVSYW5nZSIsImhhc0h5ZHJhdGVkIiwib3ZlcnRpbWVTb3J0VHJpZ2dlciIsInV0aWxpemF0aW9uU29ydFRyaWdnZXIiLCJsb2FkRGF0YSIsImRhdGEiLCJjb25zb2xlIiwibG9nIiwibGVuZ3RoIiwic2FtcGxlQXNzaWdubWVudCIsImFzc2lnbm1lbnRTdHJ1Y3R1cmUiLCJzbGljZSIsIm1hcCIsImEiLCJlbXBsb3llZUlkIiwicHJvamVjdElkIiwid2VlayIsImhvdXJzIiwiQXJyYXkiLCJmcm9tIiwiU2V0IiwiZSIsInRlYW0iLCJmaWx0ZXIiLCJ0IiwiQm9vbGVhbiIsInNldFNlbGVjdGVkVGVhbSIsInNldERhdGVSYW5nZSIsInJhbmdlIiwidXBkYXRlRW1wbG95ZWUiLCJpZCIsInN0YXRlIiwidXBkYXRlUHJvamVjdCIsIm9sZFByb2plY3QiLCJmaW5kIiwicCIsImRhdGVzQ2hhbmdlZCIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJvbGRTdGFydERhdGUiLCJEYXRlIiwibmV3U3RhcnREYXRlIiwibmV3RW5kRGF0ZSIsIm1zUGVyV2VlayIsIndlZWtEaWZmZXJlbmNlIiwiTWF0aCIsInJvdW5kIiwiZ2V0VGltZSIsInVwZGF0ZWRBc3NpZ25tZW50cyIsIm5hbWUiLCJhc3NpZ25tZW50RGF0ZSIsIm5ld0Fzc2lnbm1lbnQiLCJkYXRlIiwic2hpZnRlZERhdGUiLCJuZXdEYXRlU3RyIiwidG9JU09TdHJpbmciLCJzcGxpdCIsIm5ld1dlZWtTdHIiLCJ0b0xvY2FsZURhdGVTdHJpbmciLCJtb250aCIsImRheSIsInRvVXBwZXJDYXNlIiwiY3VycmVudFllYXIiLCJnZXRGdWxsWWVhciIsIm1vbnRoTWFwIiwicGFydHMiLCJwYXJzZUludCIsImlzTmFOIiwib2xkRGF0ZSIsInByb2plY3RZZWFyIiwiYWJzIiwic2V0RnVsbFllYXIiLCJ3ZWVrRW5kIiwiYWRkUHJvamVjdCIsInByb2plY3QiLCJuZXdJZCIsIm5vdyIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyIiwibmV3UHJvamVjdCIsInVwZGF0ZUFzc2lnbm1lbnQiLCJhZGRBc3NpZ25tZW50IiwiYXNzaWdubWVudCIsInJlbW92ZUFzc2lnbm1lbnQiLCJjbGVhckRhdGEiLCJzZXRIYXNIeWRyYXRlZCIsInNldE92ZXJ0aW1lU29ydFRyaWdnZXIiLCJzZXRVdGlsaXphdGlvblNvcnRUcmlnZ2VyIiwic3RvcmFnZSIsImxvY2FsU3RvcmFnZSIsInBhcnRpYWxpemUiLCJvblJlaHlkcmF0ZVN0b3JhZ2UiLCJwYXJzZUxvY2FsRGF0ZSIsImRhdGVWYWx1ZSIsImRhdGVTdHIiLCJTdHJpbmciLCJtYXRjaCIsInllYXIiLCJOdW1iZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./store/useScheduleStore.ts\n"));

/***/ })

});