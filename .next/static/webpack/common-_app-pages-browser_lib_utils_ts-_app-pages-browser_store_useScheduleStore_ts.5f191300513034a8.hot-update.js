"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("common-_app-pages-browser_lib_utils_ts-_app-pages-browser_store_useScheduleStore_ts",{

/***/ "(app-pages-browser)/./store/useScheduleStore.ts":
/*!***********************************!*\
  !*** ./store/useScheduleStore.ts ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useScheduleStore: () => (/* binding */ useScheduleStore)\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/react.mjs\");\n/* harmony import */ var zustand_middleware__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zustand/middleware */ \"(app-pages-browser)/./node_modules/zustand/esm/middleware.mjs\");\n\n\nconst initialState = {\n    employees: [],\n    projects: [],\n    assignments: [],\n    skills: [],\n    teams: [\n        'All Teams'\n    ]\n};\nconst useScheduleStore = (0,zustand__WEBPACK_IMPORTED_MODULE_0__.create)()((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_1__.persist)((set)=>({\n        ...initialState,\n        selectedTeam: 'All Teams',\n        dateRange: null,\n        hasHydrated: false,\n        overtimeSortTrigger: 0,\n        loadData: (data)=>{\n            console.log('ðŸ“¦ Storing data in Zustand:', {\n                employees: data.employees.length,\n                projects: data.projects.length,\n                assignments: data.assignments.length,\n                sampleAssignment: data.assignments[0],\n                assignmentStructure: data.assignments.slice(0, 3).map((a)=>({\n                        employeeId: a.employeeId,\n                        projectId: a.projectId,\n                        week: a.week,\n                        hours: a.hours\n                    }))\n            });\n            return set(()=>({\n                    ...data,\n                    teams: [\n                        'All Teams',\n                        ...Array.from(new Set(data.employees.map((e)=>e.team).filter((t)=>Boolean(t))))\n                    ],\n                    // Reset date range when loading new data so it recalculates based on new project dates\n                    dateRange: null\n                }));\n        },\n        setSelectedTeam: (team)=>set({\n                selectedTeam: team\n            }),\n        setDateRange: (range)=>set({\n                dateRange: range\n            }),\n        updateEmployee: (id, data)=>set((state)=>({\n                    employees: state.employees.map((e)=>e.id === id ? {\n                            ...e,\n                            ...data\n                        } : e)\n                })),\n        updateProject: (id, data)=>set((state)=>{\n                const oldProject = state.projects.find((p)=>p.id === id);\n                if (!oldProject) {\n                    return {\n                        projects: state.projects.map((p)=>p.id === id ? {\n                                ...p,\n                                ...data\n                            } : p)\n                    };\n                }\n                // Check if dates are being changed\n                const datesChanged = data.startDate && data.startDate !== oldProject.startDate || data.endDate && data.endDate !== oldProject.endDate;\n                if (datesChanged) {\n                    const oldStartDate = new Date(oldProject.startDate);\n                    const newStartDate = data.startDate ? new Date(data.startDate) : oldStartDate;\n                    const newEndDate = data.endDate ? new Date(data.endDate) : new Date(oldProject.endDate);\n                    // Calculate the week shift if start date changed\n                    const msPerWeek = 7 * 24 * 60 * 60 * 1000;\n                    const weekDifference = data.startDate ? Math.round((newStartDate.getTime() - oldStartDate.getTime()) / msPerWeek) : 0;\n                    // Update assignments for this project\n                    const updatedAssignments = state.assignments.map((a)=>{\n                        // Check if assignment belongs to this project\n                        if (a.projectId === id || a.projectId === oldProject.name) {\n                            let assignmentDate = null;\n                            let newAssignment = {\n                                ...a\n                            };\n                            // First, shift the assignment date if project moved\n                            if (weekDifference !== 0) {\n                                if (a.date) {\n                                    assignmentDate = new Date(a.date);\n                                    const shiftedDate = new Date(assignmentDate.getTime() + weekDifference * msPerWeek);\n                                    const newDateStr = shiftedDate.toISOString().split('T')[0];\n                                    const newWeekStr = shiftedDate.toLocaleDateString('en-US', {\n                                        month: 'short',\n                                        day: 'numeric'\n                                    }).toUpperCase();\n                                    newAssignment = {\n                                        ...newAssignment,\n                                        date: newDateStr,\n                                        week: newWeekStr\n                                    };\n                                    assignmentDate = shiftedDate;\n                                } else {\n                                    // For older data without date field, try to parse week string\n                                    const currentYear = new Date().getFullYear();\n                                    const monthMap = {\n                                        'JAN': 0,\n                                        'FEB': 1,\n                                        'MAR': 2,\n                                        'APR': 3,\n                                        'MAY': 4,\n                                        'JUN': 5,\n                                        'JUL': 6,\n                                        'AUG': 7,\n                                        'SEP': 8,\n                                        'OCT': 9,\n                                        'NOV': 10,\n                                        'DEC': 11\n                                    };\n                                    const parts = a.week.split(' ');\n                                    if (parts.length === 2) {\n                                        const month = monthMap[parts[0]];\n                                        const day = parseInt(parts[1]);\n                                        if (!isNaN(month) && !isNaN(day)) {\n                                            const oldDate = new Date(currentYear, month, day);\n                                            const projectYear = new Date(oldProject.startDate).getFullYear();\n                                            if (Math.abs(currentYear - projectYear) > 1) {\n                                                oldDate.setFullYear(projectYear);\n                                            }\n                                            const shiftedDate = new Date(oldDate.getTime() + weekDifference * msPerWeek);\n                                            const newDateStr = shiftedDate.toISOString().split('T')[0];\n                                            const newWeekStr = shiftedDate.toLocaleDateString('en-US', {\n                                                month: 'short',\n                                                day: 'numeric'\n                                            }).toUpperCase();\n                                            newAssignment = {\n                                                ...newAssignment,\n                                                date: newDateStr,\n                                                week: newWeekStr\n                                            };\n                                            assignmentDate = shiftedDate;\n                                        }\n                                    }\n                                }\n                            } else {\n                                // No shift, just get the current assignment date\n                                if (newAssignment.date) {\n                                    assignmentDate = new Date(newAssignment.date);\n                                }\n                            }\n                            // Now check if the assignment date is within the new project range\n                            // If not, set hours to 0\n                            if (assignmentDate) {\n                                // Add 6 days to get the end of the week (assignments are for full weeks)\n                                const weekEnd = new Date(assignmentDate.getTime() + 6 * 24 * 60 * 60 * 1000);\n                                // Check if the assignment week is outside the new project date range\n                                if (assignmentDate > newEndDate || weekEnd < newStartDate) {\n                                    // Assignment is completely outside project range - zero out hours\n                                    newAssignment = {\n                                        ...newAssignment,\n                                        hours: 0\n                                    };\n                                }\n                            }\n                            return newAssignment;\n                        }\n                        return a;\n                    });\n                    return {\n                        projects: state.projects.map((p)=>p.id === id ? {\n                                ...p,\n                                ...data\n                            } : p),\n                        assignments: updatedAssignments\n                    };\n                }\n                // If no date change, just update the project\n                return {\n                    projects: state.projects.map((p)=>p.id === id ? {\n                            ...p,\n                            ...data\n                        } : p)\n                };\n            }),\n        addProject: (project)=>set((state)=>{\n                // Generate a unique ID for the new project\n                const newId = \"project_\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substr(2, 9));\n                const newProject = {\n                    ...project,\n                    id: newId\n                };\n                return {\n                    projects: [\n                        ...state.projects,\n                        newProject\n                    ]\n                };\n            }),\n        updateAssignment: (id, data)=>set((state)=>({\n                    assignments: state.assignments.map((a)=>a.id === id ? {\n                            ...a,\n                            ...data\n                        } : a)\n                })),\n        addAssignment: (assignment)=>set((state)=>({\n                    assignments: [\n                        ...state.assignments,\n                        assignment\n                    ]\n                })),\n        removeAssignment: (id)=>set((state)=>({\n                    assignments: state.assignments.filter((a)=>a.id !== id)\n                })),\n        clearData: ()=>set(initialState),\n        setHasHydrated: (state)=>set({\n                hasHydrated: state\n            }),\n        setOvertimeSortTrigger: ()=>set((state)=>({\n                    overtimeSortTrigger: state.overtimeSortTrigger + 1\n                }))\n    }), {\n    name: 'schedule-storage',\n    storage: (0,zustand_middleware__WEBPACK_IMPORTED_MODULE_1__.createJSONStorage)(()=>localStorage),\n    partialize: (state)=>({\n            employees: state.employees,\n            projects: state.projects,\n            assignments: state.assignments,\n            skills: state.skills,\n            teams: state.teams,\n            selectedTeam: state.selectedTeam,\n            dateRange: state.dateRange\n        }),\n    onRehydrateStorage: ()=>(state)=>{\n            // Helper to parse date strings as local dates to avoid timezone issues\n            const parseLocalDate = (dateValue)=>{\n                if (dateValue instanceof Date) return dateValue;\n                const dateStr = String(dateValue);\n                // For YYYY-MM-DD format, parse as local date not UTC\n                if (dateStr.match(/^\\d{4}-\\d{2}-\\d{2}$/)) {\n                    const [year, month, day] = dateStr.split('-').map(Number);\n                    return new Date(year, month - 1, day) // month is 0-indexed\n                    ;\n                }\n                return new Date(dateValue);\n            };\n            // Convert date strings back to Date objects after rehydration\n            if (state === null || state === void 0 ? void 0 : state.dateRange) {\n                state.dateRange = {\n                    startDate: parseLocalDate(state.dateRange.startDate),\n                    endDate: parseLocalDate(state.dateRange.endDate)\n                };\n            }\n            // Convert project dates back to Date objects\n            if (state === null || state === void 0 ? void 0 : state.projects) {\n                state.projects = state.projects.map((project)=>({\n                        ...project,\n                        startDate: parseLocalDate(project.startDate),\n                        endDate: parseLocalDate(project.endDate)\n                    }));\n            }\n            state === null || state === void 0 ? void 0 : state.setHasHydrated(true);\n        }\n}));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3N0b3JlL3VzZVNjaGVkdWxlU3RvcmUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdDO0FBQytCO0FBK0IvRCxNQUFNRyxlQUE2QjtJQUNqQ0MsV0FBVyxFQUFFO0lBQ2JDLFVBQVUsRUFBRTtJQUNaQyxhQUFhLEVBQUU7SUFDZkMsUUFBUSxFQUFFO0lBQ1ZDLE9BQU87UUFBQztLQUFZO0FBQ3RCO0FBRU8sTUFBTUMsbUJBQW1CVCwrQ0FBTUEsR0FDcENDLDJEQUFPQSxDQUNMLENBQUNTLE1BQVM7UUFDUixHQUFHUCxZQUFZO1FBQ2ZRLGNBQWM7UUFDZEMsV0FBVztRQUNYQyxhQUFhO1FBQ2JDLHFCQUFxQjtRQUVyQkMsVUFBVSxDQUFDQztZQUNUQyxRQUFRQyxHQUFHLENBQUMsK0JBQStCO2dCQUN6Q2QsV0FBV1ksS0FBS1osU0FBUyxDQUFDZSxNQUFNO2dCQUNoQ2QsVUFBVVcsS0FBS1gsUUFBUSxDQUFDYyxNQUFNO2dCQUM5QmIsYUFBYVUsS0FBS1YsV0FBVyxDQUFDYSxNQUFNO2dCQUNwQ0Msa0JBQWtCSixLQUFLVixXQUFXLENBQUMsRUFBRTtnQkFDckNlLHFCQUFxQkwsS0FBS1YsV0FBVyxDQUFDZ0IsS0FBSyxDQUFDLEdBQUcsR0FBR0MsR0FBRyxDQUFDQyxDQUFBQSxJQUFNO3dCQUMxREMsWUFBWUQsRUFBRUMsVUFBVTt3QkFDeEJDLFdBQVdGLEVBQUVFLFNBQVM7d0JBQ3RCQyxNQUFNSCxFQUFFRyxJQUFJO3dCQUNaQyxPQUFPSixFQUFFSSxLQUFLO29CQUNoQjtZQUNGO1lBRUEsT0FBT2xCLElBQUksSUFBTztvQkFDaEIsR0FBR00sSUFBSTtvQkFDUFIsT0FBTzt3QkFBQzsyQkFBZ0JxQixNQUFNQyxJQUFJLENBQUMsSUFBSUMsSUFBSWYsS0FBS1osU0FBUyxDQUFDbUIsR0FBRyxDQUFDUyxDQUFBQSxJQUFLQSxFQUFFQyxJQUFJLEVBQUVDLE1BQU0sQ0FBQyxDQUFDQyxJQUFtQkMsUUFBUUQ7cUJBQU07b0JB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Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZSB9IGZyb20gJ3p1c3RhbmQnXG5pbXBvcnQgeyBwZXJzaXN0LCBjcmVhdGVKU09OU3RvcmFnZSB9IGZyb20gJ3p1c3RhbmQvbWlkZGxld2FyZSdcbmltcG9ydCB0eXBlIHsgU2NoZWR1bGVEYXRhLCBFbXBsb3llZSwgUHJvamVjdCwgQXNzaWdubWVudCB9IGZyb20gJ0AvdHlwZXMvc2NoZWR1bGUnXG5cbmludGVyZmFjZSBEYXRlUmFuZ2Uge1xuICBzdGFydERhdGU6IERhdGVcbiAgZW5kRGF0ZTogRGF0ZVxufVxuXG5pbnRlcmZhY2UgU2NoZWR1bGVTdGF0ZSBleHRlbmRzIFNjaGVkdWxlRGF0YSB7XG4gIHNlbGVjdGVkVGVhbTogc3RyaW5nXG4gIGRhdGVSYW5nZTogRGF0ZVJhbmdlIHwgbnVsbFxuICBoYXNIeWRyYXRlZDogYm9vbGVhblxuICBvdmVydGltZVNvcnRUcmlnZ2VyOiBudW1iZXJcbiAgdXRpbGl6YXRpb25Tb3J0VHJpZ2dlcjogbnVtYmVyXG4gIFxuICAvLyBBY3Rpb25zXG4gIGxvYWREYXRhOiAoZGF0YTogU2NoZWR1bGVEYXRhKSA9PiB2b2lkXG4gIHNldFNlbGVjdGVkVGVhbTogKHRlYW06IHN0cmluZykgPT4gdm9pZFxuICBzZXREYXRlUmFuZ2U6IChyYW5nZTogRGF0ZVJhbmdlIHwgbnVsbCkgPT4gdm9pZFxuICB1cGRhdGVFbXBsb3llZTogKGlkOiBzdHJpbmcsIGRhdGE6IFBhcnRpYWw8RW1wbG95ZWU+KSA9PiB2b2lkXG4gIHVwZGF0ZVByb2plY3Q6IChpZDogc3RyaW5nLCBkYXRhOiBQYXJ0aWFsPFByb2plY3Q+KSA9PiB2b2lkXG4gIGFkZFByb2plY3Q6IChwcm9qZWN0OiBPbWl0PFByb2plY3QsICdpZCc+KSA9PiB2b2lkXG4gIHVwZGF0ZUFzc2lnbm1lbnQ6IChpZDogc3RyaW5nLCBkYXRhOiBQYXJ0aWFsPEFzc2lnbm1lbnQ+KSA9PiB2b2lkXG4gIGFkZEFzc2lnbm1lbnQ6IChhc3NpZ25tZW50OiBBc3NpZ25tZW50KSA9PiB2b2lkXG4gIHJlbW92ZUFzc2lnbm1lbnQ6IChpZDogc3RyaW5nKSA9PiB2b2lkXG4gIGNsZWFyRGF0YTogKCkgPT4gdm9pZFxuICBzZXRIYXNIeWRyYXRlZDogKHN0YXRlOiBib29sZWFuKSA9PiB2b2lkXG4gIHNldE92ZXJ0aW1lU29ydFRyaWdnZXI6ICgpID0+IHZvaWRcbiAgc2V0VXRpbGl6YXRpb25Tb3J0VHJpZ2dlcjogKCkgPT4gdm9pZFxufVxuXG5jb25zdCBpbml0aWFsU3RhdGU6IFNjaGVkdWxlRGF0YSA9IHtcbiAgZW1wbG95ZWVzOiBbXSxcbiAgcHJvamVjdHM6IFtdLFxuICBhc3NpZ25tZW50czogW10sXG4gIHNraWxsczogW10sXG4gIHRlYW1zOiBbJ0FsbCBUZWFtcyddLFxufVxuXG5leHBvcnQgY29uc3QgdXNlU2NoZWR1bGVTdG9yZSA9IGNyZWF0ZTxTY2hlZHVsZVN0YXRlPigpKFxuICBwZXJzaXN0KFxuICAgIChzZXQpID0+ICh7XG4gICAgICAuLi5pbml0aWFsU3RhdGUsXG4gICAgICBzZWxlY3RlZFRlYW06ICdBbGwgVGVhbXMnLFxuICAgICAgZGF0ZVJhbmdlOiBudWxsLFxuICAgICAgaGFzSHlkcmF0ZWQ6IGZhbHNlLFxuICAgICAgb3ZlcnRpbWVTb3J0VHJpZ2dlcjogMCxcblxuICAgICAgbG9hZERhdGE6IChkYXRhKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5OmIFN0b3JpbmcgZGF0YSBpbiBadXN0YW5kOicsIHtcbiAgICAgICAgICBlbXBsb3llZXM6IGRhdGEuZW1wbG95ZWVzLmxlbmd0aCxcbiAgICAgICAgICBwcm9qZWN0czogZGF0YS5wcm9qZWN0cy5sZW5ndGgsXG4gICAgICAgICAgYXNzaWdubWVudHM6IGRhdGEuYXNzaWdubWVudHMubGVuZ3RoLFxuICAgICAgICAgIHNhbXBsZUFzc2lnbm1lbnQ6IGRhdGEuYXNzaWdubWVudHNbMF0sXG4gICAgICAgICAgYXNzaWdubWVudFN0cnVjdHVyZTogZGF0YS5hc3NpZ25tZW50cy5zbGljZSgwLCAzKS5tYXAoYSA9PiAoe1xuICAgICAgICAgICAgZW1wbG95ZWVJZDogYS5lbXBsb3llZUlkLFxuICAgICAgICAgICAgcHJvamVjdElkOiBhLnByb2plY3RJZCxcbiAgICAgICAgICAgIHdlZWs6IGEud2VlayxcbiAgICAgICAgICAgIGhvdXJzOiBhLmhvdXJzXG4gICAgICAgICAgfSkpXG4gICAgICAgIH0pXG4gICAgICAgIFxuICAgICAgICByZXR1cm4gc2V0KCgpID0+ICh7XG4gICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICB0ZWFtczogWydBbGwgVGVhbXMnLCAuLi5BcnJheS5mcm9tKG5ldyBTZXQoZGF0YS5lbXBsb3llZXMubWFwKGUgPT4gZS50ZWFtKS5maWx0ZXIoKHQpOiB0IGlzIHN0cmluZyA9PiBCb29sZWFuKHQpKSkpXSxcbiAgICAgICAgICAvLyBSZXNldCBkYXRlIHJhbmdlIHdoZW4gbG9hZGluZyBuZXcgZGF0YSBzbyBpdCByZWNhbGN1bGF0ZXMgYmFzZWQgb24gbmV3IHByb2plY3QgZGF0ZXNcbiAgICAgICAgICBkYXRlUmFuZ2U6IG51bGwsXG4gICAgICAgIH0pKVxuICAgICAgfSxcblxuICAgICAgc2V0U2VsZWN0ZWRUZWFtOiAodGVhbSkgPT4gc2V0KHsgc2VsZWN0ZWRUZWFtOiB0ZWFtIH0pLFxuICAgICAgXG4gICAgICBzZXREYXRlUmFuZ2U6IChyYW5nZSkgPT4gc2V0KHsgZGF0ZVJhbmdlOiByYW5nZSB9KSxcblxuICAgICAgdXBkYXRlRW1wbG95ZWU6IChpZCwgZGF0YSkgPT4gc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgICAgZW1wbG95ZWVzOiBzdGF0ZS5lbXBsb3llZXMubWFwKGUgPT4gXG4gICAgICAgICAgZS5pZCA9PT0gaWQgPyB7IC4uLmUsIC4uLmRhdGEgfSA6IGVcbiAgICAgICAgKSxcbiAgICAgIH0pKSxcblxuICAgICAgdXBkYXRlUHJvamVjdDogKGlkLCBkYXRhKSA9PiBzZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IG9sZFByb2plY3QgPSBzdGF0ZS5wcm9qZWN0cy5maW5kKHAgPT4gcC5pZCA9PT0gaWQpXG4gICAgICAgIFxuICAgICAgICBpZiAoIW9sZFByb2plY3QpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJvamVjdHM6IHN0YXRlLnByb2plY3RzLm1hcChwID0+IFxuICAgICAgICAgICAgICBwLmlkID09PSBpZCA/IHsgLi4ucCwgLi4uZGF0YSB9IDogcFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIGRhdGVzIGFyZSBiZWluZyBjaGFuZ2VkXG4gICAgICAgIGNvbnN0IGRhdGVzQ2hhbmdlZCA9IChkYXRhLnN0YXJ0RGF0ZSAmJiBkYXRhLnN0YXJ0RGF0ZSAhPT0gb2xkUHJvamVjdC5zdGFydERhdGUpIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRhdGEuZW5kRGF0ZSAmJiBkYXRhLmVuZERhdGUgIT09IG9sZFByb2plY3QuZW5kRGF0ZSlcbiAgICAgICAgXG4gICAgICAgIGlmIChkYXRlc0NoYW5nZWQpIHtcbiAgICAgICAgICBjb25zdCBvbGRTdGFydERhdGUgPSBuZXcgRGF0ZShvbGRQcm9qZWN0LnN0YXJ0RGF0ZSlcbiAgICAgICAgICBjb25zdCBuZXdTdGFydERhdGUgPSBkYXRhLnN0YXJ0RGF0ZSA/IG5ldyBEYXRlKGRhdGEuc3RhcnREYXRlKSA6IG9sZFN0YXJ0RGF0ZVxuICAgICAgICAgIGNvbnN0IG5ld0VuZERhdGUgPSBkYXRhLmVuZERhdGUgPyBuZXcgRGF0ZShkYXRhLmVuZERhdGUpIDogbmV3IERhdGUob2xkUHJvamVjdC5lbmREYXRlKVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgd2VlayBzaGlmdCBpZiBzdGFydCBkYXRlIGNoYW5nZWRcbiAgICAgICAgICBjb25zdCBtc1BlcldlZWsgPSA3ICogMjQgKiA2MCAqIDYwICogMTAwMFxuICAgICAgICAgIGNvbnN0IHdlZWtEaWZmZXJlbmNlID0gZGF0YS5zdGFydERhdGUgPyBcbiAgICAgICAgICAgIE1hdGgucm91bmQoKG5ld1N0YXJ0RGF0ZS5nZXRUaW1lKCkgLSBvbGRTdGFydERhdGUuZ2V0VGltZSgpKSAvIG1zUGVyV2VlaykgOiAwXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVXBkYXRlIGFzc2lnbm1lbnRzIGZvciB0aGlzIHByb2plY3RcbiAgICAgICAgICBjb25zdCB1cGRhdGVkQXNzaWdubWVudHMgPSBzdGF0ZS5hc3NpZ25tZW50cy5tYXAoYSA9PiB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBhc3NpZ25tZW50IGJlbG9uZ3MgdG8gdGhpcyBwcm9qZWN0XG4gICAgICAgICAgICBpZiAoYS5wcm9qZWN0SWQgPT09IGlkIHx8IGEucHJvamVjdElkID09PSBvbGRQcm9qZWN0Lm5hbWUpIHtcbiAgICAgICAgICAgICAgbGV0IGFzc2lnbm1lbnREYXRlOiBEYXRlIHwgbnVsbCA9IG51bGxcbiAgICAgICAgICAgICAgbGV0IG5ld0Fzc2lnbm1lbnQgPSB7IC4uLmEgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gRmlyc3QsIHNoaWZ0IHRoZSBhc3NpZ25tZW50IGRhdGUgaWYgcHJvamVjdCBtb3ZlZFxuICAgICAgICAgICAgICBpZiAod2Vla0RpZmZlcmVuY2UgIT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoYS5kYXRlKSB7XG4gICAgICAgICAgICAgICAgICBhc3NpZ25tZW50RGF0ZSA9IG5ldyBEYXRlKGEuZGF0ZSlcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHNoaWZ0ZWREYXRlID0gbmV3IERhdGUoYXNzaWdubWVudERhdGUuZ2V0VGltZSgpICsgKHdlZWtEaWZmZXJlbmNlICogbXNQZXJXZWVrKSlcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0RhdGVTdHIgPSBzaGlmdGVkRGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF1cbiAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1dlZWtTdHIgPSBzaGlmdGVkRGF0ZS50b0xvY2FsZURhdGVTdHJpbmcoJ2VuLVVTJywgeyBcbiAgICAgICAgICAgICAgICAgICAgbW9udGg6ICdzaG9ydCcsIFxuICAgICAgICAgICAgICAgICAgICBkYXk6ICdudW1lcmljJyBcbiAgICAgICAgICAgICAgICAgIH0pLnRvVXBwZXJDYXNlKClcbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgbmV3QXNzaWdubWVudCA9IHsgLi4ubmV3QXNzaWdubWVudCwgZGF0ZTogbmV3RGF0ZVN0ciwgd2VlazogbmV3V2Vla1N0ciB9XG4gICAgICAgICAgICAgICAgICBhc3NpZ25tZW50RGF0ZSA9IHNoaWZ0ZWREYXRlXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIEZvciBvbGRlciBkYXRhIHdpdGhvdXQgZGF0ZSBmaWVsZCwgdHJ5IHRvIHBhcnNlIHdlZWsgc3RyaW5nXG4gICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50WWVhciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKVxuICAgICAgICAgICAgICAgICAgY29uc3QgbW9udGhNYXA6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7XG4gICAgICAgICAgICAgICAgICAgICdKQU4nOiAwLCAnRkVCJzogMSwgJ01BUic6IDIsICdBUFInOiAzLCAnTUFZJzogNCwgJ0pVTic6IDUsXG4gICAgICAgICAgICAgICAgICAgICdKVUwnOiA2LCAnQVVHJzogNywgJ1NFUCc6IDgsICdPQ1QnOiA5LCAnTk9WJzogMTAsICdERUMnOiAxMVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGEud2Vlay5zcGxpdCgnICcpXG4gICAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vbnRoID0gbW9udGhNYXBbcGFydHNbMF1dXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRheSA9IHBhcnNlSW50KHBhcnRzWzFdKVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05hTihtb250aCkgJiYgIWlzTmFOKGRheSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGREYXRlID0gbmV3IERhdGUoY3VycmVudFllYXIsIG1vbnRoLCBkYXkpXG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvamVjdFllYXIgPSBuZXcgRGF0ZShvbGRQcm9qZWN0LnN0YXJ0RGF0ZSkuZ2V0RnVsbFllYXIoKVxuICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhjdXJyZW50WWVhciAtIHByb2plY3RZZWFyKSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZERhdGUuc2V0RnVsbFllYXIocHJvamVjdFllYXIpXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNoaWZ0ZWREYXRlID0gbmV3IERhdGUob2xkRGF0ZS5nZXRUaW1lKCkgKyAod2Vla0RpZmZlcmVuY2UgKiBtc1BlcldlZWspKVxuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0RhdGVTdHIgPSBzaGlmdGVkRGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF1cbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdXZWVrU3RyID0gc2hpZnRlZERhdGUudG9Mb2NhbGVEYXRlU3RyaW5nKCdlbi1VUycsIHsgXG4gICAgICAgICAgICAgICAgICAgICAgICBtb250aDogJ3Nob3J0JywgXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXk6ICdudW1lcmljJyBcbiAgICAgICAgICAgICAgICAgICAgICB9KS50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgbmV3QXNzaWdubWVudCA9IHsgLi4ubmV3QXNzaWdubWVudCwgZGF0ZTogbmV3RGF0ZVN0ciwgd2VlazogbmV3V2Vla1N0ciB9XG4gICAgICAgICAgICAgICAgICAgICAgYXNzaWdubWVudERhdGUgPSBzaGlmdGVkRGF0ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5vIHNoaWZ0LCBqdXN0IGdldCB0aGUgY3VycmVudCBhc3NpZ25tZW50IGRhdGVcbiAgICAgICAgICAgICAgICBpZiAobmV3QXNzaWdubWVudC5kYXRlKSB7XG4gICAgICAgICAgICAgICAgICBhc3NpZ25tZW50RGF0ZSA9IG5ldyBEYXRlKG5ld0Fzc2lnbm1lbnQuZGF0ZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIE5vdyBjaGVjayBpZiB0aGUgYXNzaWdubWVudCBkYXRlIGlzIHdpdGhpbiB0aGUgbmV3IHByb2plY3QgcmFuZ2VcbiAgICAgICAgICAgICAgLy8gSWYgbm90LCBzZXQgaG91cnMgdG8gMFxuICAgICAgICAgICAgICBpZiAoYXNzaWdubWVudERhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgNiBkYXlzIHRvIGdldCB0aGUgZW5kIG9mIHRoZSB3ZWVrIChhc3NpZ25tZW50cyBhcmUgZm9yIGZ1bGwgd2Vla3MpXG4gICAgICAgICAgICAgICAgY29uc3Qgd2Vla0VuZCA9IG5ldyBEYXRlKGFzc2lnbm1lbnREYXRlLmdldFRpbWUoKSArICg2ICogMjQgKiA2MCAqIDYwICogMTAwMCkpXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGFzc2lnbm1lbnQgd2VlayBpcyBvdXRzaWRlIHRoZSBuZXcgcHJvamVjdCBkYXRlIHJhbmdlXG4gICAgICAgICAgICAgICAgaWYgKGFzc2lnbm1lbnREYXRlID4gbmV3RW5kRGF0ZSB8fCB3ZWVrRW5kIDwgbmV3U3RhcnREYXRlKSB7XG4gICAgICAgICAgICAgICAgICAvLyBBc3NpZ25tZW50IGlzIGNvbXBsZXRlbHkgb3V0c2lkZSBwcm9qZWN0IHJhbmdlIC0gemVybyBvdXQgaG91cnNcbiAgICAgICAgICAgICAgICAgIG5ld0Fzc2lnbm1lbnQgPSB7IC4uLm5ld0Fzc2lnbm1lbnQsIGhvdXJzOiAwIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHJldHVybiBuZXdBc3NpZ25tZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYVxuICAgICAgICAgIH0pXG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByb2plY3RzOiBzdGF0ZS5wcm9qZWN0cy5tYXAocCA9PiBcbiAgICAgICAgICAgICAgcC5pZCA9PT0gaWQgPyB7IC4uLnAsIC4uLmRhdGEgfSA6IHBcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBhc3NpZ25tZW50czogdXBkYXRlZEFzc2lnbm1lbnRzXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBJZiBubyBkYXRlIGNoYW5nZSwganVzdCB1cGRhdGUgdGhlIHByb2plY3RcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwcm9qZWN0czogc3RhdGUucHJvamVjdHMubWFwKHAgPT4gXG4gICAgICAgICAgICBwLmlkID09PSBpZCA/IHsgLi4ucCwgLi4uZGF0YSB9IDogcFxuICAgICAgICAgICksXG4gICAgICAgIH1cbiAgICAgIH0pLFxuXG4gICAgICBhZGRQcm9qZWN0OiAocHJvamVjdCkgPT4gc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgICAvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBJRCBmb3IgdGhlIG5ldyBwcm9qZWN0XG4gICAgICAgIGNvbnN0IG5ld0lkID0gYHByb2plY3RfJHtEYXRlLm5vdygpfV8ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KX1gXG4gICAgICAgIGNvbnN0IG5ld1Byb2plY3Q6IFByb2plY3QgPSB7XG4gICAgICAgICAgLi4ucHJvamVjdCxcbiAgICAgICAgICBpZDogbmV3SWRcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHByb2plY3RzOiBbLi4uc3RhdGUucHJvamVjdHMsIG5ld1Byb2plY3RdXG4gICAgICAgIH1cbiAgICAgIH0pLFxuXG4gICAgICB1cGRhdGVBc3NpZ25tZW50OiAoaWQsIGRhdGEpID0+IHNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgIGFzc2lnbm1lbnRzOiBzdGF0ZS5hc3NpZ25tZW50cy5tYXAoYSA9PiBcbiAgICAgICAgICBhLmlkID09PSBpZCA/IHsgLi4uYSwgLi4uZGF0YSB9IDogYVxuICAgICAgICApLFxuICAgICAgfSkpLFxuXG4gICAgICBhZGRBc3NpZ25tZW50OiAoYXNzaWdubWVudCkgPT4gc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgICAgYXNzaWdubWVudHM6IFsuLi5zdGF0ZS5hc3NpZ25tZW50cywgYXNzaWdubWVudF0sXG4gICAgICB9KSksXG5cbiAgICAgIHJlbW92ZUFzc2lnbm1lbnQ6IChpZCkgPT4gc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgICAgYXNzaWdubWVudHM6IHN0YXRlLmFzc2lnbm1lbnRzLmZpbHRlcihhID0+IGEuaWQgIT09IGlkKSxcbiAgICAgIH0pKSxcblxuICAgICAgY2xlYXJEYXRhOiAoKSA9PiBzZXQoaW5pdGlhbFN0YXRlKSxcbiAgICAgIFxuICAgICAgc2V0SGFzSHlkcmF0ZWQ6IChzdGF0ZSkgPT4gc2V0KHsgaGFzSHlkcmF0ZWQ6IHN0YXRlIH0pLFxuICAgICAgXG4gICAgICBzZXRPdmVydGltZVNvcnRUcmlnZ2VyOiAoKSA9PiBzZXQoKHN0YXRlKSA9PiAoeyBvdmVydGltZVNvcnRUcmlnZ2VyOiBzdGF0ZS5vdmVydGltZVNvcnRUcmlnZ2VyICsgMSB9KSksXG4gICAgfSksXG4gICAge1xuICAgICAgbmFtZTogJ3NjaGVkdWxlLXN0b3JhZ2UnLFxuICAgICAgc3RvcmFnZTogY3JlYXRlSlNPTlN0b3JhZ2UoKCkgPT4gbG9jYWxTdG9yYWdlKSxcbiAgICAgIHBhcnRpYWxpemU6IChzdGF0ZSkgPT4gKHtcbiAgICAgICAgZW1wbG95ZWVzOiBzdGF0ZS5lbXBsb3llZXMsXG4gICAgICAgIHByb2plY3RzOiBzdGF0ZS5wcm9qZWN0cyxcbiAgICAgICAgYXNzaWdubWVudHM6IHN0YXRlLmFzc2lnbm1lbnRzLFxuICAgICAgICBza2lsbHM6IHN0YXRlLnNraWxscyxcbiAgICAgICAgdGVhbXM6IHN0YXRlLnRlYW1zLFxuICAgICAgICBzZWxlY3RlZFRlYW06IHN0YXRlLnNlbGVjdGVkVGVhbSxcbiAgICAgICAgZGF0ZVJhbmdlOiBzdGF0ZS5kYXRlUmFuZ2UsXG4gICAgICB9KSxcbiAgICAgIG9uUmVoeWRyYXRlU3RvcmFnZTogKCkgPT4gKHN0YXRlKSA9PiB7XG4gICAgICAgIC8vIEhlbHBlciB0byBwYXJzZSBkYXRlIHN0cmluZ3MgYXMgbG9jYWwgZGF0ZXMgdG8gYXZvaWQgdGltZXpvbmUgaXNzdWVzXG4gICAgICAgIGNvbnN0IHBhcnNlTG9jYWxEYXRlID0gKGRhdGVWYWx1ZTogYW55KTogRGF0ZSA9PiB7XG4gICAgICAgICAgaWYgKGRhdGVWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHJldHVybiBkYXRlVmFsdWVcbiAgICAgICAgICBjb25zdCBkYXRlU3RyID0gU3RyaW5nKGRhdGVWYWx1ZSlcbiAgICAgICAgICAvLyBGb3IgWVlZWS1NTS1ERCBmb3JtYXQsIHBhcnNlIGFzIGxvY2FsIGRhdGUgbm90IFVUQ1xuICAgICAgICAgIGlmIChkYXRlU3RyLm1hdGNoKC9eXFxkezR9LVxcZHsyfS1cXGR7Mn0kLykpIHtcbiAgICAgICAgICAgIGNvbnN0IFt5ZWFyLCBtb250aCwgZGF5XSA9IGRhdGVTdHIuc3BsaXQoJy0nKS5tYXAoTnVtYmVyKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHllYXIsIG1vbnRoIC0gMSwgZGF5KSAvLyBtb250aCBpcyAwLWluZGV4ZWRcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGRhdGVWYWx1ZSlcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ29udmVydCBkYXRlIHN0cmluZ3MgYmFjayB0byBEYXRlIG9iamVjdHMgYWZ0ZXIgcmVoeWRyYXRpb25cbiAgICAgICAgaWYgKHN0YXRlPy5kYXRlUmFuZ2UpIHtcbiAgICAgICAgICBzdGF0ZS5kYXRlUmFuZ2UgPSB7XG4gICAgICAgICAgICBzdGFydERhdGU6IHBhcnNlTG9jYWxEYXRlKHN0YXRlLmRhdGVSYW5nZS5zdGFydERhdGUpLFxuICAgICAgICAgICAgZW5kRGF0ZTogcGFyc2VMb2NhbERhdGUoc3RhdGUuZGF0ZVJhbmdlLmVuZERhdGUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDb252ZXJ0IHByb2plY3QgZGF0ZXMgYmFjayB0byBEYXRlIG9iamVjdHNcbiAgICAgICAgaWYgKHN0YXRlPy5wcm9qZWN0cykge1xuICAgICAgICAgIHN0YXRlLnByb2plY3RzID0gc3RhdGUucHJvamVjdHMubWFwKHByb2plY3QgPT4gKHtcbiAgICAgICAgICAgIC4uLnByb2plY3QsXG4gICAgICAgICAgICBzdGFydERhdGU6IHBhcnNlTG9jYWxEYXRlKHByb2plY3Quc3RhcnREYXRlKSxcbiAgICAgICAgICAgIGVuZERhdGU6IHBhcnNlTG9jYWxEYXRlKHByb2plY3QuZW5kRGF0ZSlcbiAgICAgICAgICB9KSlcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgc3RhdGU/LnNldEhhc0h5ZHJhdGVkKHRydWUpXG4gICAgICB9LFxuICAgIH1cbiAgKVxuKSJdLCJuYW1lcyI6WyJjcmVhdGUiLCJwZXJzaXN0IiwiY3JlYXRlSlNPTlN0b3JhZ2UiLCJpbml0aWFsU3RhdGUiLCJlbXBsb3llZXMiLCJwcm9qZWN0cyIsImFzc2lnbm1lbnRzIiwic2tpbGxzIiwidGVhbXMiLCJ1c2VTY2hlZHVsZVN0b3JlIiwic2V0Iiwic2VsZWN0ZWRUZWFtIiwiZGF0ZVJhbmdlIiwiaGFzSHlkcmF0ZWQiLCJvdmVydGltZVNvcnRUcmlnZ2VyIiwibG9hZERhdGEiLCJkYXRhIiwiY29uc29sZSIsImxvZyIsImxlbmd0aCIsInNhbXBsZUFzc2lnbm1lbnQiLCJhc3NpZ25tZW50U3RydWN0dXJlIiwic2xpY2UiLCJtYXAiLCJhIiwiZW1wbG95ZWVJZCIsInByb2plY3RJZCIsIndlZWsiLCJob3VycyIsIkFycmF5IiwiZnJvbSIsIlNldCIsImUiLCJ0ZWFtIiwiZmlsdGVyIiwidCIsIkJvb2xlYW4iLCJzZXRTZWxlY3RlZFRlYW0iLCJzZXREYXRlUmFuZ2UiLCJyYW5nZSIsInVwZGF0ZUVtcGxveWVlIiwiaWQiLCJzdGF0ZSIsInVwZGF0ZVByb2plY3QiLCJvbGRQcm9qZWN0IiwiZmluZCIsInAiLCJkYXRlc0NoYW5nZWQiLCJzdGFydERhdGUiLCJlbmREYXRlIiwib2xkU3RhcnREYXRlIiwiRGF0ZSIsIm5ld1N0YXJ0RGF0ZSIsIm5ld0VuZERhdGUiLCJtc1BlcldlZWsiLCJ3ZWVrRGlmZmVyZW5jZSIsIk1hdGgiLCJyb3VuZCIsImdldFRpbWUiLCJ1cGRhdGVkQXNzaWdubWVudHMiLCJuYW1lIiwiYXNzaWdubWVudERhdGUiLCJuZXdBc3NpZ25tZW50IiwiZGF0ZSIsInNoaWZ0ZWREYXRlIiwibmV3RGF0ZVN0ciIsInRvSVNPU3RyaW5nIiwic3BsaXQiLCJuZXdXZWVrU3RyIiwidG9Mb2NhbGVEYXRlU3RyaW5nIiwibW9udGgiLCJkYXkiLCJ0b1VwcGVyQ2FzZSIsImN1cnJlbnRZZWFyIiwiZ2V0RnVsbFllYXIiLCJtb250aE1hcCIsInBhcnRzIiwicGFyc2VJbnQiLCJpc05hTiIsIm9sZERhdGUiLCJwcm9qZWN0WWVhciIsImFicyIsInNldEZ1bGxZZWFyIiwid2Vla0VuZCIsImFkZFByb2plY3QiLCJwcm9qZWN0IiwibmV3SWQiLCJub3ciLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0ciIsIm5ld1Byb2plY3QiLCJ1cGRhdGVBc3NpZ25tZW50IiwiYWRkQXNzaWdubWVudCIsImFzc2lnbm1lbnQiLCJyZW1vdmVBc3NpZ25tZW50IiwiY2xlYXJEYXRhIiwic2V0SGFzSHlkcmF0ZWQiLCJzZXRPdmVydGltZVNvcnRUcmlnZ2VyIiwic3RvcmFnZSIsImxvY2FsU3RvcmFnZSIsInBhcnRpYWxpemUiLCJvblJlaHlkcmF0ZVN0b3JhZ2UiLCJwYXJzZUxvY2FsRGF0ZSIsImRhdGVWYWx1ZSIsImRhdGVTdHIiLCJTdHJpbmciLCJtYXRjaCIsInllYXIiLCJOdW1iZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./store/useScheduleStore.ts\n"));

/***/ })

});