/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_lib_excel_parser_ts"],{

/***/ "(app-pages-browser)/./lib/date-utils.ts":
/*!***************************!*\
  !*** ./lib/date-utils.ts ***!
  \***************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   areSameDay: () => (/* binding */ areSameDay),\n/* harmony export */   daysBetween: () => (/* binding */ daysBetween),\n/* harmony export */   formatDate: () => (/* binding */ formatDate),\n/* harmony export */   getMondayOfWeek: () => (/* binding */ getMondayOfWeek),\n/* harmony export */   getWeekIdentifier: () => (/* binding */ getWeekIdentifier),\n/* harmony export */   isValidDateString: () => (/* binding */ isValidDateString),\n/* harmony export */   normalizeDateToWeek: () => (/* binding */ normalizeDateToWeek),\n/* harmony export */   parseFlexibleDate: () => (/* binding */ parseFlexibleDate)\n/* harmony export */ });\n/* harmony import */ var _barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! __barrel_optimize__?names=format,isValid,parse,startOfWeek!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/isValid.js\");\n/* harmony import */ var _barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! __barrel_optimize__?names=format,isValid,parse,startOfWeek!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/parse.js\");\n/* harmony import */ var _barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! __barrel_optimize__?names=format,isValid,parse,startOfWeek!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/format.js\");\n/* harmony import */ var _barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! __barrel_optimize__?names=format,isValid,parse,startOfWeek!=!date-fns */ \"(app-pages-browser)/./node_modules/date-fns/startOfWeek.js\");\n\n/**\n * Parses various date formats into a Date object\n * Supports Excel dates, ISO strings, and common date formats\n */ function parseFlexibleDate(dateValue) {\n    if (!dateValue) return null;\n    // Already a valid Date object\n    if (dateValue instanceof Date && (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_0__.isValid)(dateValue)) {\n        return dateValue;\n    }\n    // Excel date number (days since 1900-01-01, with Excel's leap year bug)\n    if (typeof dateValue === 'number' && dateValue > 0) {\n        // Excel dates: number of days since 1900-01-01 (with leap year bug for 1900)\n        const excelEpoch = new Date(1900, 0, 1);\n        const msPerDay = 24 * 60 * 60 * 1000;\n        // Subtract 2 to account for Excel's leap year bug (1900 not a leap year) and 0-indexing\n        const date = new Date(excelEpoch.getTime() + (dateValue - 2) * msPerDay);\n        if ((0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_0__.isValid)(date)) return date;\n    }\n    // String date\n    if (typeof dateValue === 'string') {\n        const dateStr = dateValue.trim();\n        // Try parsing as ISO date\n        const isoDate = new Date(dateStr);\n        if ((0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_0__.isValid)(isoDate)) {\n            return isoDate;\n        }\n        // Try common date formats\n        const formats = [\n            'yyyy-MM-dd',\n            'MM/dd/yyyy',\n            'M/d/yyyy',\n            'dd/MM/yyyy',\n            'd/M/yyyy',\n            'MMM d yyyy',\n            'd-MMM-yyyy',\n            'yyyy/MM/dd',\n            'dd-MM-yyyy',\n            'MM-dd-yyyy'\n        ];\n        for (const fmt of formats){\n            try {\n                const parsed = (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_1__.parse)(dateStr, fmt, new Date());\n                if ((0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_0__.isValid)(parsed)) {\n                    return parsed;\n                }\n            } catch (e) {\n            // Continue to next format\n            }\n        }\n    }\n    return null;\n}\n/**\n * Formats a date consistently as yyyy-MM-dd\n */ function formatDate(date) {\n    const parsed = typeof date === 'string' || typeof date === 'number' ? parseFlexibleDate(date) : date;\n    if (!parsed || !(0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_0__.isValid)(parsed)) {\n        return (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_2__.format)(new Date(), 'yyyy-MM-dd');\n    }\n    return (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_2__.format)(parsed, 'yyyy-MM-dd');\n}\n/**\n * Gets the Monday of the week for a given date\n */ function getMondayOfWeek(date) {\n    const parsed = typeof date === 'string' || typeof date === 'number' ? parseFlexibleDate(date) : date;\n    if (!parsed || !(0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_0__.isValid)(parsed)) {\n        return (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_3__.startOfWeek)(new Date(), {\n            weekStartsOn: 1\n        });\n    }\n    return (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_3__.startOfWeek)(parsed, {\n        weekStartsOn: 1\n    });\n}\n/**\n * Gets week identifier in format \"YYYY-WW\"\n */ function getWeekIdentifier(date) {\n    const monday = getMondayOfWeek(date);\n    return (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_2__.format)(monday, \"yyyy-'W'II\");\n}\n/**\n * Normalizes a date to Monday of its week and returns both date and week strings\n */ function normalizeDateToWeek(dateValue) {\n    const parsed = parseFlexibleDate(dateValue);\n    if (!parsed) {\n        // Fallback to current week\n        const now = new Date();\n        const monday = getMondayOfWeek(now);\n        return {\n            date: formatDate(monday),\n            week: getWeekIdentifier(monday)\n        };\n    }\n    const monday = getMondayOfWeek(parsed);\n    return {\n        date: formatDate(monday),\n        week: getWeekIdentifier(monday)\n    };\n}\n/**\n * Checks if a date string is in a valid format\n */ function isValidDateString(dateStr) {\n    const parsed = parseFlexibleDate(dateStr);\n    return parsed !== null && (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_0__.isValid)(parsed);\n}\n/**\n * Compares two dates for equality (ignoring time)\n */ function areSameDay(date1, date2) {\n    const d1 = parseFlexibleDate(date1);\n    const d2 = parseFlexibleDate(date2);\n    if (!d1 || !d2) return false;\n    return formatDate(d1) === formatDate(d2);\n}\n/**\n * Gets the number of days between two dates\n */ function daysBetween(startDate, endDate) {\n    const start = parseFlexibleDate(startDate);\n    const end = parseFlexibleDate(endDate);\n    if (!start || !end) return 0;\n    const msPerDay = 24 * 60 * 60 * 1000;\n    return Math.floor((end.getTime() - start.getTime()) / msPerDay);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TSxTQUFTSSxrQkFBa0JkLE9BQWU7SUFDL0MsTUFBTUssU0FBU1osa0JBQWtCTztJQUNqQyxPQUFPSyxXQUFXLFFBQVFkLHlHQUFPQSxDQUFDYztBQUNwQztBQUVBOztDQUVDLEdBQ00sU0FBU1UsV0FBV0MsS0FBNkIsRUFBRUMsS0FBNkI7SUFDckYsTUFBTUMsS0FBS3pCLGtCQUFrQnVCO0lBQzdCLE1BQU1HLEtBQUsxQixrQkFBa0J3QjtJQUU3QixJQUFJLENBQUNDLE1BQU0sQ0FBQ0MsSUFBSSxPQUFPO0lBRXZCLE9BQU9iLFdBQVdZLFFBQVFaLFdBQVdhO0FBQ3ZDO0FBRUE7O0NBRUMsR0FDTSxTQUFTQyxZQUFZQyxTQUFpQyxFQUFFQyxPQUErQjtJQUM1RixNQUFNQyxRQUFROUIsa0JBQWtCNEI7SUFDaEMsTUFBTUcsTUFBTS9CLGtCQUFrQjZCO0lBRTlCLElBQUksQ0FBQ0MsU0FBUyxDQUFDQyxLQUFLLE9BQU87SUFFM0IsTUFBTTNCLFdBQVcsS0FBSyxLQUFLLEtBQUs7SUFDaEMsT0FBTzRCLEtBQUtDLEtBQUssQ0FBQyxDQUFDRixJQUFJekIsT0FBTyxLQUFLd0IsTUFBTXhCLE9BQU8sRUFBQyxJQUFLRjtBQUN4RCIsInNvdXJjZXMiOlsiL2hvbWUvcDQ3Mi9TY2hlZHVsZXIvbGliL2RhdGUtdXRpbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZm9ybWF0LCBwYXJzZSwgaXNWYWxpZCwgc3RhcnRPZldlZWsgfSBmcm9tICdkYXRlLWZucydcblxuLyoqXG4gKiBQYXJzZXMgdmFyaW91cyBkYXRlIGZvcm1hdHMgaW50byBhIERhdGUgb2JqZWN0XG4gKiBTdXBwb3J0cyBFeGNlbCBkYXRlcywgSVNPIHN0cmluZ3MsIGFuZCBjb21tb24gZGF0ZSBmb3JtYXRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUZsZXhpYmxlRGF0ZShkYXRlVmFsdWU6IGFueSk6IERhdGUgfCBudWxsIHtcbiAgaWYgKCFkYXRlVmFsdWUpIHJldHVybiBudWxsXG4gIFxuICAvLyBBbHJlYWR5IGEgdmFsaWQgRGF0ZSBvYmplY3RcbiAgaWYgKGRhdGVWYWx1ZSBpbnN0YW5jZW9mIERhdGUgJiYgaXNWYWxpZChkYXRlVmFsdWUpKSB7XG4gICAgcmV0dXJuIGRhdGVWYWx1ZVxuICB9XG4gIFxuICAvLyBFeGNlbCBkYXRlIG51bWJlciAoZGF5cyBzaW5jZSAxOTAwLTAxLTAxLCB3aXRoIEV4Y2VsJ3MgbGVhcCB5ZWFyIGJ1ZylcbiAgaWYgKHR5cGVvZiBkYXRlVmFsdWUgPT09ICdudW1iZXInICYmIGRhdGVWYWx1ZSA+IDApIHtcbiAgICAvLyBFeGNlbCBkYXRlczogbnVtYmVyIG9mIGRheXMgc2luY2UgMTkwMC0wMS0wMSAod2l0aCBsZWFwIHllYXIgYnVnIGZvciAxOTAwKVxuICAgIGNvbnN0IGV4Y2VsRXBvY2ggPSBuZXcgRGF0ZSgxOTAwLCAwLCAxKVxuICAgIGNvbnN0IG1zUGVyRGF5ID0gMjQgKiA2MCAqIDYwICogMTAwMFxuICAgIC8vIFN1YnRyYWN0IDIgdG8gYWNjb3VudCBmb3IgRXhjZWwncyBsZWFwIHllYXIgYnVnICgxOTAwIG5vdCBhIGxlYXAgeWVhcikgYW5kIDAtaW5kZXhpbmdcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoZXhjZWxFcG9jaC5nZXRUaW1lKCkgKyAoZGF0ZVZhbHVlIC0gMikgKiBtc1BlckRheSlcbiAgICBpZiAoaXNWYWxpZChkYXRlKSkgcmV0dXJuIGRhdGVcbiAgfVxuICBcbiAgLy8gU3RyaW5nIGRhdGVcbiAgaWYgKHR5cGVvZiBkYXRlVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgZGF0ZVN0ciA9IGRhdGVWYWx1ZS50cmltKClcbiAgICBcbiAgICAvLyBUcnkgcGFyc2luZyBhcyBJU08gZGF0ZVxuICAgIGNvbnN0IGlzb0RhdGUgPSBuZXcgRGF0ZShkYXRlU3RyKVxuICAgIGlmIChpc1ZhbGlkKGlzb0RhdGUpKSB7XG4gICAgICByZXR1cm4gaXNvRGF0ZVxuICAgIH1cbiAgICBcbiAgICAvLyBUcnkgY29tbW9uIGRhdGUgZm9ybWF0c1xuICAgIGNvbnN0IGZvcm1hdHMgPSBbXG4gICAgICAneXl5eS1NTS1kZCcsXG4gICAgICAnTU0vZGQveXl5eScsXG4gICAgICAnTS9kL3l5eXknLFxuICAgICAgJ2RkL01NL3l5eXknLFxuICAgICAgJ2QvTS95eXl5JyxcbiAgICAgICdNTU0gZCB5eXl5JyxcbiAgICAgICdkLU1NTS15eXl5JyxcbiAgICAgICd5eXl5L01NL2RkJyxcbiAgICAgICdkZC1NTS15eXl5JyxcbiAgICAgICdNTS1kZC15eXl5J1xuICAgIF1cbiAgICBcbiAgICBmb3IgKGNvbnN0IGZtdCBvZiBmb3JtYXRzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZShkYXRlU3RyLCBmbXQsIG5ldyBEYXRlKCkpXG4gICAgICAgIGlmIChpc1ZhbGlkKHBhcnNlZCkpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VkXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyBDb250aW51ZSB0byBuZXh0IGZvcm1hdFxuICAgICAgfVxuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIG51bGxcbn1cblxuLyoqXG4gKiBGb3JtYXRzIGEgZGF0ZSBjb25zaXN0ZW50bHkgYXMgeXl5eS1NTS1kZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlOiBEYXRlIHwgc3RyaW5nIHwgbnVtYmVyKTogc3RyaW5nIHtcbiAgY29uc3QgcGFyc2VkID0gdHlwZW9mIGRhdGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBkYXRlID09PSAnbnVtYmVyJyBcbiAgICA/IHBhcnNlRmxleGlibGVEYXRlKGRhdGUpIFxuICAgIDogZGF0ZVxuICAgIFxuICBpZiAoIXBhcnNlZCB8fCAhaXNWYWxpZChwYXJzZWQpKSB7XG4gICAgcmV0dXJuIGZvcm1hdChuZXcgRGF0ZSgpLCAneXl5eS1NTS1kZCcpXG4gIH1cbiAgXG4gIHJldHVybiBmb3JtYXQocGFyc2VkLCAneXl5eS1NTS1kZCcpXG59XG5cbi8qKlxuICogR2V0cyB0aGUgTW9uZGF5IG9mIHRoZSB3ZWVrIGZvciBhIGdpdmVuIGRhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1vbmRheU9mV2VlayhkYXRlOiBEYXRlIHwgc3RyaW5nIHwgbnVtYmVyKTogRGF0ZSB7XG4gIGNvbnN0IHBhcnNlZCA9IHR5cGVvZiBkYXRlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgZGF0ZSA9PT0gJ251bWJlcidcbiAgICA/IHBhcnNlRmxleGlibGVEYXRlKGRhdGUpXG4gICAgOiBkYXRlXG4gICAgXG4gIGlmICghcGFyc2VkIHx8ICFpc1ZhbGlkKHBhcnNlZCkpIHtcbiAgICByZXR1cm4gc3RhcnRPZldlZWsobmV3IERhdGUoKSwgeyB3ZWVrU3RhcnRzT246IDEgfSlcbiAgfVxuICBcbiAgcmV0dXJuIHN0YXJ0T2ZXZWVrKHBhcnNlZCwgeyB3ZWVrU3RhcnRzT246IDEgfSlcbn1cblxuLyoqXG4gKiBHZXRzIHdlZWsgaWRlbnRpZmllciBpbiBmb3JtYXQgXCJZWVlZLVdXXCJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFdlZWtJZGVudGlmaWVyKGRhdGU6IERhdGUgfCBzdHJpbmcgfCBudW1iZXIpOiBzdHJpbmcge1xuICBjb25zdCBtb25kYXkgPSBnZXRNb25kYXlPZldlZWsoZGF0ZSlcbiAgcmV0dXJuIGZvcm1hdChtb25kYXksIFwieXl5eS0nVydJSVwiKVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZXMgYSBkYXRlIHRvIE1vbmRheSBvZiBpdHMgd2VlayBhbmQgcmV0dXJucyBib3RoIGRhdGUgYW5kIHdlZWsgc3RyaW5nc1xuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplRGF0ZVRvV2VlayhkYXRlVmFsdWU6IGFueSk6IHsgZGF0ZTogc3RyaW5nOyB3ZWVrOiBzdHJpbmcgfSB7XG4gIGNvbnN0IHBhcnNlZCA9IHBhcnNlRmxleGlibGVEYXRlKGRhdGVWYWx1ZSlcbiAgXG4gIGlmICghcGFyc2VkKSB7XG4gICAgLy8gRmFsbGJhY2sgdG8gY3VycmVudCB3ZWVrXG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKVxuICAgIGNvbnN0IG1vbmRheSA9IGdldE1vbmRheU9mV2Vlayhub3cpXG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGU6IGZvcm1hdERhdGUobW9uZGF5KSxcbiAgICAgIHdlZWs6IGdldFdlZWtJZGVudGlmaWVyKG1vbmRheSlcbiAgICB9XG4gIH1cbiAgXG4gIGNvbnN0IG1vbmRheSA9IGdldE1vbmRheU9mV2VlayhwYXJzZWQpXG4gIHJldHVybiB7XG4gICAgZGF0ZTogZm9ybWF0RGF0ZShtb25kYXkpLFxuICAgIHdlZWs6IGdldFdlZWtJZGVudGlmaWVyKG1vbmRheSlcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGRhdGUgc3RyaW5nIGlzIGluIGEgdmFsaWQgZm9ybWF0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkRGF0ZVN0cmluZyhkYXRlU3RyOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgY29uc3QgcGFyc2VkID0gcGFyc2VGbGV4aWJsZURhdGUoZGF0ZVN0cilcbiAgcmV0dXJuIHBhcnNlZCAhPT0gbnVsbCAmJiBpc1ZhbGlkKHBhcnNlZClcbn1cblxuLyoqXG4gKiBDb21wYXJlcyB0d28gZGF0ZXMgZm9yIGVxdWFsaXR5IChpZ25vcmluZyB0aW1lKVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXJlU2FtZURheShkYXRlMTogRGF0ZSB8IHN0cmluZyB8IG51bWJlciwgZGF0ZTI6IERhdGUgfCBzdHJpbmcgfCBudW1iZXIpOiBib29sZWFuIHtcbiAgY29uc3QgZDEgPSBwYXJzZUZsZXhpYmxlRGF0ZShkYXRlMSlcbiAgY29uc3QgZDIgPSBwYXJzZUZsZXhpYmxlRGF0ZShkYXRlMilcbiAgXG4gIGlmICghZDEgfHwgIWQyKSByZXR1cm4gZmFsc2VcbiAgXG4gIHJldHVybiBmb3JtYXREYXRlKGQxKSA9PT0gZm9ybWF0RGF0ZShkMilcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuIHR3byBkYXRlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZGF5c0JldHdlZW4oc3RhcnREYXRlOiBEYXRlIHwgc3RyaW5nIHwgbnVtYmVyLCBlbmREYXRlOiBEYXRlIHwgc3RyaW5nIHwgbnVtYmVyKTogbnVtYmVyIHtcbiAgY29uc3Qgc3RhcnQgPSBwYXJzZUZsZXhpYmxlRGF0ZShzdGFydERhdGUpXG4gIGNvbnN0IGVuZCA9IHBhcnNlRmxleGlibGVEYXRlKGVuZERhdGUpXG4gIFxuICBpZiAoIXN0YXJ0IHx8ICFlbmQpIHJldHVybiAwXG4gIFxuICBjb25zdCBtc1BlckRheSA9IDI0ICogNjAgKiA2MCAqIDEwMDBcbiAgcmV0dXJuIE1hdGguZmxvb3IoKGVuZC5nZXRUaW1lKCkgLSBzdGFydC5nZXRUaW1lKCkpIC8gbXNQZXJEYXkpXG59Il0sIm5hbWVzIjpbImZvcm1hdCIsInBhcnNlIiwiaXNWYWxpZCIsInN0YXJ0T2ZXZWVrIiwicGFyc2VGbGV4aWJsZURhdGUiLCJkYXRlVmFsdWUiLCJEYXRlIiwiZXhjZWxFcG9jaCIsIm1zUGVyRGF5IiwiZGF0ZSIsImdldFRpbWUiLCJkYXRlU3RyIiwidHJpbSIsImlzb0RhdGUiLCJmb3JtYXRzIiwiZm10IiwicGFyc2VkIiwiZm9ybWF0RGF0ZSIsImdldE1vbmRheU9mV2VlayIsIndlZWtTdGFydHNPbiIsImdldFdlZWtJZGVudGlmaWVyIiwibW9uZGF5Iiwibm9ybWFsaXplRGF0ZVRvV2VlayIsIm5vdyIsIndlZWsiLCJpc1ZhbGlkRGF0ZVN0cmluZyIsImFyZVNhbWVEYXkiLCJkYXRlMSIsImRhdGUyIiwiZDEiLCJkMiIsImRheXNCZXR3ZWVuIiwic3RhcnREYXRlIiwiZW5kRGF0ZSIsInN0YXJ0IiwiZW5kIiwiTWF0aCIsImZsb29yIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/date-utils.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/excel/parser.ts":
/*!*****************************!*\
  !*** ./lib/excel/parser.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseExcelFile: () => (/* binding */ parseExcelFile)\n/* harmony export */ });\n/* harmony import */ var xlsx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! xlsx */ \"(app-pages-browser)/./node_modules/xlsx/xlsx.mjs\");\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/utils */ \"(app-pages-browser)/./lib/utils.ts\");\n/* harmony import */ var _lib_date_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/date-utils */ \"(app-pages-browser)/./lib/date-utils.ts\");\n/* harmony import */ var _validator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./validator */ \"(app-pages-browser)/./lib/excel/validator.ts\");\n\n\n\n\n// Wrapper function for backward compatibility\nfunction normalizeDateToMonday(dateValue) {\n    return (0,_lib_date_utils__WEBPACK_IMPORTED_MODULE_1__.normalizeDateToWeek)(dateValue);\n}\nasync function parseExcelFile(file) {\n    return new Promise((resolve, reject)=>{\n        const reader = new FileReader();\n        reader.onload = (e)=>{\n            try {\n                var _e_target;\n                // Only log essential info for debugging\n                const DEBUG = false // Set to true for detailed logging\n                ;\n                if (DEBUG) {\n                    console.log('📊 Starting Excel parsing...', {\n                        fileSize: file.size\n                    });\n                }\n                if (!((_e_target = e.target) === null || _e_target === void 0 ? void 0 : _e_target.result)) {\n                    throw new Error('Failed to read file content');\n                }\n                const data = new Uint8Array(e.target.result);\n                const workbook = xlsx__WEBPACK_IMPORTED_MODULE_3__.read(data, {\n                    type: 'array',\n                    cellDates: true\n                });\n                if (!workbook.Sheets || Object.keys(workbook.Sheets).length === 0) {\n                    throw new Error('No sheets found in the Excel file');\n                }\n                const result = parseWorkbook(workbook);\n                // Only log summary on success\n                console.log(\"✅ Excel parsed: \".concat(result.employees.length, \" employees, \").concat(result.projects.length, \" projects, \").concat(result.assignments.length, \" assignments\"));\n                // Validate the parsed data\n                const validation = (0,_validator__WEBPACK_IMPORTED_MODULE_2__.validateExcelData)({\n                    employees: result.employees,\n                    projects: result.projects,\n                    assignments: result.assignments\n                });\n                if (!validation.isValid) {\n                    const errorMessage = 'Excel validation failed:\\n' + validation.errors.join('\\n');\n                    throw new Error(errorMessage);\n                }\n                // Log warnings if any\n                if (validation.warnings.length > 0) {\n                    console.warn('⚠️ Excel validation warnings:', validation.warnings);\n                }\n                resolve(result);\n            } catch (error) {\n                console.error('❌ Error parsing Excel:', error);\n                if (error instanceof Error) {\n                    reject(error);\n                } else {\n                    reject(new Error('Unknown error occurred while parsing Excel file'));\n                }\n            }\n        };\n        reader.onerror = (error)=>{\n            console.error('❌ FileReader error:', error);\n            reject(new Error('Failed to read file. Please try again.'));\n        };\n        reader.readAsArrayBuffer(file);\n    });\n}\nfunction parseWorkbook(workbook) {\n    const result = {\n        employees: [],\n        projects: [],\n        assignments: [],\n        skills: [],\n        teams: [\n            'All Teams'\n        ]\n    };\n    // Parse Employees sheet\n    if (workbook.Sheets['Employees']) {\n        const sheet = xlsx__WEBPACK_IMPORTED_MODULE_3__.utils.sheet_to_json(workbook.Sheets['Employees']);\n        result.employees = sheet.map((row)=>({\n                id: row.ID || row.id || (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.generateId)(),\n                name: row.Name || row.Employee || '',\n                email: row.Email || '',\n                maxHours: Number(row['Max Hours']) || 40,\n                team: row.Team || 'Default',\n                skills: parseSkills(row)\n            }));\n    }\n    // Parse Projects sheet\n    if (workbook.Sheets['Projects']) {\n        const sheet = xlsx__WEBPACK_IMPORTED_MODULE_3__.utils.sheet_to_json(workbook.Sheets['Projects']);\n        result.projects = sheet.map((row)=>({\n                id: row.ID || row.id || (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.generateId)(),\n                name: row.Name || row.Project || '',\n                startDate: (0,_lib_date_utils__WEBPACK_IMPORTED_MODULE_1__.parseFlexibleDate)(row['Start Date']) || new Date(),\n                endDate: (0,_lib_date_utils__WEBPACK_IMPORTED_MODULE_1__.parseFlexibleDate)(row['End Date']) || new Date(),\n                requiredSkills: row['Required Skills'] ? String(row['Required Skills']).split(',').map((s)=>s.trim()) : [],\n                portfolio: row.Portfolio || ''\n            }));\n    }\n    // Parse Assignments sheet\n    if (workbook.Sheets['Assignments']) {\n        const sheet = xlsx__WEBPACK_IMPORTED_MODULE_3__.utils.sheet_to_json(workbook.Sheets['Assignments']);\n        // Check if this is pivot-style format (columns are dates)\n        const firstRow = sheet[0] || {};\n        const columns = Object.keys(firstRow);\n        const dateColumns = columns.filter((col)=>{\n            // Check if column name looks like a date\n            return /^\\d{4}-\\d{2}-\\d{2}/.test(col) || /^\\d{1,2}\\/\\d{1,2}\\/\\d{4}/.test(col) || /^[A-Z][a-z]{2}\\s+\\d{1,2}/.test(col);\n        });\n        if (dateColumns.length > 0) {\n            // Pivot format: Each row is employee-project, columns are week dates\n            result.assignments = [];\n            sheet.forEach((row, rowIndex)=>{\n                const employeeIdOrName = row.Employee || row['Employee'] || row['Employee ID'] || '';\n                const projectIdOrName = row.Project || row['Project'] || row['Project ID'] || '';\n                if (!employeeIdOrName || !projectIdOrName) {\n                    // Skip invalid rows silently\n                    return;\n                }\n                // Try to find employee by ID first, then by name\n                let employeeId = employeeIdOrName;\n                const employeeById = result.employees.find((e)=>e.id === employeeIdOrName);\n                const employeeByName = result.employees.find((e)=>e.name === employeeIdOrName);\n                if (!employeeById && employeeByName) {\n                    employeeId = employeeByName.id;\n                }\n                // Try to find project by ID first, then by name\n                let projectId = projectIdOrName;\n                const projectById = result.projects.find((p)=>p.id === projectIdOrName);\n                const projectByName = result.projects.find((p)=>p.name === projectIdOrName);\n                if (!projectById && projectByName) {\n                    projectId = projectByName.id;\n                }\n                // Process each date column\n                dateColumns.forEach((dateCol)=>{\n                    const hours = row[dateCol];\n                    if (hours && Number(hours) > 0) {\n                        const { date, week } = normalizeDateToMonday(dateCol);\n                        const assignment = {\n                            id: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.generateId)(),\n                            employeeId: employeeId,\n                            projectId: projectId,\n                            hours: Number(hours),\n                            week: week,\n                            date: date\n                        };\n                        result.assignments.push(assignment);\n                    }\n                });\n            });\n        } else {\n            // Traditional format: Each row is one assignment\n            result.assignments = sheet.map((row, index)=>{\n                // Check all possible column names for week/date\n                const rawDate = row.Week || row['Week'] || row.Date || row['Date'] || row.week || row.date;\n                const { date, week } = normalizeDateToMonday(rawDate);\n                // Parse hours with better handling\n                const rawHours = row.Hours || row['Hours'] || row.hours || 0;\n                const parsedHours = typeof rawHours === 'string' ? parseFloat(rawHours) || 0 : Number(rawHours) || 0;\n                const employeeIdOrName = row['Employee ID'] || row.Employee || row['Employee'] || row['employee'] || '';\n                const projectIdOrName = row['Project ID'] || row.Project || row['Project'] || row['project'] || '';\n                // Try to find employee by ID first, then by name\n                let employeeId = employeeIdOrName;\n                const employeeById = result.employees.find((e)=>e.id === employeeIdOrName);\n                const employeeByName = result.employees.find((e)=>e.name === employeeIdOrName);\n                if (!employeeById && employeeByName) {\n                    employeeId = employeeByName.id;\n                }\n                // Try to find project by ID first, then by name\n                let projectId = projectIdOrName;\n                const projectById = result.projects.find((p)=>p.id === projectIdOrName);\n                const projectByName = result.projects.find((p)=>p.name === projectIdOrName);\n                if (!projectById && projectByName) {\n                    projectId = projectByName.id;\n                }\n                const assignment = {\n                    id: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.generateId)(),\n                    employeeId: employeeId,\n                    projectId: projectId,\n                    hours: parsedHours,\n                    week: week,\n                    date: date // New: Store full date in yyyy-MM-dd format\n                };\n                // Assignment created\n                return assignment;\n            });\n        }\n    } else {\n    // No assignments sheet found\n    }\n    // Parse Skills sheet (optional)\n    if (workbook.Sheets['Skills']) {\n        const sheet = xlsx__WEBPACK_IMPORTED_MODULE_3__.utils.sheet_to_json(workbook.Sheets['Skills']);\n        const skillSet = new Set();\n        sheet.forEach((row)=>{\n            Object.keys(row).forEach((key)=>{\n                if (key !== 'Employee' && key !== 'ID' && key !== 'Name') {\n                    skillSet.add(key);\n                }\n            });\n        });\n        result.skills = Array.from(skillSet);\n    } else {\n        // Extract skills from employees\n        const skillSet = new Set();\n        result.employees.forEach((emp)=>{\n            Object.keys(emp.skills).forEach((skill)=>skillSet.add(skill));\n        });\n        result.skills = Array.from(skillSet);\n    }\n    // Extract teams\n    const teamSet = new Set([\n        'All Teams'\n    ]);\n    result.employees.forEach((emp)=>{\n        if (emp.team) teamSet.add(emp.team);\n    });\n    result.teams = Array.from(teamSet);\n    return result;\n}\nfunction parseSkills(row) {\n    const skills = {};\n    const excludeFields = [\n        'Name',\n        'Employee',\n        'Email',\n        'ID',\n        'id',\n        'Max Hours',\n        'Team'\n    ];\n    Object.keys(row).forEach((key)=>{\n        if (!excludeFields.includes(key)) {\n            const value = row[key];\n            if (value && value !== 'None' && value !== '') {\n                // Try to parse as proficiency level\n                if ([\n                    'Beginner',\n                    'Intermediate',\n                    'Expert'\n                ].includes(value)) {\n                    skills[key] = value;\n                } else if (typeof value === 'number') {\n                    // Convert numeric values to proficiency levels\n                    if (value >= 3) skills[key] = 'Expert';\n                    else if (value >= 2) skills[key] = 'Intermediate';\n                    else if (value >= 1) skills[key] = 'Beginner';\n                } else if (value) {\n                    // Default to Intermediate for any other non-empty value\n                    skills[key] = 'Intermediate';\n                }\n            }\n        }\n    });\n    return skills;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9leGNlbC9wYXJzZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBNEI7QUFFWTtBQUNpQztBQUMxQjtBQUUvQyw4Q0FBOEM7QUFDOUMsU0FBU0ssc0JBQXNCQyxTQUFjO0lBQzNDLE9BQU9KLG9FQUFtQkEsQ0FBQ0k7QUFDN0I7QUFFTyxlQUFlQyxlQUFlQyxJQUFVO0lBQzdDLE9BQU8sSUFBSUMsUUFBUSxDQUFDQyxTQUFTQztRQUMzQixNQUFNQyxTQUFTLElBQUlDO1FBRW5CRCxPQUFPRSxNQUFNLEdBQUcsQ0FBQ0M7WUFDZixJQUFJO29CQU9HQTtnQkFOTCx3Q0FBd0M7Z0JBQ3hDLE1BQU1DLFFBQVEsTUFBTSxtQ0FBbUM7O2dCQUN2RCxJQUFJQSxPQUFPO29CQUNUQyxRQUFRQyxHQUFHLENBQUMsZ0NBQWdDO3dCQUFFQyxVQUFVWCxLQUFLWSxJQUFJO29CQUFDO2dCQUNwRTtnQkFFQSxJQUFJLEdBQUNMLFlBQUFBLEVBQUVNLE1BQU0sY0FBUk4sZ0NBQUFBLFVBQVVPLE1BQU0sR0FBRTtvQkFDckIsTUFBTSxJQUFJQyxNQUFNO2dCQUNsQjtnQkFFQSxNQUFNQyxPQUFPLElBQUlDLFdBQVdWLEVBQUVNLE1BQU0sQ0FBQ0MsTUFBTTtnQkFDM0MsTUFBTUksV0FBVzFCLHNDQUFTLENBQUN3QixNQUFNO29CQUFFSSxNQUFNO29CQUFTQyxXQUFXO2dCQUFLO2dCQUVsRSxJQUFJLENBQUNILFNBQVNJLE1BQU0sSUFBSUMsT0FBT0MsSUFBSSxDQUFDTixTQUFTSSxNQUFNLEVBQUVHLE1BQU0sS0FBSyxHQUFHO29CQUNqRSxNQUFNLElBQUlWLE1BQU07Z0JBQ2xCO2dCQUVBLE1BQU1ELFNBQVNZLGNBQWNSO2dCQUM3Qiw4QkFBOEI7Z0JBQzlCVCxRQUFRQyxHQUFHLENBQUMsbUJBQXlESSxPQUF0Q0EsT0FBT2EsU0FBUyxDQUFDRixNQUFNLEVBQUMsZ0JBQWtEWCxPQUFwQ0EsT0FBT2MsUUFBUSxDQUFDSCxNQUFNLEVBQUMsZUFBdUMsT0FBMUJYLE9BQU9lLFdBQVcsQ0FBQ0osTUFBTSxFQUFDO2dCQUVuSSwyQkFBMkI7Z0JBQzNCLE1BQU1LLGFBQWFsQyw2REFBaUJBLENBQUM7b0JBQ25DK0IsV0FBV2IsT0FBT2EsU0FBUztvQkFDM0JDLFVBQVVkLE9BQU9jLFFBQVE7b0JBQ3pCQyxhQUFhZixPQUFPZSxXQUFXO2dCQUNqQztnQkFFQSxJQUFJLENBQUNDLFdBQVdDLE9BQU8sRUFBRTtvQkFDdkIsTUFBTUMsZUFBZSwrQkFBK0JGLFdBQVdHLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDO29CQUMzRSxNQUFNLElBQUluQixNQUFNaUI7Z0JBQ2xCO2dCQUVBLHNCQUFzQjtnQkFDdEIsSUFBSUYsV0FBV0ssUUFBUSxDQUFDVixNQUFNLEdBQUcsR0FBRztvQkFDbENoQixRQUFRMkIsSUFBSSxDQUFDLGlDQUFpQ04sV0FBV0ssUUFBUTtnQkFDbkU7Z0JBRUFqQyxRQUFRWTtZQUNWLEVBQUUsT0FBT3VCLE9BQU87Z0JBQ2Q1QixRQUFRNEIsS0FBSyxDQUFDLDBCQUEwQkE7Z0JBQ3hDLElBQUlBLGlCQUFpQnRCLE9BQU87b0JBQzFCWixPQUFPa0M7Z0JBQ1QsT0FBTztvQkFDTGxDLE9BQU8sSUFBSVksTUFBTTtnQkFDbkI7WUFDRjtRQUNGO1FBRUFYLE9BQU9rQyxPQUFPLEdBQUcsQ0FBQ0Q7WUFDaEI1QixRQUFRNEIsS0FBSyxDQUFDLHVCQUF1QkE7WUFDckNsQyxPQUFPLElBQUlZLE1BQU07UUFDbkI7UUFFQVgsT0FBT21DLGlCQUFpQixDQUFDdkM7SUFDM0I7QUFDRjtBQUVBLFNBQVMwQixjQUFjUixRQUF1QjtJQUM1QyxNQUFNSixTQUF1QjtRQUMzQmEsV0FBVyxFQUFFO1FBQ2JDLFVBQVUsRUFBRTtRQUNaQyxhQUFhLEVBQUU7UUFDZlcsUUFBUSxFQUFFO1FBQ1ZDLE9BQU87WUFBQztTQUFZO0lBQ3RCO0lBRUEsd0JBQXdCO0lBQ3hCLElBQUl2QixTQUFTSSxNQUFNLENBQUMsWUFBWSxFQUFFO1FBQ2hDLE1BQU1vQixRQUFRbEQsdUNBQVUsQ0FBQ29ELGFBQWEsQ0FBQzFCLFNBQVNJLE1BQU0sQ0FBQyxZQUFZO1FBQ25FUixPQUFPYSxTQUFTLEdBQUdlLE1BQU1HLEdBQUcsQ0FBQyxDQUFDQyxNQUFjO2dCQUMxQ0MsSUFBSUQsSUFBSUUsRUFBRSxJQUFJRixJQUFJQyxFQUFFLElBQUl0RCxzREFBVUE7Z0JBQ2xDd0QsTUFBTUgsSUFBSUksSUFBSSxJQUFJSixJQUFJSyxRQUFRLElBQUk7Z0JBQ2xDQyxPQUFPTixJQUFJTyxLQUFLLElBQUk7Z0JBQ3BCQyxVQUFVQyxPQUFPVCxHQUFHLENBQUMsWUFBWSxLQUFLO2dCQUN0Q1UsTUFBTVYsSUFBSVcsSUFBSSxJQUFJO2dCQUNsQmpCLFFBQVFrQixZQUFZWjtZQUN0QjtJQUNGO0lBRUEsdUJBQXVCO0lBQ3ZCLElBQUk1QixTQUFTSSxNQUFNLENBQUMsV0FBVyxFQUFFO1FBQy9CLE1BQU1vQixRQUFRbEQsdUNBQVUsQ0FBQ29ELGFBQWEsQ0FBQzFCLFNBQVNJLE1BQU0sQ0FBQyxXQUFXO1FBQ2xFUixPQUFPYyxRQUFRLEdBQUdjLE1BQU1HLEdBQUcsQ0FBQyxDQUFDQyxNQUFjO2dCQUN6Q0MsSUFBSUQsSUFBSUUsRUFBRSxJQUFJRixJQUFJQyxFQUFFLElBQUl0RCxzREFBVUE7Z0JBQ2xDd0QsTUFBTUgsSUFBSUksSUFBSSxJQUFJSixJQUFJYSxPQUFPLElBQUk7Z0JBQ2pDQyxXQUFXakUsa0VBQWlCQSxDQUFDbUQsR0FBRyxDQUFDLGFBQWEsS0FBSyxJQUFJZTtnQkFDdkRDLFNBQVNuRSxrRUFBaUJBLENBQUNtRCxHQUFHLENBQUMsV0FBVyxLQUFLLElBQUllO2dCQUNuREUsZ0JBQWdCakIsR0FBRyxDQUFDLGtCQUFrQixHQUNsQ2tCLE9BQU9sQixHQUFHLENBQUMsa0JBQWtCLEVBQUVtQixLQUFLLENBQUMsS0FBS3BCLEdBQUcsQ0FBQ3FCLENBQUFBLElBQUtBLEVBQUVDLElBQUksTUFDekQsRUFBRTtnQkFDTkMsV0FBV3RCLElBQUl1QixTQUFTLElBQUk7WUFDOUI7SUFDRjtJQUVBLDBCQUEwQjtJQUMxQixJQUFJbkQsU0FBU0ksTUFBTSxDQUFDLGNBQWMsRUFBRTtRQUNsQyxNQUFNb0IsUUFBUWxELHVDQUFVLENBQUNvRCxhQUFhLENBQUMxQixTQUFTSSxNQUFNLENBQUMsY0FBYztRQUVyRSwwREFBMEQ7UUFDMUQsTUFBTWdELFdBQVc1QixLQUFLLENBQUMsRUFBRSxJQUFJLENBQUM7UUFDOUIsTUFBTTZCLFVBQVVoRCxPQUFPQyxJQUFJLENBQUM4QztRQUM1QixNQUFNRSxjQUFjRCxRQUFRRSxNQUFNLENBQUNDLENBQUFBO1lBQ2pDLHlDQUF5QztZQUN6QyxPQUFPLHFCQUFxQkMsSUFBSSxDQUFDRCxRQUMxQiwyQkFBMkJDLElBQUksQ0FBQ0QsUUFDaEMsMkJBQTJCQyxJQUFJLENBQUNEO1FBQ3pDO1FBRUEsSUFBSUYsWUFBWS9DLE1BQU0sR0FBRyxHQUFHO1lBQzFCLHFFQUFxRTtZQUNyRVgsT0FBT2UsV0FBVyxHQUFHLEVBQUU7WUFFdkJhLE1BQU1rQyxPQUFPLENBQUMsQ0FBQzlCLEtBQVUrQjtnQkFDdkIsTUFBTUMsbUJBQW1CaEMsSUFBSUssUUFBUSxJQUFJTCxHQUFHLENBQUMsV0FBVyxJQUFJQSxHQUFHLENBQUMsY0FBYyxJQUFJO2dCQUNsRixNQUFNaUMsa0JBQWtCakMsSUFBSWEsT0FBTyxJQUFJYixHQUFHLENBQUMsVUFBVSxJQUFJQSxHQUFHLENBQUMsYUFBYSxJQUFJO2dCQUU5RSxJQUFJLENBQUNnQyxvQkFBb0IsQ0FBQ0MsaUJBQWlCO29CQUN6Qyw2QkFBNkI7b0JBQzdCO2dCQUNGO2dCQUVBLGlEQUFpRDtnQkFDakQsSUFBSUMsYUFBYUY7Z0JBQ2pCLE1BQU1HLGVBQWVuRSxPQUFPYSxTQUFTLENBQUN1RCxJQUFJLENBQUMzRSxDQUFBQSxJQUFLQSxFQUFFd0MsRUFBRSxLQUFLK0I7Z0JBQ3pELE1BQU1LLGlCQUFpQnJFLE9BQU9hLFNBQVMsQ0FBQ3VELElBQUksQ0FBQzNFLENBQUFBLElBQUtBLEVBQUUwQyxJQUFJLEtBQUs2QjtnQkFFN0QsSUFBSSxDQUFDRyxnQkFBZ0JFLGdCQUFnQjtvQkFDbkNILGFBQWFHLGVBQWVwQyxFQUFFO2dCQUNoQztnQkFFQSxnREFBZ0Q7Z0JBQ2hELElBQUlxQyxZQUFZTDtnQkFDaEIsTUFBTU0sY0FBY3ZFLE9BQU9jLFFBQVEsQ0FBQ3NELElBQUksQ0FBQ0ksQ0FBQUEsSUFBS0EsRUFBRXZDLEVBQUUsS0FBS2dDO2dCQUN2RCxNQUFNUSxnQkFBZ0J6RSxPQUFPYyxRQUFRLENBQUNzRCxJQUFJLENBQUNJLENBQUFBLElBQUtBLEVBQUVyQyxJQUFJLEtBQUs4QjtnQkFFM0QsSUFBSSxDQUFDTSxlQUFlRSxlQUFlO29CQUNqQ0gsWUFBWUcsY0FBY3hDLEVBQUU7Z0JBQzlCO2dCQUVBLDJCQUEyQjtnQkFDM0J5QixZQUFZSSxPQUFPLENBQUNZLENBQUFBO29CQUNsQixNQUFNQyxRQUFRM0MsR0FBRyxDQUFDMEMsUUFBUTtvQkFDMUIsSUFBSUMsU0FBU2xDLE9BQU9rQyxTQUFTLEdBQUc7d0JBQzlCLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxJQUFJLEVBQUUsR0FBRzlGLHNCQUFzQjJGO3dCQUU3QyxNQUFNSSxhQUF5Qjs0QkFDN0I3QyxJQUFJdEQsc0RBQVVBOzRCQUNkdUYsWUFBWUE7NEJBQ1pJLFdBQVdBOzRCQUNYSyxPQUFPbEMsT0FBT2tDOzRCQUNkRSxNQUFNQTs0QkFDTkQsTUFBTUE7d0JBQ1I7d0JBRUE1RSxPQUFPZSxXQUFXLENBQUNnRSxJQUFJLENBQUNEO29CQUMxQjtnQkFDRjtZQUNGO1FBQ0YsT0FBTztZQUNMLGlEQUFpRDtZQUNqRDlFLE9BQU9lLFdBQVcsR0FBR2EsTUFBTUcsR0FBRyxDQUFDLENBQUNDLEtBQVVnRDtnQkFDeEMsZ0RBQWdEO2dCQUNoRCxNQUFNQyxVQUFVakQsSUFBSWtELElBQUksSUFBSWxELEdBQUcsQ0FBQyxPQUFPLElBQUlBLElBQUllLElBQUksSUFBSWYsR0FBRyxDQUFDLE9BQU8sSUFBSUEsSUFBSTZDLElBQUksSUFBSTdDLElBQUk0QyxJQUFJO2dCQUMxRixNQUFNLEVBQUVBLElBQUksRUFBRUMsSUFBSSxFQUFFLEdBQUc5RixzQkFBc0JrRztnQkFFN0MsbUNBQW1DO2dCQUNuQyxNQUFNRSxXQUFXbkQsSUFBSW9ELEtBQUssSUFBSXBELEdBQUcsQ0FBQyxRQUFRLElBQUlBLElBQUkyQyxLQUFLLElBQUk7Z0JBQzNELE1BQU1VLGNBQWMsT0FBT0YsYUFBYSxXQUFXRyxXQUFXSCxhQUFhLElBQUkxQyxPQUFPMEMsYUFBYTtnQkFFbkcsTUFBTW5CLG1CQUFtQmhDLEdBQUcsQ0FBQyxjQUFjLElBQUlBLElBQUlLLFFBQVEsSUFBSUwsR0FBRyxDQUFDLFdBQVcsSUFBSUEsR0FBRyxDQUFDLFdBQVcsSUFBSTtnQkFDckcsTUFBTWlDLGtCQUFrQmpDLEdBQUcsQ0FBQyxhQUFhLElBQUlBLElBQUlhLE9BQU8sSUFBSWIsR0FBRyxDQUFDLFVBQVUsSUFBSUEsR0FBRyxDQUFDLFVBQVUsSUFBSTtnQkFFaEcsaURBQWlEO2dCQUNqRCxJQUFJa0MsYUFBYUY7Z0JBQ2pCLE1BQU1HLGVBQWVuRSxPQUFPYSxTQUFTLENBQUN1RCxJQUFJLENBQUMzRSxDQUFBQSxJQUFLQSxFQUFFd0MsRUFBRSxLQUFLK0I7Z0JBQ3pELE1BQU1LLGlCQUFpQnJFLE9BQU9hLFNBQVMsQ0FBQ3VELElBQUksQ0FBQzNFLENBQUFBLElBQUtBLEVBQUUwQyxJQUFJLEtBQUs2QjtnQkFFN0QsSUFBSSxDQUFDRyxnQkFBZ0JFLGdCQUFnQjtvQkFDbkNILGFBQWFHLGVBQWVwQyxFQUFFO2dCQUNoQztnQkFFQSxnREFBZ0Q7Z0JBQ2hELElBQUlxQyxZQUFZTDtnQkFDaEIsTUFBTU0sY0FBY3ZFLE9BQU9jLFFBQVEsQ0FBQ3NELElBQUksQ0FBQ0ksQ0FBQUEsSUFBS0EsRUFBRXZDLEVBQUUsS0FBS2dDO2dCQUN2RCxNQUFNUSxnQkFBZ0J6RSxPQUFPYyxRQUFRLENBQUNzRCxJQUFJLENBQUNJLENBQUFBLElBQUtBLEVBQUVyQyxJQUFJLEtBQUs4QjtnQkFFM0QsSUFBSSxDQUFDTSxlQUFlRSxlQUFlO29CQUNqQ0gsWUFBWUcsY0FBY3hDLEVBQUU7Z0JBQzlCO2dCQUVBLE1BQU02QyxhQUF5QjtvQkFDN0I3QyxJQUFJdEQsc0RBQVVBO29CQUNkdUYsWUFBWUE7b0JBQ1pJLFdBQVdBO29CQUNYSyxPQUFPVTtvQkFDUFIsTUFBTUE7b0JBQ05ELE1BQU1BLEtBQU8sNENBQTRDO2dCQUMzRDtnQkFFQSxxQkFBcUI7Z0JBRXJCLE9BQU9FO1lBQ1Q7UUFDRjtJQUNGLE9BQU87SUFDTCw2QkFBNkI7SUFDL0I7SUFFQSxnQ0FBZ0M7SUFDaEMsSUFBSTFFLFNBQVNJLE1BQU0sQ0FBQyxTQUFTLEVBQUU7UUFDN0IsTUFBTW9CLFFBQVFsRCx1Q0FBVSxDQUFDb0QsYUFBYSxDQUFDMUIsU0FBU0ksTUFBTSxDQUFDLFNBQVM7UUFDaEUsTUFBTStFLFdBQVcsSUFBSUM7UUFFckI1RCxNQUFNa0MsT0FBTyxDQUFDLENBQUM5QjtZQUNidkIsT0FBT0MsSUFBSSxDQUFDc0IsS0FBSzhCLE9BQU8sQ0FBQzJCLENBQUFBO2dCQUN2QixJQUFJQSxRQUFRLGNBQWNBLFFBQVEsUUFBUUEsUUFBUSxRQUFRO29CQUN4REYsU0FBU0csR0FBRyxDQUFDRDtnQkFDZjtZQUNGO1FBQ0Y7UUFFQXpGLE9BQU8wQixNQUFNLEdBQUdpRSxNQUFNQyxJQUFJLENBQUNMO0lBQzdCLE9BQU87UUFDTCxnQ0FBZ0M7UUFDaEMsTUFBTUEsV0FBVyxJQUFJQztRQUNyQnhGLE9BQU9hLFNBQVMsQ0FBQ2lELE9BQU8sQ0FBQytCLENBQUFBO1lBQ3ZCcEYsT0FBT0MsSUFBSSxDQUFDbUYsSUFBSW5FLE1BQU0sRUFBRW9DLE9BQU8sQ0FBQ2dDLENBQUFBLFFBQVNQLFNBQVNHLEdBQUcsQ0FBQ0k7UUFDeEQ7UUFDQTlGLE9BQU8wQixNQUFNLEdBQUdpRSxNQUFNQyxJQUFJLENBQUNMO0lBQzdCO0lBRUEsZ0JBQWdCO0lBQ2hCLE1BQU1RLFVBQVUsSUFBSVAsSUFBSTtRQUFDO0tBQVk7SUFDckN4RixPQUFPYSxTQUFTLENBQUNpRCxPQUFPLENBQUMrQixDQUFBQTtRQUN2QixJQUFJQSxJQUFJbkQsSUFBSSxFQUFFcUQsUUFBUUwsR0FBRyxDQUFDRyxJQUFJbkQsSUFBSTtJQUNwQztJQUNBMUMsT0FBTzJCLEtBQUssR0FBR2dFLE1BQU1DLElBQUksQ0FBQ0c7SUFFMUIsT0FBTy9GO0FBQ1Q7QUFFQSxTQUFTNEMsWUFBWVosR0FBUTtJQUMzQixNQUFNTixTQUEyQyxDQUFDO0lBQ2xELE1BQU1zRSxnQkFBZ0I7UUFBQztRQUFRO1FBQVk7UUFBUztRQUFNO1FBQU07UUFBYTtLQUFPO0lBRXBGdkYsT0FBT0MsSUFBSSxDQUFDc0IsS0FBSzhCLE9BQU8sQ0FBQzJCLENBQUFBO1FBQ3ZCLElBQUksQ0FBQ08sY0FBY0MsUUFBUSxDQUFDUixNQUFNO1lBQ2hDLE1BQU1TLFFBQVFsRSxHQUFHLENBQUN5RCxJQUFJO1lBQ3RCLElBQUlTLFNBQVNBLFVBQVUsVUFBVUEsVUFBVSxJQUFJO2dCQUM3QyxvQ0FBb0M7Z0JBQ3BDLElBQUk7b0JBQUM7b0JBQVk7b0JBQWdCO2lCQUFTLENBQUNELFFBQVEsQ0FBQ0MsUUFBUTtvQkFDMUR4RSxNQUFNLENBQUMrRCxJQUFJLEdBQUdTO2dCQUNoQixPQUFPLElBQUksT0FBT0EsVUFBVSxVQUFVO29CQUNwQywrQ0FBK0M7b0JBQy9DLElBQUlBLFNBQVMsR0FBR3hFLE1BQU0sQ0FBQytELElBQUksR0FBRzt5QkFDekIsSUFBSVMsU0FBUyxHQUFHeEUsTUFBTSxDQUFDK0QsSUFBSSxHQUFHO3lCQUM5QixJQUFJUyxTQUFTLEdBQUd4RSxNQUFNLENBQUMrRCxJQUFJLEdBQUc7Z0JBQ3JDLE9BQU8sSUFBSVMsT0FBTztvQkFDaEIsd0RBQXdEO29CQUN4RHhFLE1BQU0sQ0FBQytELElBQUksR0FBRztnQkFDaEI7WUFDRjtRQUNGO0lBQ0Y7SUFFQSxPQUFPL0Q7QUFDVCIsInNvdXJjZXMiOlsiL2hvbWUvcDQ3Mi9TY2hlZHVsZXIvbGliL2V4Y2VsL3BhcnNlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBYTFNYIGZyb20gJ3hsc3gnXG5pbXBvcnQgeyBTY2hlZHVsZURhdGEsIEFzc2lnbm1lbnQsIFByb2ZpY2llbmN5TGV2ZWwgfSBmcm9tICdAL3R5cGVzL3NjaGVkdWxlJ1xuaW1wb3J0IHsgZ2VuZXJhdGVJZCB9IGZyb20gJ0AvbGliL3V0aWxzJ1xuaW1wb3J0IHsgbm9ybWFsaXplRGF0ZVRvV2VlaywgcGFyc2VGbGV4aWJsZURhdGUgfSBmcm9tICdAL2xpYi9kYXRlLXV0aWxzJ1xuaW1wb3J0IHsgdmFsaWRhdGVFeGNlbERhdGEgfSBmcm9tICcuL3ZhbGlkYXRvcidcblxuLy8gV3JhcHBlciBmdW5jdGlvbiBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuZnVuY3Rpb24gbm9ybWFsaXplRGF0ZVRvTW9uZGF5KGRhdGVWYWx1ZTogYW55KTogeyBkYXRlOiBzdHJpbmcsIHdlZWs6IHN0cmluZyB9IHtcbiAgcmV0dXJuIG5vcm1hbGl6ZURhdGVUb1dlZWsoZGF0ZVZhbHVlKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGFyc2VFeGNlbEZpbGUoZmlsZTogRmlsZSk6IFByb21pc2U8U2NoZWR1bGVEYXRhPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICAgIFxuICAgIHJlYWRlci5vbmxvYWQgPSAoZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gT25seSBsb2cgZXNzZW50aWFsIGluZm8gZm9yIGRlYnVnZ2luZ1xuICAgICAgICBjb25zdCBERUJVRyA9IGZhbHNlIC8vIFNldCB0byB0cnVlIGZvciBkZXRhaWxlZCBsb2dnaW5nXG4gICAgICAgIGlmIChERUJVRykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5OKIFN0YXJ0aW5nIEV4Y2VsIHBhcnNpbmcuLi4nLCB7IGZpbGVTaXplOiBmaWxlLnNpemUgfSlcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKCFlLnRhcmdldD8ucmVzdWx0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcmVhZCBmaWxlIGNvbnRlbnQnKVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoZS50YXJnZXQucmVzdWx0IGFzIEFycmF5QnVmZmVyKVxuICAgICAgICBjb25zdCB3b3JrYm9vayA9IFhMU1gucmVhZChkYXRhLCB7IHR5cGU6ICdhcnJheScsIGNlbGxEYXRlczogdHJ1ZSB9KVxuICAgICAgICBcbiAgICAgICAgaWYgKCF3b3JrYm9vay5TaGVldHMgfHwgT2JqZWN0LmtleXMod29ya2Jvb2suU2hlZXRzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNoZWV0cyBmb3VuZCBpbiB0aGUgRXhjZWwgZmlsZScpXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlV29ya2Jvb2sod29ya2Jvb2spXG4gICAgICAgIC8vIE9ubHkgbG9nIHN1bW1hcnkgb24gc3VjY2Vzc1xuICAgICAgICBjb25zb2xlLmxvZyhg4pyFIEV4Y2VsIHBhcnNlZDogJHtyZXN1bHQuZW1wbG95ZWVzLmxlbmd0aH0gZW1wbG95ZWVzLCAke3Jlc3VsdC5wcm9qZWN0cy5sZW5ndGh9IHByb2plY3RzLCAke3Jlc3VsdC5hc3NpZ25tZW50cy5sZW5ndGh9IGFzc2lnbm1lbnRzYClcbiAgICAgICAgXG4gICAgICAgIC8vIFZhbGlkYXRlIHRoZSBwYXJzZWQgZGF0YVxuICAgICAgICBjb25zdCB2YWxpZGF0aW9uID0gdmFsaWRhdGVFeGNlbERhdGEoe1xuICAgICAgICAgIGVtcGxveWVlczogcmVzdWx0LmVtcGxveWVlcyxcbiAgICAgICAgICBwcm9qZWN0czogcmVzdWx0LnByb2plY3RzLFxuICAgICAgICAgIGFzc2lnbm1lbnRzOiByZXN1bHQuYXNzaWdubWVudHNcbiAgICAgICAgfSlcbiAgICAgICAgXG4gICAgICAgIGlmICghdmFsaWRhdGlvbi5pc1ZhbGlkKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gJ0V4Y2VsIHZhbGlkYXRpb24gZmFpbGVkOlxcbicgKyB2YWxpZGF0aW9uLmVycm9ycy5qb2luKCdcXG4nKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIExvZyB3YXJuaW5ncyBpZiBhbnlcbiAgICAgICAgaWYgKHZhbGlkYXRpb24ud2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIEV4Y2VsIHZhbGlkYXRpb24gd2FybmluZ3M6JywgdmFsaWRhdGlvbi53YXJuaW5ncylcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgcGFyc2luZyBFeGNlbDonLCBlcnJvcilcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVW5rbm93biBlcnJvciBvY2N1cnJlZCB3aGlsZSBwYXJzaW5nIEV4Y2VsIGZpbGUnKSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZWFkZXIub25lcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEZpbGVSZWFkZXIgZXJyb3I6JywgZXJyb3IpXG4gICAgICByZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gcmVhZCBmaWxlLiBQbGVhc2UgdHJ5IGFnYWluLicpKVxuICAgIH1cbiAgICBcbiAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoZmlsZSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gcGFyc2VXb3JrYm9vayh3b3JrYm9vazogWExTWC5Xb3JrQm9vayk6IFNjaGVkdWxlRGF0YSB7XG4gIGNvbnN0IHJlc3VsdDogU2NoZWR1bGVEYXRhID0ge1xuICAgIGVtcGxveWVlczogW10sXG4gICAgcHJvamVjdHM6IFtdLFxuICAgIGFzc2lnbm1lbnRzOiBbXSxcbiAgICBza2lsbHM6IFtdLFxuICAgIHRlYW1zOiBbJ0FsbCBUZWFtcyddLFxuICB9XG5cbiAgLy8gUGFyc2UgRW1wbG95ZWVzIHNoZWV0XG4gIGlmICh3b3JrYm9vay5TaGVldHNbJ0VtcGxveWVlcyddKSB7XG4gICAgY29uc3Qgc2hlZXQgPSBYTFNYLnV0aWxzLnNoZWV0X3RvX2pzb24od29ya2Jvb2suU2hlZXRzWydFbXBsb3llZXMnXSlcbiAgICByZXN1bHQuZW1wbG95ZWVzID0gc2hlZXQubWFwKChyb3c6IGFueSkgPT4gKHtcbiAgICAgIGlkOiByb3cuSUQgfHwgcm93LmlkIHx8IGdlbmVyYXRlSWQoKSxcbiAgICAgIG5hbWU6IHJvdy5OYW1lIHx8IHJvdy5FbXBsb3llZSB8fCAnJyxcbiAgICAgIGVtYWlsOiByb3cuRW1haWwgfHwgJycsXG4gICAgICBtYXhIb3VyczogTnVtYmVyKHJvd1snTWF4IEhvdXJzJ10pIHx8IDQwLFxuICAgICAgdGVhbTogcm93LlRlYW0gfHwgJ0RlZmF1bHQnLFxuICAgICAgc2tpbGxzOiBwYXJzZVNraWxscyhyb3cpLFxuICAgIH0pKVxuICB9XG5cbiAgLy8gUGFyc2UgUHJvamVjdHMgc2hlZXRcbiAgaWYgKHdvcmtib29rLlNoZWV0c1snUHJvamVjdHMnXSkge1xuICAgIGNvbnN0IHNoZWV0ID0gWExTWC51dGlscy5zaGVldF90b19qc29uKHdvcmtib29rLlNoZWV0c1snUHJvamVjdHMnXSlcbiAgICByZXN1bHQucHJvamVjdHMgPSBzaGVldC5tYXAoKHJvdzogYW55KSA9PiAoe1xuICAgICAgaWQ6IHJvdy5JRCB8fCByb3cuaWQgfHwgZ2VuZXJhdGVJZCgpLFxuICAgICAgbmFtZTogcm93Lk5hbWUgfHwgcm93LlByb2plY3QgfHwgJycsXG4gICAgICBzdGFydERhdGU6IHBhcnNlRmxleGlibGVEYXRlKHJvd1snU3RhcnQgRGF0ZSddKSB8fCBuZXcgRGF0ZSgpLFxuICAgICAgZW5kRGF0ZTogcGFyc2VGbGV4aWJsZURhdGUocm93WydFbmQgRGF0ZSddKSB8fCBuZXcgRGF0ZSgpLFxuICAgICAgcmVxdWlyZWRTa2lsbHM6IHJvd1snUmVxdWlyZWQgU2tpbGxzJ10gXG4gICAgICAgID8gU3RyaW5nKHJvd1snUmVxdWlyZWQgU2tpbGxzJ10pLnNwbGl0KCcsJykubWFwKHMgPT4gcy50cmltKCkpXG4gICAgICAgIDogW10sXG4gICAgICBwb3J0Zm9saW86IHJvdy5Qb3J0Zm9saW8gfHwgJycsXG4gICAgfSkpXG4gIH1cblxuICAvLyBQYXJzZSBBc3NpZ25tZW50cyBzaGVldFxuICBpZiAod29ya2Jvb2suU2hlZXRzWydBc3NpZ25tZW50cyddKSB7XG4gICAgY29uc3Qgc2hlZXQgPSBYTFNYLnV0aWxzLnNoZWV0X3RvX2pzb24od29ya2Jvb2suU2hlZXRzWydBc3NpZ25tZW50cyddKVxuICAgIFxuICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgcGl2b3Qtc3R5bGUgZm9ybWF0IChjb2x1bW5zIGFyZSBkYXRlcylcbiAgICBjb25zdCBmaXJzdFJvdyA9IHNoZWV0WzBdIHx8IHt9XG4gICAgY29uc3QgY29sdW1ucyA9IE9iamVjdC5rZXlzKGZpcnN0Um93KVxuICAgIGNvbnN0IGRhdGVDb2x1bW5zID0gY29sdW1ucy5maWx0ZXIoY29sID0+IHtcbiAgICAgIC8vIENoZWNrIGlmIGNvbHVtbiBuYW1lIGxvb2tzIGxpa2UgYSBkYXRlXG4gICAgICByZXR1cm4gL15cXGR7NH0tXFxkezJ9LVxcZHsyfS8udGVzdChjb2wpIHx8IFxuICAgICAgICAgICAgIC9eXFxkezEsMn1cXC9cXGR7MSwyfVxcL1xcZHs0fS8udGVzdChjb2wpIHx8XG4gICAgICAgICAgICAgL15bQS1aXVthLXpdezJ9XFxzK1xcZHsxLDJ9Ly50ZXN0KGNvbClcbiAgICB9KVxuICAgIFxuICAgIGlmIChkYXRlQ29sdW1ucy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBQaXZvdCBmb3JtYXQ6IEVhY2ggcm93IGlzIGVtcGxveWVlLXByb2plY3QsIGNvbHVtbnMgYXJlIHdlZWsgZGF0ZXNcbiAgICAgIHJlc3VsdC5hc3NpZ25tZW50cyA9IFtdXG4gICAgICBcbiAgICAgIHNoZWV0LmZvckVhY2goKHJvdzogYW55LCByb3dJbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IGVtcGxveWVlSWRPck5hbWUgPSByb3cuRW1wbG95ZWUgfHwgcm93WydFbXBsb3llZSddIHx8IHJvd1snRW1wbG95ZWUgSUQnXSB8fCAnJ1xuICAgICAgICBjb25zdCBwcm9qZWN0SWRPck5hbWUgPSByb3cuUHJvamVjdCB8fCByb3dbJ1Byb2plY3QnXSB8fCByb3dbJ1Byb2plY3QgSUQnXSB8fCAnJ1xuICAgICAgICBcbiAgICAgICAgaWYgKCFlbXBsb3llZUlkT3JOYW1lIHx8ICFwcm9qZWN0SWRPck5hbWUpIHtcbiAgICAgICAgICAvLyBTa2lwIGludmFsaWQgcm93cyBzaWxlbnRseVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBUcnkgdG8gZmluZCBlbXBsb3llZSBieSBJRCBmaXJzdCwgdGhlbiBieSBuYW1lXG4gICAgICAgIGxldCBlbXBsb3llZUlkID0gZW1wbG95ZWVJZE9yTmFtZVxuICAgICAgICBjb25zdCBlbXBsb3llZUJ5SWQgPSByZXN1bHQuZW1wbG95ZWVzLmZpbmQoZSA9PiBlLmlkID09PSBlbXBsb3llZUlkT3JOYW1lKVxuICAgICAgICBjb25zdCBlbXBsb3llZUJ5TmFtZSA9IHJlc3VsdC5lbXBsb3llZXMuZmluZChlID0+IGUubmFtZSA9PT0gZW1wbG95ZWVJZE9yTmFtZSlcbiAgICAgICAgXG4gICAgICAgIGlmICghZW1wbG95ZWVCeUlkICYmIGVtcGxveWVlQnlOYW1lKSB7XG4gICAgICAgICAgZW1wbG95ZWVJZCA9IGVtcGxveWVlQnlOYW1lLmlkXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFRyeSB0byBmaW5kIHByb2plY3QgYnkgSUQgZmlyc3QsIHRoZW4gYnkgbmFtZVxuICAgICAgICBsZXQgcHJvamVjdElkID0gcHJvamVjdElkT3JOYW1lXG4gICAgICAgIGNvbnN0IHByb2plY3RCeUlkID0gcmVzdWx0LnByb2plY3RzLmZpbmQocCA9PiBwLmlkID09PSBwcm9qZWN0SWRPck5hbWUpXG4gICAgICAgIGNvbnN0IHByb2plY3RCeU5hbWUgPSByZXN1bHQucHJvamVjdHMuZmluZChwID0+IHAubmFtZSA9PT0gcHJvamVjdElkT3JOYW1lKVxuICAgICAgICBcbiAgICAgICAgaWYgKCFwcm9qZWN0QnlJZCAmJiBwcm9qZWN0QnlOYW1lKSB7XG4gICAgICAgICAgcHJvamVjdElkID0gcHJvamVjdEJ5TmFtZS5pZFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBQcm9jZXNzIGVhY2ggZGF0ZSBjb2x1bW5cbiAgICAgICAgZGF0ZUNvbHVtbnMuZm9yRWFjaChkYXRlQ29sID0+IHtcbiAgICAgICAgICBjb25zdCBob3VycyA9IHJvd1tkYXRlQ29sXVxuICAgICAgICAgIGlmIChob3VycyAmJiBOdW1iZXIoaG91cnMpID4gMCkge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRlLCB3ZWVrIH0gPSBub3JtYWxpemVEYXRlVG9Nb25kYXkoZGF0ZUNvbClcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgYXNzaWdubWVudDogQXNzaWdubWVudCA9IHtcbiAgICAgICAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgICAgICAgZW1wbG95ZWVJZDogZW1wbG95ZWVJZCxcbiAgICAgICAgICAgICAgcHJvamVjdElkOiBwcm9qZWN0SWQsXG4gICAgICAgICAgICAgIGhvdXJzOiBOdW1iZXIoaG91cnMpLFxuICAgICAgICAgICAgICB3ZWVrOiB3ZWVrLFxuICAgICAgICAgICAgICBkYXRlOiBkYXRlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJlc3VsdC5hc3NpZ25tZW50cy5wdXNoKGFzc2lnbm1lbnQpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVHJhZGl0aW9uYWwgZm9ybWF0OiBFYWNoIHJvdyBpcyBvbmUgYXNzaWdubWVudFxuICAgICAgcmVzdWx0LmFzc2lnbm1lbnRzID0gc2hlZXQubWFwKChyb3c6IGFueSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICAvLyBDaGVjayBhbGwgcG9zc2libGUgY29sdW1uIG5hbWVzIGZvciB3ZWVrL2RhdGVcbiAgICAgICAgY29uc3QgcmF3RGF0ZSA9IHJvdy5XZWVrIHx8IHJvd1snV2VlayddIHx8IHJvdy5EYXRlIHx8IHJvd1snRGF0ZSddIHx8IHJvdy53ZWVrIHx8IHJvdy5kYXRlXG4gICAgICAgIGNvbnN0IHsgZGF0ZSwgd2VlayB9ID0gbm9ybWFsaXplRGF0ZVRvTW9uZGF5KHJhd0RhdGUpXG4gICAgICAgIFxuICAgICAgICAvLyBQYXJzZSBob3VycyB3aXRoIGJldHRlciBoYW5kbGluZ1xuICAgICAgICBjb25zdCByYXdIb3VycyA9IHJvdy5Ib3VycyB8fCByb3dbJ0hvdXJzJ10gfHwgcm93LmhvdXJzIHx8IDBcbiAgICAgICAgY29uc3QgcGFyc2VkSG91cnMgPSB0eXBlb2YgcmF3SG91cnMgPT09ICdzdHJpbmcnID8gcGFyc2VGbG9hdChyYXdIb3VycykgfHwgMCA6IE51bWJlcihyYXdIb3VycykgfHwgMFxuICAgICAgICBcbiAgICAgICAgY29uc3QgZW1wbG95ZWVJZE9yTmFtZSA9IHJvd1snRW1wbG95ZWUgSUQnXSB8fCByb3cuRW1wbG95ZWUgfHwgcm93WydFbXBsb3llZSddIHx8IHJvd1snZW1wbG95ZWUnXSB8fCAnJ1xuICAgICAgICBjb25zdCBwcm9qZWN0SWRPck5hbWUgPSByb3dbJ1Byb2plY3QgSUQnXSB8fCByb3cuUHJvamVjdCB8fCByb3dbJ1Byb2plY3QnXSB8fCByb3dbJ3Byb2plY3QnXSB8fCAnJ1xuICAgICAgICBcbiAgICAgICAgLy8gVHJ5IHRvIGZpbmQgZW1wbG95ZWUgYnkgSUQgZmlyc3QsIHRoZW4gYnkgbmFtZVxuICAgICAgICBsZXQgZW1wbG95ZWVJZCA9IGVtcGxveWVlSWRPck5hbWVcbiAgICAgICAgY29uc3QgZW1wbG95ZWVCeUlkID0gcmVzdWx0LmVtcGxveWVlcy5maW5kKGUgPT4gZS5pZCA9PT0gZW1wbG95ZWVJZE9yTmFtZSlcbiAgICAgICAgY29uc3QgZW1wbG95ZWVCeU5hbWUgPSByZXN1bHQuZW1wbG95ZWVzLmZpbmQoZSA9PiBlLm5hbWUgPT09IGVtcGxveWVlSWRPck5hbWUpXG4gICAgICAgIFxuICAgICAgICBpZiAoIWVtcGxveWVlQnlJZCAmJiBlbXBsb3llZUJ5TmFtZSkge1xuICAgICAgICAgIGVtcGxveWVlSWQgPSBlbXBsb3llZUJ5TmFtZS5pZFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBUcnkgdG8gZmluZCBwcm9qZWN0IGJ5IElEIGZpcnN0LCB0aGVuIGJ5IG5hbWVcbiAgICAgICAgbGV0IHByb2plY3RJZCA9IHByb2plY3RJZE9yTmFtZVxuICAgICAgICBjb25zdCBwcm9qZWN0QnlJZCA9IHJlc3VsdC5wcm9qZWN0cy5maW5kKHAgPT4gcC5pZCA9PT0gcHJvamVjdElkT3JOYW1lKVxuICAgICAgICBjb25zdCBwcm9qZWN0QnlOYW1lID0gcmVzdWx0LnByb2plY3RzLmZpbmQocCA9PiBwLm5hbWUgPT09IHByb2plY3RJZE9yTmFtZSlcbiAgICAgICAgXG4gICAgICAgIGlmICghcHJvamVjdEJ5SWQgJiYgcHJvamVjdEJ5TmFtZSkge1xuICAgICAgICAgIHByb2plY3RJZCA9IHByb2plY3RCeU5hbWUuaWRcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3QgYXNzaWdubWVudDogQXNzaWdubWVudCA9IHtcbiAgICAgICAgICBpZDogZ2VuZXJhdGVJZCgpLFxuICAgICAgICAgIGVtcGxveWVlSWQ6IGVtcGxveWVlSWQsXG4gICAgICAgICAgcHJvamVjdElkOiBwcm9qZWN0SWQsXG4gICAgICAgICAgaG91cnM6IHBhcnNlZEhvdXJzLFxuICAgICAgICAgIHdlZWs6IHdlZWssICAvLyBLZWVwIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgICAgIGRhdGU6IGRhdGUgICAvLyBOZXc6IFN0b3JlIGZ1bGwgZGF0ZSBpbiB5eXl5LU1NLWRkIGZvcm1hdFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBBc3NpZ25tZW50IGNyZWF0ZWRcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBhc3NpZ25tZW50XG4gICAgICB9KVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBObyBhc3NpZ25tZW50cyBzaGVldCBmb3VuZFxuICB9XG5cbiAgLy8gUGFyc2UgU2tpbGxzIHNoZWV0IChvcHRpb25hbClcbiAgaWYgKHdvcmtib29rLlNoZWV0c1snU2tpbGxzJ10pIHtcbiAgICBjb25zdCBzaGVldCA9IFhMU1gudXRpbHMuc2hlZXRfdG9fanNvbih3b3JrYm9vay5TaGVldHNbJ1NraWxscyddKVxuICAgIGNvbnN0IHNraWxsU2V0ID0gbmV3IFNldDxzdHJpbmc+KClcbiAgICBcbiAgICBzaGVldC5mb3JFYWNoKChyb3c6IGFueSkgPT4ge1xuICAgICAgT2JqZWN0LmtleXMocm93KS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGlmIChrZXkgIT09ICdFbXBsb3llZScgJiYga2V5ICE9PSAnSUQnICYmIGtleSAhPT0gJ05hbWUnKSB7XG4gICAgICAgICAgc2tpbGxTZXQuYWRkKGtleSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICAgIFxuICAgIHJlc3VsdC5za2lsbHMgPSBBcnJheS5mcm9tKHNraWxsU2V0KVxuICB9IGVsc2Uge1xuICAgIC8vIEV4dHJhY3Qgc2tpbGxzIGZyb20gZW1wbG95ZWVzXG4gICAgY29uc3Qgc2tpbGxTZXQgPSBuZXcgU2V0PHN0cmluZz4oKVxuICAgIHJlc3VsdC5lbXBsb3llZXMuZm9yRWFjaChlbXAgPT4ge1xuICAgICAgT2JqZWN0LmtleXMoZW1wLnNraWxscykuZm9yRWFjaChza2lsbCA9PiBza2lsbFNldC5hZGQoc2tpbGwpKVxuICAgIH0pXG4gICAgcmVzdWx0LnNraWxscyA9IEFycmF5LmZyb20oc2tpbGxTZXQpXG4gIH1cblxuICAvLyBFeHRyYWN0IHRlYW1zXG4gIGNvbnN0IHRlYW1TZXQgPSBuZXcgU2V0KFsnQWxsIFRlYW1zJ10pXG4gIHJlc3VsdC5lbXBsb3llZXMuZm9yRWFjaChlbXAgPT4ge1xuICAgIGlmIChlbXAudGVhbSkgdGVhbVNldC5hZGQoZW1wLnRlYW0pXG4gIH0pXG4gIHJlc3VsdC50ZWFtcyA9IEFycmF5LmZyb20odGVhbVNldClcblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIHBhcnNlU2tpbGxzKHJvdzogYW55KTogUmVjb3JkPHN0cmluZywgUHJvZmljaWVuY3lMZXZlbD4ge1xuICBjb25zdCBza2lsbHM6IFJlY29yZDxzdHJpbmcsIFByb2ZpY2llbmN5TGV2ZWw+ID0ge31cbiAgY29uc3QgZXhjbHVkZUZpZWxkcyA9IFsnTmFtZScsICdFbXBsb3llZScsICdFbWFpbCcsICdJRCcsICdpZCcsICdNYXggSG91cnMnLCAnVGVhbSddXG4gIFxuICBPYmplY3Qua2V5cyhyb3cpLmZvckVhY2goa2V5ID0+IHtcbiAgICBpZiAoIWV4Y2x1ZGVGaWVsZHMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgY29uc3QgdmFsdWUgPSByb3dba2V5XVxuICAgICAgaWYgKHZhbHVlICYmIHZhbHVlICE9PSAnTm9uZScgJiYgdmFsdWUgIT09ICcnKSB7XG4gICAgICAgIC8vIFRyeSB0byBwYXJzZSBhcyBwcm9maWNpZW5jeSBsZXZlbFxuICAgICAgICBpZiAoWydCZWdpbm5lcicsICdJbnRlcm1lZGlhdGUnLCAnRXhwZXJ0J10uaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgICAgc2tpbGxzW2tleV0gPSB2YWx1ZSBhcyBQcm9maWNpZW5jeUxldmVsXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIC8vIENvbnZlcnQgbnVtZXJpYyB2YWx1ZXMgdG8gcHJvZmljaWVuY3kgbGV2ZWxzXG4gICAgICAgICAgaWYgKHZhbHVlID49IDMpIHNraWxsc1trZXldID0gJ0V4cGVydCdcbiAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA+PSAyKSBza2lsbHNba2V5XSA9ICdJbnRlcm1lZGlhdGUnXG4gICAgICAgICAgZWxzZSBpZiAodmFsdWUgPj0gMSkgc2tpbGxzW2tleV0gPSAnQmVnaW5uZXInXG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICAvLyBEZWZhdWx0IHRvIEludGVybWVkaWF0ZSBmb3IgYW55IG90aGVyIG5vbi1lbXB0eSB2YWx1ZVxuICAgICAgICAgIHNraWxsc1trZXldID0gJ0ludGVybWVkaWF0ZSdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgXG4gIHJldHVybiBza2lsbHNcbn0iXSwibmFtZXMiOlsiWExTWCIsImdlbmVyYXRlSWQiLCJub3JtYWxpemVEYXRlVG9XZWVrIiwicGFyc2VGbGV4aWJsZURhdGUiLCJ2YWxpZGF0ZUV4Y2VsRGF0YSIsIm5vcm1hbGl6ZURhdGVUb01vbmRheSIsImRhdGVWYWx1ZSIsInBhcnNlRXhjZWxGaWxlIiwiZmlsZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicmVhZGVyIiwiRmlsZVJlYWRlciIsIm9ubG9hZCIsImUiLCJERUJVRyIsImNvbnNvbGUiLCJsb2ciLCJmaWxlU2l6ZSIsInNpemUiLCJ0YXJnZXQiLCJyZXN1bHQiLCJFcnJvciIsImRhdGEiLCJVaW50OEFycmF5Iiwid29ya2Jvb2siLCJyZWFkIiwidHlwZSIsImNlbGxEYXRlcyIsIlNoZWV0cyIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJwYXJzZVdvcmtib29rIiwiZW1wbG95ZWVzIiwicHJvamVjdHMiLCJhc3NpZ25tZW50cyIsInZhbGlkYXRpb24iLCJpc1ZhbGlkIiwiZXJyb3JNZXNzYWdlIiwiZXJyb3JzIiwiam9pbiIsIndhcm5pbmdzIiwid2FybiIsImVycm9yIiwib25lcnJvciIsInJlYWRBc0FycmF5QnVmZmVyIiwic2tpbGxzIiwidGVhbXMiLCJzaGVldCIsInV0aWxzIiwic2hlZXRfdG9fanNvbiIsIm1hcCIsInJvdyIsImlkIiwiSUQiLCJuYW1lIiwiTmFtZSIsIkVtcGxveWVlIiwiZW1haWwiLCJFbWFpbCIsIm1heEhvdXJzIiwiTnVtYmVyIiwidGVhbSIsIlRlYW0iLCJwYXJzZVNraWxscyIsIlByb2plY3QiLCJzdGFydERhdGUiLCJEYXRlIiwiZW5kRGF0ZSIsInJlcXVpcmVkU2tpbGxzIiwiU3RyaW5nIiwic3BsaXQiLCJzIiwidHJpbSIsInBvcnRmb2xpbyIsIlBvcnRmb2xpbyIsImZpcnN0Um93IiwiY29sdW1ucyIsImRhdGVDb2x1bW5zIiwiZmlsdGVyIiwiY29sIiwidGVzdCIsImZvckVhY2giLCJyb3dJbmRleCIsImVtcGxveWVlSWRPck5hbWUiLCJwcm9qZWN0SWRPck5hbWUiLCJlbXBsb3llZUlkIiwiZW1wbG95ZWVCeUlkIiwiZmluZCIsImVtcGxveWVlQnlOYW1lIiwicHJvamVjdElkIiwicHJvamVjdEJ5SWQiLCJwIiwicHJvamVjdEJ5TmFtZSIsImRhdGVDb2wiLCJob3VycyIsImRhdGUiLCJ3ZWVrIiwiYXNzaWdubWVudCIsInB1c2giLCJpbmRleCIsInJhd0RhdGUiLCJXZWVrIiwicmF3SG91cnMiLCJIb3VycyIsInBhcnNlZEhvdXJzIiwicGFyc2VGbG9hdCIsInNraWxsU2V0IiwiU2V0Iiwia2V5IiwiYWRkIiwiQXJyYXkiLCJmcm9tIiwiZW1wIiwic2tpbGwiLCJ0ZWFtU2V0IiwiZXhjbHVkZUZpZWxkcyIsImluY2x1ZGVzIiwidmFsdWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/excel/parser.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/excel/validator.ts":
/*!********************************!*\
  !*** ./lib/excel/validator.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   validateAssignment: () => (/* binding */ validateAssignment),\n/* harmony export */   validateEmployee: () => (/* binding */ validateEmployee),\n/* harmony export */   validateExcelData: () => (/* binding */ validateExcelData),\n/* harmony export */   validateProject: () => (/* binding */ validateProject)\n/* harmony export */ });\n/**\n * Validates employee data from Excel\n */ function validateEmployee(employee, index) {\n    const errors = [];\n    const warnings = [];\n    // Required fields\n    if (!employee.id && !employee.ID && !employee.Name && !employee.name) {\n        errors.push(\"Row \".concat(index + 2, \": Employee must have an ID or Name\"));\n    }\n    // Validate max hours\n    const maxHours = employee['Max Hours'] || employee.maxHours || employee['max hours'];\n    if (maxHours !== undefined) {\n        const hours = Number(maxHours);\n        if (isNaN(hours) || hours < 0) {\n            errors.push(\"Row \".concat(index + 2, \": Invalid max hours value: \").concat(maxHours));\n        } else if (hours > 80) {\n            warnings.push(\"Row \".concat(index + 2, \": Unusually high max hours: \").concat(hours));\n        }\n    }\n    // Validate email format if provided\n    const email = employee.Email || employee.email;\n    if (email && !isValidEmail(email)) {\n        warnings.push(\"Row \".concat(index + 2, \": Invalid email format: \").concat(email));\n    }\n    return {\n        isValid: errors.length === 0,\n        errors,\n        warnings\n    };\n}\n/**\n * Validates project data from Excel\n */ function validateProject(project, index) {\n    const errors = [];\n    const warnings = [];\n    // Required fields\n    if (!project.id && !project.ID && !project.Name && !project.name) {\n        errors.push(\"Row \".concat(index + 2, \": Project must have an ID or Name\"));\n    }\n    // Validate dates\n    const startDate = project['Start Date'] || project.startDate || project['start date'];\n    const endDate = project['End Date'] || project.endDate || project['end date'];\n    if (!startDate) {\n        errors.push(\"Row \".concat(index + 2, \": Project missing start date\"));\n    }\n    if (!endDate) {\n        errors.push(\"Row \".concat(index + 2, \": Project missing end date\"));\n    }\n    if (startDate && endDate) {\n        const start = new Date(startDate);\n        const end = new Date(endDate);\n        if (isNaN(start.getTime())) {\n            errors.push(\"Row \".concat(index + 2, \": Invalid start date format: \").concat(startDate));\n        }\n        if (isNaN(end.getTime())) {\n            errors.push(\"Row \".concat(index + 2, \": Invalid end date format: \").concat(endDate));\n        }\n        if (!isNaN(start.getTime()) && !isNaN(end.getTime()) && start > end) {\n            errors.push(\"Row \".concat(index + 2, \": Start date is after end date\"));\n        }\n        // Warn about projects longer than 2 years\n        if (!isNaN(start.getTime()) && !isNaN(end.getTime())) {\n            const durationDays = (end.getTime() - start.getTime()) / (1000 * 60 * 60 * 24);\n            if (durationDays > 730) {\n                warnings.push(\"Row \".concat(index + 2, \": Project duration exceeds 2 years\"));\n            }\n        }\n    }\n    return {\n        isValid: errors.length === 0,\n        errors,\n        warnings\n    };\n}\n/**\n * Validates assignment data from Excel\n */ function validateAssignment(assignment, index, employees, projects) {\n    const errors = [];\n    const warnings = [];\n    // Check employee reference\n    const employeeRef = assignment['Employee ID'] || assignment.Employee || assignment.employee || assignment.employeeId;\n    if (!employeeRef) {\n        errors.push(\"Row \".concat(index + 2, \": Assignment missing employee reference\"));\n    } else {\n        // Verify employee exists\n        const employeeExists = employees.some((e)=>e.id === employeeRef || e.name === employeeRef);\n        if (!employeeExists) {\n            errors.push(\"Row \".concat(index + 2, \": Employee not found: \").concat(employeeRef));\n        }\n    }\n    // Check project reference\n    const projectRef = assignment['Project ID'] || assignment.Project || assignment.project || assignment.projectId;\n    if (!projectRef) {\n        errors.push(\"Row \".concat(index + 2, \": Assignment missing project reference\"));\n    } else {\n        // Verify project exists\n        const projectExists = projects.some((p)=>p.id === projectRef || p.name === projectRef);\n        if (!projectExists) {\n            errors.push(\"Row \".concat(index + 2, \": Project not found: \").concat(projectRef));\n        }\n    }\n    // Validate hours\n    const hours = assignment.Hours || assignment.hours;\n    if (hours !== undefined && hours !== null && hours !== '') {\n        const hoursNum = Number(hours);\n        if (isNaN(hoursNum) || hoursNum < 0) {\n            errors.push(\"Row \".concat(index + 2, \": Invalid hours value: \").concat(hours));\n        } else if (hoursNum > 60) {\n            warnings.push(\"Row \".concat(index + 2, \": Unusually high hours for single assignment: \").concat(hoursNum));\n        }\n    }\n    // Check for date/week\n    const hasDate = assignment.Week || assignment.Date || assignment.week || assignment.date;\n    if (!hasDate) {\n        warnings.push(\"Row \".concat(index + 2, \": Assignment missing date/week\"));\n    }\n    return {\n        isValid: errors.length === 0,\n        errors,\n        warnings\n    };\n}\n/**\n * Validates the entire Excel data structure\n */ function validateExcelData(data) {\n    const allErrors = [];\n    const allWarnings = [];\n    // Check for required sheets\n    if (!data.employees || data.employees.length === 0) {\n        allErrors.push('No employees found in the Excel file');\n    }\n    if (!data.projects || data.projects.length === 0) {\n        allErrors.push('No projects found in the Excel file');\n    }\n    // Validate individual records\n    if (data.employees) {\n        data.employees.forEach((emp, i)=>{\n            const result = validateEmployee(emp, i);\n            allErrors.push(...result.errors);\n            allWarnings.push(...result.warnings);\n        });\n    }\n    if (data.projects) {\n        data.projects.forEach((proj, i)=>{\n            const result = validateProject(proj, i);\n            allErrors.push(...result.errors);\n            allWarnings.push(...result.warnings);\n        });\n    }\n    // Only validate assignments if we have valid employees and projects\n    if (data.assignments && data.employees && data.projects) {\n        // Convert to typed arrays for validation\n        const typedEmployees = data.employees;\n        const typedProjects = data.projects;\n        data.assignments.forEach((assign, i)=>{\n            const result = validateAssignment(assign, i, typedEmployees, typedProjects);\n            allErrors.push(...result.errors);\n            allWarnings.push(...result.warnings);\n        });\n    }\n    // Check for duplicate employee IDs\n    if (data.employees) {\n        const employeeIds = data.employees.map((e)=>e.id || e.ID || e.name || e.Name).filter(Boolean);\n        const duplicates = findDuplicates(employeeIds);\n        if (duplicates.length > 0) {\n            allWarnings.push(\"Duplicate employee IDs found: \".concat(duplicates.join(', ')));\n        }\n    }\n    // Check for duplicate project IDs\n    if (data.projects) {\n        const projectIds = data.projects.map((p)=>p.id || p.ID || p.name || p.Name).filter(Boolean);\n        const duplicates = findDuplicates(projectIds);\n        if (duplicates.length > 0) {\n            allWarnings.push(\"Duplicate project IDs found: \".concat(duplicates.join(', ')));\n        }\n    }\n    return {\n        isValid: allErrors.length === 0,\n        errors: allErrors,\n        warnings: allWarnings\n    };\n}\n/**\n * Helper function to validate email format\n */ function isValidEmail(email) {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n}\n/**\n * Helper function to find duplicates in an array\n */ function findDuplicates(arr) {\n    const seen = new Set();\n    const duplicates = new Set();\n    arr.forEach((item)=>{\n        if (seen.has(item)) {\n            duplicates.add(item);\n        }\n        seen.add(item);\n    });\n    return Array.from(duplicates);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9leGNlbC92YWxpZGF0b3IudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQVFBOztDQUVDLEdBQ00sU0FBU0EsaUJBQWlCQyxRQUFhLEVBQUVDLEtBQWE7SUFDM0QsTUFBTUMsU0FBbUIsRUFBRTtJQUMzQixNQUFNQyxXQUFxQixFQUFFO0lBRTdCLGtCQUFrQjtJQUNsQixJQUFJLENBQUNILFNBQVNJLEVBQUUsSUFBSSxDQUFDSixTQUFTSyxFQUFFLElBQUksQ0FBQ0wsU0FBU00sSUFBSSxJQUFJLENBQUNOLFNBQVNPLElBQUksRUFBRTtRQUNwRUwsT0FBT00sSUFBSSxDQUFDLE9BQWlCLE9BQVZQLFFBQVEsR0FBRTtJQUMvQjtJQUVBLHFCQUFxQjtJQUNyQixNQUFNUSxXQUFXVCxRQUFRLENBQUMsWUFBWSxJQUFJQSxTQUFTUyxRQUFRLElBQUlULFFBQVEsQ0FBQyxZQUFZO0lBQ3BGLElBQUlTLGFBQWFDLFdBQVc7UUFDMUIsTUFBTUMsUUFBUUMsT0FBT0g7UUFDckIsSUFBSUksTUFBTUYsVUFBVUEsUUFBUSxHQUFHO1lBQzdCVCxPQUFPTSxJQUFJLENBQUMsT0FBOENDLE9BQXZDUixRQUFRLEdBQUUsK0JBQXNDLE9BQVRRO1FBQzVELE9BQU8sSUFBSUUsUUFBUSxJQUFJO1lBQ3JCUixTQUFTSyxJQUFJLENBQUMsT0FBK0NHLE9BQXhDVixRQUFRLEdBQUUsZ0NBQW9DLE9BQU5VO1FBQy9EO0lBQ0Y7SUFFQSxvQ0FBb0M7SUFDcEMsTUFBTUcsUUFBUWQsU0FBU2UsS0FBSyxJQUFJZixTQUFTYyxLQUFLO0lBQzlDLElBQUlBLFNBQVMsQ0FBQ0UsYUFBYUYsUUFBUTtRQUNqQ1gsU0FBU0ssSUFBSSxDQUFDLE9BQTJDTSxPQUFwQ2IsUUFBUSxHQUFFLDRCQUFnQyxPQUFOYTtJQUMzRDtJQUVBLE9BQU87UUFDTEcsU0FBU2YsT0FBT2dCLE1BQU0sS0FBSztRQUMzQmhCO1FBQ0FDO0lBQ0Y7QUFDRjtBQUVBOztDQUVDLEdBQ00s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QVNwQyxhQUFhRixLQUFhO0lBQ2pDLE1BQU13RCxhQUFhO0lBQ25CLE9BQU9BLFdBQVdDLElBQUksQ0FBQ3pEO0FBQ3pCO0FBRUE7O0NBRUMsR0FDRCxTQUFTcUQsZUFBZUssR0FBYTtJQUNuQyxNQUFNQyxPQUFPLElBQUlDO0lBQ2pCLE1BQU1SLGFBQWEsSUFBSVE7SUFFdkJGLElBQUluQixPQUFPLENBQUNzQixDQUFBQTtRQUNWLElBQUlGLEtBQUtHLEdBQUcsQ0FBQ0QsT0FBTztZQUNsQlQsV0FBV1csR0FBRyxDQUFDRjtRQUNqQjtRQUNBRixLQUFLSSxHQUFHLENBQUNGO0lBQ1g7SUFFQSxPQUFPRyxNQUFNQyxJQUFJLENBQUNiO0FBQ3BCIiwic291cmNlcyI6WyIvaG9tZS9wNDcyL1NjaGVkdWxlci9saWIvZXhjZWwvdmFsaWRhdG9yLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVtcGxveWVlLCBQcm9qZWN0LCBBc3NpZ25tZW50IH0gZnJvbSAnQC90eXBlcy9zY2hlZHVsZSdcblxuZXhwb3J0IGludGVyZmFjZSBWYWxpZGF0aW9uUmVzdWx0IHtcbiAgaXNWYWxpZDogYm9vbGVhblxuICBlcnJvcnM6IHN0cmluZ1tdXG4gIHdhcm5pbmdzOiBzdHJpbmdbXVxufVxuXG4vKipcbiAqIFZhbGlkYXRlcyBlbXBsb3llZSBkYXRhIGZyb20gRXhjZWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlRW1wbG95ZWUoZW1wbG95ZWU6IGFueSwgaW5kZXg6IG51bWJlcik6IFZhbGlkYXRpb25SZXN1bHQge1xuICBjb25zdCBlcnJvcnM6IHN0cmluZ1tdID0gW11cbiAgY29uc3Qgd2FybmluZ3M6IHN0cmluZ1tdID0gW11cbiAgXG4gIC8vIFJlcXVpcmVkIGZpZWxkc1xuICBpZiAoIWVtcGxveWVlLmlkICYmICFlbXBsb3llZS5JRCAmJiAhZW1wbG95ZWUuTmFtZSAmJiAhZW1wbG95ZWUubmFtZSkge1xuICAgIGVycm9ycy5wdXNoKGBSb3cgJHtpbmRleCArIDJ9OiBFbXBsb3llZSBtdXN0IGhhdmUgYW4gSUQgb3IgTmFtZWApXG4gIH1cbiAgXG4gIC8vIFZhbGlkYXRlIG1heCBob3Vyc1xuICBjb25zdCBtYXhIb3VycyA9IGVtcGxveWVlWydNYXggSG91cnMnXSB8fCBlbXBsb3llZS5tYXhIb3VycyB8fCBlbXBsb3llZVsnbWF4IGhvdXJzJ11cbiAgaWYgKG1heEhvdXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBob3VycyA9IE51bWJlcihtYXhIb3VycylcbiAgICBpZiAoaXNOYU4oaG91cnMpIHx8IGhvdXJzIDwgMCkge1xuICAgICAgZXJyb3JzLnB1c2goYFJvdyAke2luZGV4ICsgMn06IEludmFsaWQgbWF4IGhvdXJzIHZhbHVlOiAke21heEhvdXJzfWApXG4gICAgfSBlbHNlIGlmIChob3VycyA+IDgwKSB7XG4gICAgICB3YXJuaW5ncy5wdXNoKGBSb3cgJHtpbmRleCArIDJ9OiBVbnVzdWFsbHkgaGlnaCBtYXggaG91cnM6ICR7aG91cnN9YClcbiAgICB9XG4gIH1cbiAgXG4gIC8vIFZhbGlkYXRlIGVtYWlsIGZvcm1hdCBpZiBwcm92aWRlZFxuICBjb25zdCBlbWFpbCA9IGVtcGxveWVlLkVtYWlsIHx8IGVtcGxveWVlLmVtYWlsXG4gIGlmIChlbWFpbCAmJiAhaXNWYWxpZEVtYWlsKGVtYWlsKSkge1xuICAgIHdhcm5pbmdzLnB1c2goYFJvdyAke2luZGV4ICsgMn06IEludmFsaWQgZW1haWwgZm9ybWF0OiAke2VtYWlsfWApXG4gIH1cbiAgXG4gIHJldHVybiB7XG4gICAgaXNWYWxpZDogZXJyb3JzLmxlbmd0aCA9PT0gMCxcbiAgICBlcnJvcnMsXG4gICAgd2FybmluZ3NcbiAgfVxufVxuXG4vKipcbiAqIFZhbGlkYXRlcyBwcm9qZWN0IGRhdGEgZnJvbSBFeGNlbFxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVQcm9qZWN0KHByb2plY3Q6IGFueSwgaW5kZXg6IG51bWJlcik6IFZhbGlkYXRpb25SZXN1bHQge1xuICBjb25zdCBlcnJvcnM6IHN0cmluZ1tdID0gW11cbiAgY29uc3Qgd2FybmluZ3M6IHN0cmluZ1tdID0gW11cbiAgXG4gIC8vIFJlcXVpcmVkIGZpZWxkc1xuICBpZiAoIXByb2plY3QuaWQgJiYgIXByb2plY3QuSUQgJiYgIXByb2plY3QuTmFtZSAmJiAhcHJvamVjdC5uYW1lKSB7XG4gICAgZXJyb3JzLnB1c2goYFJvdyAke2luZGV4ICsgMn06IFByb2plY3QgbXVzdCBoYXZlIGFuIElEIG9yIE5hbWVgKVxuICB9XG4gIFxuICAvLyBWYWxpZGF0ZSBkYXRlc1xuICBjb25zdCBzdGFydERhdGUgPSBwcm9qZWN0WydTdGFydCBEYXRlJ10gfHwgcHJvamVjdC5zdGFydERhdGUgfHwgcHJvamVjdFsnc3RhcnQgZGF0ZSddXG4gIGNvbnN0IGVuZERhdGUgPSBwcm9qZWN0WydFbmQgRGF0ZSddIHx8IHByb2plY3QuZW5kRGF0ZSB8fCBwcm9qZWN0WydlbmQgZGF0ZSddXG4gIFxuICBpZiAoIXN0YXJ0RGF0ZSkge1xuICAgIGVycm9ycy5wdXNoKGBSb3cgJHtpbmRleCArIDJ9OiBQcm9qZWN0IG1pc3Npbmcgc3RhcnQgZGF0ZWApXG4gIH1cbiAgXG4gIGlmICghZW5kRGF0ZSkge1xuICAgIGVycm9ycy5wdXNoKGBSb3cgJHtpbmRleCArIDJ9OiBQcm9qZWN0IG1pc3NpbmcgZW5kIGRhdGVgKVxuICB9XG4gIFxuICBpZiAoc3RhcnREYXRlICYmIGVuZERhdGUpIHtcbiAgICBjb25zdCBzdGFydCA9IG5ldyBEYXRlKHN0YXJ0RGF0ZSlcbiAgICBjb25zdCBlbmQgPSBuZXcgRGF0ZShlbmREYXRlKVxuICAgIFxuICAgIGlmIChpc05hTihzdGFydC5nZXRUaW1lKCkpKSB7XG4gICAgICBlcnJvcnMucHVzaChgUm93ICR7aW5kZXggKyAyfTogSW52YWxpZCBzdGFydCBkYXRlIGZvcm1hdDogJHtzdGFydERhdGV9YClcbiAgICB9XG4gICAgXG4gICAgaWYgKGlzTmFOKGVuZC5nZXRUaW1lKCkpKSB7XG4gICAgICBlcnJvcnMucHVzaChgUm93ICR7aW5kZXggKyAyfTogSW52YWxpZCBlbmQgZGF0ZSBmb3JtYXQ6ICR7ZW5kRGF0ZX1gKVxuICAgIH1cbiAgICBcbiAgICBpZiAoIWlzTmFOKHN0YXJ0LmdldFRpbWUoKSkgJiYgIWlzTmFOKGVuZC5nZXRUaW1lKCkpICYmIHN0YXJ0ID4gZW5kKSB7XG4gICAgICBlcnJvcnMucHVzaChgUm93ICR7aW5kZXggKyAyfTogU3RhcnQgZGF0ZSBpcyBhZnRlciBlbmQgZGF0ZWApXG4gICAgfVxuICAgIFxuICAgIC8vIFdhcm4gYWJvdXQgcHJvamVjdHMgbG9uZ2VyIHRoYW4gMiB5ZWFyc1xuICAgIGlmICghaXNOYU4oc3RhcnQuZ2V0VGltZSgpKSAmJiAhaXNOYU4oZW5kLmdldFRpbWUoKSkpIHtcbiAgICAgIGNvbnN0IGR1cmF0aW9uRGF5cyA9IChlbmQuZ2V0VGltZSgpIC0gc3RhcnQuZ2V0VGltZSgpKSAvICgxMDAwICogNjAgKiA2MCAqIDI0KVxuICAgICAgaWYgKGR1cmF0aW9uRGF5cyA+IDczMCkge1xuICAgICAgICB3YXJuaW5ncy5wdXNoKGBSb3cgJHtpbmRleCArIDJ9OiBQcm9qZWN0IGR1cmF0aW9uIGV4Y2VlZHMgMiB5ZWFyc2ApXG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4ge1xuICAgIGlzVmFsaWQ6IGVycm9ycy5sZW5ndGggPT09IDAsXG4gICAgZXJyb3JzLFxuICAgIHdhcm5pbmdzXG4gIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZXMgYXNzaWdubWVudCBkYXRhIGZyb20gRXhjZWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQXNzaWdubWVudChhc3NpZ25tZW50OiBhbnksIGluZGV4OiBudW1iZXIsIGVtcGxveWVlczogRW1wbG95ZWVbXSwgcHJvamVjdHM6IFByb2plY3RbXSk6IFZhbGlkYXRpb25SZXN1bHQge1xuICBjb25zdCBlcnJvcnM6IHN0cmluZ1tdID0gW11cbiAgY29uc3Qgd2FybmluZ3M6IHN0cmluZ1tdID0gW11cbiAgXG4gIC8vIENoZWNrIGVtcGxveWVlIHJlZmVyZW5jZVxuICBjb25zdCBlbXBsb3llZVJlZiA9IGFzc2lnbm1lbnRbJ0VtcGxveWVlIElEJ10gfHwgYXNzaWdubWVudC5FbXBsb3llZSB8fCBhc3NpZ25tZW50LmVtcGxveWVlIHx8IGFzc2lnbm1lbnQuZW1wbG95ZWVJZFxuICBpZiAoIWVtcGxveWVlUmVmKSB7XG4gICAgZXJyb3JzLnB1c2goYFJvdyAke2luZGV4ICsgMn06IEFzc2lnbm1lbnQgbWlzc2luZyBlbXBsb3llZSByZWZlcmVuY2VgKVxuICB9IGVsc2Uge1xuICAgIC8vIFZlcmlmeSBlbXBsb3llZSBleGlzdHNcbiAgICBjb25zdCBlbXBsb3llZUV4aXN0cyA9IGVtcGxveWVlcy5zb21lKGUgPT4gXG4gICAgICBlLmlkID09PSBlbXBsb3llZVJlZiB8fCBlLm5hbWUgPT09IGVtcGxveWVlUmVmXG4gICAgKVxuICAgIGlmICghZW1wbG95ZWVFeGlzdHMpIHtcbiAgICAgIGVycm9ycy5wdXNoKGBSb3cgJHtpbmRleCArIDJ9OiBFbXBsb3llZSBub3QgZm91bmQ6ICR7ZW1wbG95ZWVSZWZ9YClcbiAgICB9XG4gIH1cbiAgXG4gIC8vIENoZWNrIHByb2plY3QgcmVmZXJlbmNlXG4gIGNvbnN0IHByb2plY3RSZWYgPSBhc3NpZ25tZW50WydQcm9qZWN0IElEJ10gfHwgYXNzaWdubWVudC5Qcm9qZWN0IHx8IGFzc2lnbm1lbnQucHJvamVjdCB8fCBhc3NpZ25tZW50LnByb2plY3RJZFxuICBpZiAoIXByb2plY3RSZWYpIHtcbiAgICBlcnJvcnMucHVzaChgUm93ICR7aW5kZXggKyAyfTogQXNzaWdubWVudCBtaXNzaW5nIHByb2plY3QgcmVmZXJlbmNlYClcbiAgfSBlbHNlIHtcbiAgICAvLyBWZXJpZnkgcHJvamVjdCBleGlzdHNcbiAgICBjb25zdCBwcm9qZWN0RXhpc3RzID0gcHJvamVjdHMuc29tZShwID0+IFxuICAgICAgcC5pZCA9PT0gcHJvamVjdFJlZiB8fCBwLm5hbWUgPT09IHByb2plY3RSZWZcbiAgICApXG4gICAgaWYgKCFwcm9qZWN0RXhpc3RzKSB7XG4gICAgICBlcnJvcnMucHVzaChgUm93ICR7aW5kZXggKyAyfTogUHJvamVjdCBub3QgZm91bmQ6ICR7cHJvamVjdFJlZn1gKVxuICAgIH1cbiAgfVxuICBcbiAgLy8gVmFsaWRhdGUgaG91cnNcbiAgY29uc3QgaG91cnMgPSBhc3NpZ25tZW50LkhvdXJzIHx8IGFzc2lnbm1lbnQuaG91cnNcbiAgaWYgKGhvdXJzICE9PSB1bmRlZmluZWQgJiYgaG91cnMgIT09IG51bGwgJiYgaG91cnMgIT09ICcnKSB7XG4gICAgY29uc3QgaG91cnNOdW0gPSBOdW1iZXIoaG91cnMpXG4gICAgaWYgKGlzTmFOKGhvdXJzTnVtKSB8fCBob3Vyc051bSA8IDApIHtcbiAgICAgIGVycm9ycy5wdXNoKGBSb3cgJHtpbmRleCArIDJ9OiBJbnZhbGlkIGhvdXJzIHZhbHVlOiAke2hvdXJzfWApXG4gICAgfSBlbHNlIGlmIChob3Vyc051bSA+IDYwKSB7XG4gICAgICB3YXJuaW5ncy5wdXNoKGBSb3cgJHtpbmRleCArIDJ9OiBVbnVzdWFsbHkgaGlnaCBob3VycyBmb3Igc2luZ2xlIGFzc2lnbm1lbnQ6ICR7aG91cnNOdW19YClcbiAgICB9XG4gIH1cbiAgXG4gIC8vIENoZWNrIGZvciBkYXRlL3dlZWtcbiAgY29uc3QgaGFzRGF0ZSA9IGFzc2lnbm1lbnQuV2VlayB8fCBhc3NpZ25tZW50LkRhdGUgfHwgYXNzaWdubWVudC53ZWVrIHx8IGFzc2lnbm1lbnQuZGF0ZVxuICBpZiAoIWhhc0RhdGUpIHtcbiAgICB3YXJuaW5ncy5wdXNoKGBSb3cgJHtpbmRleCArIDJ9OiBBc3NpZ25tZW50IG1pc3NpbmcgZGF0ZS93ZWVrYClcbiAgfVxuICBcbiAgcmV0dXJuIHtcbiAgICBpc1ZhbGlkOiBlcnJvcnMubGVuZ3RoID09PSAwLFxuICAgIGVycm9ycyxcbiAgICB3YXJuaW5nc1xuICB9XG59XG5cbi8qKlxuICogVmFsaWRhdGVzIHRoZSBlbnRpcmUgRXhjZWwgZGF0YSBzdHJ1Y3R1cmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlRXhjZWxEYXRhKGRhdGE6IHtcbiAgZW1wbG95ZWVzOiBhbnlbXVxuICBwcm9qZWN0czogYW55W11cbiAgYXNzaWdubWVudHM6IGFueVtdXG59KTogVmFsaWRhdGlvblJlc3VsdCB7XG4gIGNvbnN0IGFsbEVycm9yczogc3RyaW5nW10gPSBbXVxuICBjb25zdCBhbGxXYXJuaW5nczogc3RyaW5nW10gPSBbXVxuICBcbiAgLy8gQ2hlY2sgZm9yIHJlcXVpcmVkIHNoZWV0c1xuICBpZiAoIWRhdGEuZW1wbG95ZWVzIHx8IGRhdGEuZW1wbG95ZWVzLmxlbmd0aCA9PT0gMCkge1xuICAgIGFsbEVycm9ycy5wdXNoKCdObyBlbXBsb3llZXMgZm91bmQgaW4gdGhlIEV4Y2VsIGZpbGUnKVxuICB9XG4gIFxuICBpZiAoIWRhdGEucHJvamVjdHMgfHwgZGF0YS5wcm9qZWN0cy5sZW5ndGggPT09IDApIHtcbiAgICBhbGxFcnJvcnMucHVzaCgnTm8gcHJvamVjdHMgZm91bmQgaW4gdGhlIEV4Y2VsIGZpbGUnKVxuICB9XG4gIFxuICAvLyBWYWxpZGF0ZSBpbmRpdmlkdWFsIHJlY29yZHNcbiAgaWYgKGRhdGEuZW1wbG95ZWVzKSB7XG4gICAgZGF0YS5lbXBsb3llZXMuZm9yRWFjaCgoZW1wLCBpKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZUVtcGxveWVlKGVtcCwgaSlcbiAgICAgIGFsbEVycm9ycy5wdXNoKC4uLnJlc3VsdC5lcnJvcnMpXG4gICAgICBhbGxXYXJuaW5ncy5wdXNoKC4uLnJlc3VsdC53YXJuaW5ncylcbiAgICB9KVxuICB9XG4gIFxuICBpZiAoZGF0YS5wcm9qZWN0cykge1xuICAgIGRhdGEucHJvamVjdHMuZm9yRWFjaCgocHJvaiwgaSkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGVQcm9qZWN0KHByb2osIGkpXG4gICAgICBhbGxFcnJvcnMucHVzaCguLi5yZXN1bHQuZXJyb3JzKVxuICAgICAgYWxsV2FybmluZ3MucHVzaCguLi5yZXN1bHQud2FybmluZ3MpXG4gICAgfSlcbiAgfVxuICBcbiAgLy8gT25seSB2YWxpZGF0ZSBhc3NpZ25tZW50cyBpZiB3ZSBoYXZlIHZhbGlkIGVtcGxveWVlcyBhbmQgcHJvamVjdHNcbiAgaWYgKGRhdGEuYXNzaWdubWVudHMgJiYgZGF0YS5lbXBsb3llZXMgJiYgZGF0YS5wcm9qZWN0cykge1xuICAgIC8vIENvbnZlcnQgdG8gdHlwZWQgYXJyYXlzIGZvciB2YWxpZGF0aW9uXG4gICAgY29uc3QgdHlwZWRFbXBsb3llZXMgPSBkYXRhLmVtcGxveWVlcyBhcyBFbXBsb3llZVtdXG4gICAgY29uc3QgdHlwZWRQcm9qZWN0cyA9IGRhdGEucHJvamVjdHMgYXMgUHJvamVjdFtdXG4gICAgXG4gICAgZGF0YS5hc3NpZ25tZW50cy5mb3JFYWNoKChhc3NpZ24sIGkpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlQXNzaWdubWVudChhc3NpZ24sIGksIHR5cGVkRW1wbG95ZWVzLCB0eXBlZFByb2plY3RzKVxuICAgICAgYWxsRXJyb3JzLnB1c2goLi4ucmVzdWx0LmVycm9ycylcbiAgICAgIGFsbFdhcm5pbmdzLnB1c2goLi4ucmVzdWx0Lndhcm5pbmdzKVxuICAgIH0pXG4gIH1cbiAgXG4gIC8vIENoZWNrIGZvciBkdXBsaWNhdGUgZW1wbG95ZWUgSURzXG4gIGlmIChkYXRhLmVtcGxveWVlcykge1xuICAgIGNvbnN0IGVtcGxveWVlSWRzID0gZGF0YS5lbXBsb3llZXNcbiAgICAgIC5tYXAoZSA9PiBlLmlkIHx8IGUuSUQgfHwgZS5uYW1lIHx8IGUuTmFtZSlcbiAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICBjb25zdCBkdXBsaWNhdGVzID0gZmluZER1cGxpY2F0ZXMoZW1wbG95ZWVJZHMpXG4gICAgaWYgKGR1cGxpY2F0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgYWxsV2FybmluZ3MucHVzaChgRHVwbGljYXRlIGVtcGxveWVlIElEcyBmb3VuZDogJHtkdXBsaWNhdGVzLmpvaW4oJywgJyl9YClcbiAgICB9XG4gIH1cbiAgXG4gIC8vIENoZWNrIGZvciBkdXBsaWNhdGUgcHJvamVjdCBJRHNcbiAgaWYgKGRhdGEucHJvamVjdHMpIHtcbiAgICBjb25zdCBwcm9qZWN0SWRzID0gZGF0YS5wcm9qZWN0c1xuICAgICAgLm1hcChwID0+IHAuaWQgfHwgcC5JRCB8fCBwLm5hbWUgfHwgcC5OYW1lKVxuICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgIGNvbnN0IGR1cGxpY2F0ZXMgPSBmaW5kRHVwbGljYXRlcyhwcm9qZWN0SWRzKVxuICAgIGlmIChkdXBsaWNhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGFsbFdhcm5pbmdzLnB1c2goYER1cGxpY2F0ZSBwcm9qZWN0IElEcyBmb3VuZDogJHtkdXBsaWNhdGVzLmpvaW4oJywgJyl9YClcbiAgICB9XG4gIH1cbiAgXG4gIHJldHVybiB7XG4gICAgaXNWYWxpZDogYWxsRXJyb3JzLmxlbmd0aCA9PT0gMCxcbiAgICBlcnJvcnM6IGFsbEVycm9ycyxcbiAgICB3YXJuaW5nczogYWxsV2FybmluZ3NcbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byB2YWxpZGF0ZSBlbWFpbCBmb3JtYXRcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEVtYWlsKGVtYWlsOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgY29uc3QgZW1haWxSZWdleCA9IC9eW15cXHNAXStAW15cXHNAXStcXC5bXlxcc0BdKyQvXG4gIHJldHVybiBlbWFpbFJlZ2V4LnRlc3QoZW1haWwpXG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGZpbmQgZHVwbGljYXRlcyBpbiBhbiBhcnJheVxuICovXG5mdW5jdGlvbiBmaW5kRHVwbGljYXRlcyhhcnI6IHN0cmluZ1tdKTogc3RyaW5nW10ge1xuICBjb25zdCBzZWVuID0gbmV3IFNldDxzdHJpbmc+KClcbiAgY29uc3QgZHVwbGljYXRlcyA9IG5ldyBTZXQ8c3RyaW5nPigpXG4gIFxuICBhcnIuZm9yRWFjaChpdGVtID0+IHtcbiAgICBpZiAoc2Vlbi5oYXMoaXRlbSkpIHtcbiAgICAgIGR1cGxpY2F0ZXMuYWRkKGl0ZW0pXG4gICAgfVxuICAgIHNlZW4uYWRkKGl0ZW0pXG4gIH0pXG4gIFxuICByZXR1cm4gQXJyYXkuZnJvbShkdXBsaWNhdGVzKVxufSJdLCJuYW1lcyI6WyJ2YWxpZGF0ZUVtcGxveWVlIiwiZW1wbG95ZWUiLCJpbmRleCIsImVycm9ycyIsIndhcm5pbmdzIiwiaWQiLCJJRCIsIk5hbWUiLCJuYW1lIiwicHVzaCIsIm1heEhvdXJzIiwidW5kZWZpbmVkIiwiaG91cnMiLCJOdW1iZXIiLCJpc05hTiIsImVtYWlsIiwiRW1haWwiLCJpc1ZhbGlkRW1haWwiLCJpc1ZhbGlkIiwibGVuZ3RoIiwidmFsaWRhdGVQcm9qZWN0IiwicHJvamVjdCIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJzdGFydCIsIkRhdGUiLCJlbmQiLCJnZXRUaW1lIiwiZHVyYXRpb25EYXlzIiwidmFsaWRhdGVBc3NpZ25tZW50IiwiYXNzaWdubWVudCIsImVtcGxveWVlcyIsInByb2plY3RzIiwiZW1wbG95ZWVSZWYiLCJFbXBsb3llZSIsImVtcGxveWVlSWQiLCJlbXBsb3llZUV4aXN0cyIsInNvbWUiLCJlIiwicHJvamVjdFJlZiIsIlByb2plY3QiLCJwcm9qZWN0SWQiLCJwcm9qZWN0RXhpc3RzIiwicCIsIkhvdXJzIiwiaG91cnNOdW0iLCJoYXNEYXRlIiwiV2VlayIsIndlZWsiLCJkYXRlIiwidmFsaWRhdGVFeGNlbERhdGEiLCJkYXRhIiwiYWxsRXJyb3JzIiwiYWxsV2FybmluZ3MiLCJmb3JFYWNoIiwiZW1wIiwiaSIsInJlc3VsdCIsInByb2oiLCJhc3NpZ25tZW50cyIsInR5cGVkRW1wbG95ZWVzIiwidHlwZWRQcm9qZWN0cyIsImFzc2lnbiIsImVtcGxveWVlSWRzIiwibWFwIiwiZmlsdGVyIiwiQm9vbGVhbiIsImR1cGxpY2F0ZXMiLCJmaW5kRHVwbGljYXRlcyIsImpvaW4iLCJwcm9qZWN0SWRzIiwiZW1haWxSZWdleCIsInRlc3QiLCJhcnIiLCJzZWVuIiwiU2V0IiwiaXRlbSIsImhhcyIsImFkZCIsIkFycmF5IiwiZnJvbSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/excel/validator.ts\n"));

/***/ }),

/***/ "?0b7b":
/*!*************************!*\
  !*** process (ignored) ***!
  \*************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/* (ignored) */

/***/ }),

/***/ "?1bda":
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/* (ignored) */

/***/ })

}]);