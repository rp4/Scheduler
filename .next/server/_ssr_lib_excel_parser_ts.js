"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_ssr_lib_excel_parser_ts";
exports.ids = ["_ssr_lib_excel_parser_ts"];
exports.modules = {

/***/ "(ssr)/./lib/date-utils.ts":
/*!***************************!*\
  !*** ./lib/date-utils.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   areSameDay: () => (/* binding */ areSameDay),\n/* harmony export */   daysBetween: () => (/* binding */ daysBetween),\n/* harmony export */   formatDate: () => (/* binding */ formatDate),\n/* harmony export */   getMondayOfWeek: () => (/* binding */ getMondayOfWeek),\n/* harmony export */   getWeekIdentifier: () => (/* binding */ getWeekIdentifier),\n/* harmony export */   isValidDateString: () => (/* binding */ isValidDateString),\n/* harmony export */   normalizeDateToWeek: () => (/* binding */ normalizeDateToWeek),\n/* harmony export */   parseFlexibleDate: () => (/* binding */ parseFlexibleDate)\n/* harmony export */ });\n/* harmony import */ var _barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! __barrel_optimize__?names=format,isValid,parse,startOfWeek!=!date-fns */ \"(ssr)/./node_modules/date-fns/isValid.js\");\n/* harmony import */ var _barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! __barrel_optimize__?names=format,isValid,parse,startOfWeek!=!date-fns */ \"(ssr)/./node_modules/date-fns/parse.js\");\n/* harmony import */ var _barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! __barrel_optimize__?names=format,isValid,parse,startOfWeek!=!date-fns */ \"(ssr)/./node_modules/date-fns/format.js\");\n/* harmony import */ var _barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! __barrel_optimize__?names=format,isValid,parse,startOfWeek!=!date-fns */ \"(ssr)/./node_modules/date-fns/startOfWeek.js\");\n\n/**\n * Parses various date formats into a Date object\n * Supports Excel dates, ISO strings, and common date formats\n */ function parseFlexibleDate(dateValue) {\n    if (!dateValue) return null;\n    // Already a valid Date object\n    if (dateValue instanceof Date && (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_0__.isValid)(dateValue)) {\n        return dateValue;\n    }\n    // Excel date number (days since 1900-01-01, with Excel's leap year bug)\n    if (typeof dateValue === 'number' && dateValue > 0) {\n        // Excel dates: number of days since 1900-01-01 (with leap year bug for 1900)\n        const excelEpoch = new Date(1900, 0, 1);\n        const msPerDay = 24 * 60 * 60 * 1000;\n        // Subtract 2 to account for Excel's leap year bug (1900 not a leap year) and 0-indexing\n        const date = new Date(excelEpoch.getTime() + (dateValue - 2) * msPerDay);\n        if ((0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_0__.isValid)(date)) return date;\n    }\n    // String date\n    if (typeof dateValue === 'string') {\n        const dateStr = dateValue.trim();\n        // Try parsing as ISO date\n        const isoDate = new Date(dateStr);\n        if ((0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_0__.isValid)(isoDate)) {\n            return isoDate;\n        }\n        // Try common date formats\n        const formats = [\n            'yyyy-MM-dd',\n            'MM/dd/yyyy',\n            'M/d/yyyy',\n            'dd/MM/yyyy',\n            'd/M/yyyy',\n            'MMM d yyyy',\n            'd-MMM-yyyy',\n            'yyyy/MM/dd',\n            'dd-MM-yyyy',\n            'MM-dd-yyyy'\n        ];\n        for (const fmt of formats){\n            try {\n                const parsed = (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_1__.parse)(dateStr, fmt, new Date());\n                if ((0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_0__.isValid)(parsed)) {\n                    return parsed;\n                }\n            } catch  {\n            // Continue to next format\n            }\n        }\n    }\n    return null;\n}\n/**\n * Formats a date consistently as yyyy-MM-dd\n */ function formatDate(date) {\n    const parsed = typeof date === 'string' || typeof date === 'number' ? parseFlexibleDate(date) : date;\n    if (!parsed || !(0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_0__.isValid)(parsed)) {\n        return (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_2__.format)(new Date(), 'yyyy-MM-dd');\n    }\n    return (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_2__.format)(parsed, 'yyyy-MM-dd');\n}\n/**\n * Gets the Monday of the week for a given date\n */ function getMondayOfWeek(date) {\n    const parsed = typeof date === 'string' || typeof date === 'number' ? parseFlexibleDate(date) : date;\n    if (!parsed || !(0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_0__.isValid)(parsed)) {\n        return (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_3__.startOfWeek)(new Date(), {\n            weekStartsOn: 1\n        });\n    }\n    return (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_3__.startOfWeek)(parsed, {\n        weekStartsOn: 1\n    });\n}\n/**\n * Gets week identifier in format \"YYYY-WW\"\n */ function getWeekIdentifier(date) {\n    const monday = getMondayOfWeek(date);\n    return (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_2__.format)(monday, \"yyyy-'W'II\");\n}\n/**\n * Normalizes a date to Monday of its week and returns both date and week strings\n */ function normalizeDateToWeek(dateValue) {\n    const parsed = parseFlexibleDate(dateValue);\n    if (!parsed) {\n        // Fallback to current week\n        const now = new Date();\n        const monday = getMondayOfWeek(now);\n        return {\n            date: formatDate(monday),\n            week: getWeekIdentifier(monday)\n        };\n    }\n    const monday = getMondayOfWeek(parsed);\n    return {\n        date: formatDate(monday),\n        week: getWeekIdentifier(monday)\n    };\n}\n/**\n * Checks if a date string is in a valid format\n */ function isValidDateString(dateStr) {\n    const parsed = parseFlexibleDate(dateStr);\n    return parsed !== null && (0,_barrel_optimize_names_format_isValid_parse_startOfWeek_date_fns__WEBPACK_IMPORTED_MODULE_0__.isValid)(parsed);\n}\n/**\n * Compares two dates for equality (ignoring time)\n */ function areSameDay(date1, date2) {\n    const d1 = parseFlexibleDate(date1);\n    const d2 = parseFlexibleDate(date2);\n    if (!d1 || !d2) return false;\n    return formatDate(d1) === formatDate(d2);\n}\n/**\n * Gets the number of days between two dates\n */ function daysBetween(startDate, endDate) {\n    const start = parseFlexibleDate(startDate);\n    const end = parseFlexibleDate(endDate);\n    if (!start || !end) return 0;\n    const msPerDay = 24 * 60 * 60 * 1000;\n    return Math.floor((end.getTime() - start.getTime()) / msPerDay);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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ZCxPQUFlO0lBQy9DLE1BQU1LLFNBQVNaLGtCQUFrQk87SUFDakMsT0FBT0ssV0FBVyxRQUFRZCx5R0FBT0EsQ0FBQ2M7QUFDcEM7QUFFQTs7Q0FFQyxHQUNNLFNBQVNVLFdBQVdDLEtBQTZCLEVBQUVDLEtBQTZCO0lBQ3JGLE1BQU1DLEtBQUt6QixrQkFBa0J1QjtJQUM3QixNQUFNRyxLQUFLMUIsa0JBQWtCd0I7SUFFN0IsSUFBSSxDQUFDQyxNQUFNLENBQUNDLElBQUksT0FBTztJQUV2QixPQUFPYixXQUFXWSxRQUFRWixXQUFXYTtBQUN2QztBQUVBOztDQUVDLEdBQ00sU0FBU0MsWUFBWUMsU0FBaUMsRUFBRUMsT0FBK0I7SUFDNUYsTUFBTUMsUUFBUTlCLGtCQUFrQjRCO0lBQ2hDLE1BQU1HLE1BQU0vQixrQkFBa0I2QjtJQUU5QixJQUFJLENBQUNDLFNBQVMsQ0FBQ0MsS0FBSyxPQUFPO0lBRTNCLE1BQU0zQixXQUFXLEtBQUssS0FBSyxLQUFLO0lBQ2hDLE9BQU80QixLQUFLQyxLQUFLLENBQUMsQ0FBQ0YsSUFBSXpCLE9BQU8sS0FBS3dCLE1BQU14QixPQUFPLEVBQUMsSUFBS0Y7QUFDeEQiLCJzb3VyY2VzIjpbIi9ob21lL3A0NzIvU2NoZWR1bGVyL2xpYi9kYXRlLXV0aWxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZvcm1hdCwgcGFyc2UsIGlzVmFsaWQsIHN0YXJ0T2ZXZWVrIH0gZnJvbSAnZGF0ZS1mbnMnXG5cbi8qKlxuICogUGFyc2VzIHZhcmlvdXMgZGF0ZSBmb3JtYXRzIGludG8gYSBEYXRlIG9iamVjdFxuICogU3VwcG9ydHMgRXhjZWwgZGF0ZXMsIElTTyBzdHJpbmdzLCBhbmQgY29tbW9uIGRhdGUgZm9ybWF0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VGbGV4aWJsZURhdGUoZGF0ZVZhbHVlOiBhbnkpOiBEYXRlIHwgbnVsbCB7XG4gIGlmICghZGF0ZVZhbHVlKSByZXR1cm4gbnVsbFxuICBcbiAgLy8gQWxyZWFkeSBhIHZhbGlkIERhdGUgb2JqZWN0XG4gIGlmIChkYXRlVmFsdWUgaW5zdGFuY2VvZiBEYXRlICYmIGlzVmFsaWQoZGF0ZVZhbHVlKSkge1xuICAgIHJldHVybiBkYXRlVmFsdWVcbiAgfVxuICBcbiAgLy8gRXhjZWwgZGF0ZSBudW1iZXIgKGRheXMgc2luY2UgMTkwMC0wMS0wMSwgd2l0aCBFeGNlbCdzIGxlYXAgeWVhciBidWcpXG4gIGlmICh0eXBlb2YgZGF0ZVZhbHVlID09PSAnbnVtYmVyJyAmJiBkYXRlVmFsdWUgPiAwKSB7XG4gICAgLy8gRXhjZWwgZGF0ZXM6IG51bWJlciBvZiBkYXlzIHNpbmNlIDE5MDAtMDEtMDEgKHdpdGggbGVhcCB5ZWFyIGJ1ZyBmb3IgMTkwMClcbiAgICBjb25zdCBleGNlbEVwb2NoID0gbmV3IERhdGUoMTkwMCwgMCwgMSlcbiAgICBjb25zdCBtc1BlckRheSA9IDI0ICogNjAgKiA2MCAqIDEwMDBcbiAgICAvLyBTdWJ0cmFjdCAyIHRvIGFjY291bnQgZm9yIEV4Y2VsJ3MgbGVhcCB5ZWFyIGJ1ZyAoMTkwMCBub3QgYSBsZWFwIHllYXIpIGFuZCAwLWluZGV4aW5nXG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGV4Y2VsRXBvY2guZ2V0VGltZSgpICsgKGRhdGVWYWx1ZSAtIDIpICogbXNQZXJEYXkpXG4gICAgaWYgKGlzVmFsaWQoZGF0ZSkpIHJldHVybiBkYXRlXG4gIH1cbiAgXG4gIC8vIFN0cmluZyBkYXRlXG4gIGlmICh0eXBlb2YgZGF0ZVZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IGRhdGVTdHIgPSBkYXRlVmFsdWUudHJpbSgpXG4gICAgXG4gICAgLy8gVHJ5IHBhcnNpbmcgYXMgSVNPIGRhdGVcbiAgICBjb25zdCBpc29EYXRlID0gbmV3IERhdGUoZGF0ZVN0cilcbiAgICBpZiAoaXNWYWxpZChpc29EYXRlKSkge1xuICAgICAgcmV0dXJuIGlzb0RhdGVcbiAgICB9XG4gICAgXG4gICAgLy8gVHJ5IGNvbW1vbiBkYXRlIGZvcm1hdHNcbiAgICBjb25zdCBmb3JtYXRzID0gW1xuICAgICAgJ3l5eXktTU0tZGQnLFxuICAgICAgJ01NL2RkL3l5eXknLFxuICAgICAgJ00vZC95eXl5JyxcbiAgICAgICdkZC9NTS95eXl5JyxcbiAgICAgICdkL00veXl5eScsXG4gICAgICAnTU1NIGQgeXl5eScsXG4gICAgICAnZC1NTU0teXl5eScsXG4gICAgICAneXl5eS9NTS9kZCcsXG4gICAgICAnZGQtTU0teXl5eScsXG4gICAgICAnTU0tZGQteXl5eSdcbiAgICBdXG4gICAgXG4gICAgZm9yIChjb25zdCBmbXQgb2YgZm9ybWF0cykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2UoZGF0ZVN0ciwgZm10LCBuZXcgRGF0ZSgpKVxuICAgICAgICBpZiAoaXNWYWxpZChwYXJzZWQpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlZFxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgLy8gQ29udGludWUgdG8gbmV4dCBmb3JtYXRcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIHJldHVybiBudWxsXG59XG5cbi8qKlxuICogRm9ybWF0cyBhIGRhdGUgY29uc2lzdGVudGx5IGFzIHl5eXktTU0tZGRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZTogRGF0ZSB8IHN0cmluZyB8IG51bWJlcik6IHN0cmluZyB7XG4gIGNvbnN0IHBhcnNlZCA9IHR5cGVvZiBkYXRlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgZGF0ZSA9PT0gJ251bWJlcicgXG4gICAgPyBwYXJzZUZsZXhpYmxlRGF0ZShkYXRlKSBcbiAgICA6IGRhdGVcbiAgICBcbiAgaWYgKCFwYXJzZWQgfHwgIWlzVmFsaWQocGFyc2VkKSkge1xuICAgIHJldHVybiBmb3JtYXQobmV3IERhdGUoKSwgJ3l5eXktTU0tZGQnKVxuICB9XG4gIFxuICByZXR1cm4gZm9ybWF0KHBhcnNlZCwgJ3l5eXktTU0tZGQnKVxufVxuXG4vKipcbiAqIEdldHMgdGhlIE1vbmRheSBvZiB0aGUgd2VlayBmb3IgYSBnaXZlbiBkYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNb25kYXlPZldlZWsoZGF0ZTogRGF0ZSB8IHN0cmluZyB8IG51bWJlcik6IERhdGUge1xuICBjb25zdCBwYXJzZWQgPSB0eXBlb2YgZGF0ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGRhdGUgPT09ICdudW1iZXInXG4gICAgPyBwYXJzZUZsZXhpYmxlRGF0ZShkYXRlKVxuICAgIDogZGF0ZVxuICAgIFxuICBpZiAoIXBhcnNlZCB8fCAhaXNWYWxpZChwYXJzZWQpKSB7XG4gICAgcmV0dXJuIHN0YXJ0T2ZXZWVrKG5ldyBEYXRlKCksIHsgd2Vla1N0YXJ0c09uOiAxIH0pXG4gIH1cbiAgXG4gIHJldHVybiBzdGFydE9mV2VlayhwYXJzZWQsIHsgd2Vla1N0YXJ0c09uOiAxIH0pXG59XG5cbi8qKlxuICogR2V0cyB3ZWVrIGlkZW50aWZpZXIgaW4gZm9ybWF0IFwiWVlZWS1XV1wiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRXZWVrSWRlbnRpZmllcihkYXRlOiBEYXRlIHwgc3RyaW5nIHwgbnVtYmVyKTogc3RyaW5nIHtcbiAgY29uc3QgbW9uZGF5ID0gZ2V0TW9uZGF5T2ZXZWVrKGRhdGUpXG4gIHJldHVybiBmb3JtYXQobW9uZGF5LCBcInl5eXktJ1cnSUlcIilcbn1cblxuLyoqXG4gKiBOb3JtYWxpemVzIGEgZGF0ZSB0byBNb25kYXkgb2YgaXRzIHdlZWsgYW5kIHJldHVybnMgYm90aCBkYXRlIGFuZCB3ZWVrIHN0cmluZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZURhdGVUb1dlZWsoZGF0ZVZhbHVlOiBhbnkpOiB7IGRhdGU6IHN0cmluZzsgd2Vlazogc3RyaW5nIH0ge1xuICBjb25zdCBwYXJzZWQgPSBwYXJzZUZsZXhpYmxlRGF0ZShkYXRlVmFsdWUpXG4gIFxuICBpZiAoIXBhcnNlZCkge1xuICAgIC8vIEZhbGxiYWNrIHRvIGN1cnJlbnQgd2Vla1xuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKClcbiAgICBjb25zdCBtb25kYXkgPSBnZXRNb25kYXlPZldlZWsobm93KVxuICAgIHJldHVybiB7XG4gICAgICBkYXRlOiBmb3JtYXREYXRlKG1vbmRheSksXG4gICAgICB3ZWVrOiBnZXRXZWVrSWRlbnRpZmllcihtb25kYXkpXG4gICAgfVxuICB9XG4gIFxuICBjb25zdCBtb25kYXkgPSBnZXRNb25kYXlPZldlZWsocGFyc2VkKVxuICByZXR1cm4ge1xuICAgIGRhdGU6IGZvcm1hdERhdGUobW9uZGF5KSxcbiAgICB3ZWVrOiBnZXRXZWVrSWRlbnRpZmllcihtb25kYXkpXG4gIH1cbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBkYXRlIHN0cmluZyBpcyBpbiBhIHZhbGlkIGZvcm1hdFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZERhdGVTdHJpbmcoZGF0ZVN0cjogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGNvbnN0IHBhcnNlZCA9IHBhcnNlRmxleGlibGVEYXRlKGRhdGVTdHIpXG4gIHJldHVybiBwYXJzZWQgIT09IG51bGwgJiYgaXNWYWxpZChwYXJzZWQpXG59XG5cbi8qKlxuICogQ29tcGFyZXMgdHdvIGRhdGVzIGZvciBlcXVhbGl0eSAoaWdub3JpbmcgdGltZSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFyZVNhbWVEYXkoZGF0ZTE6IERhdGUgfCBzdHJpbmcgfCBudW1iZXIsIGRhdGUyOiBEYXRlIHwgc3RyaW5nIHwgbnVtYmVyKTogYm9vbGVhbiB7XG4gIGNvbnN0IGQxID0gcGFyc2VGbGV4aWJsZURhdGUoZGF0ZTEpXG4gIGNvbnN0IGQyID0gcGFyc2VGbGV4aWJsZURhdGUoZGF0ZTIpXG4gIFxuICBpZiAoIWQxIHx8ICFkMikgcmV0dXJuIGZhbHNlXG4gIFxuICByZXR1cm4gZm9ybWF0RGF0ZShkMSkgPT09IGZvcm1hdERhdGUoZDIpXG59XG5cbi8qKlxuICogR2V0cyB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlbiB0d28gZGF0ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRheXNCZXR3ZWVuKHN0YXJ0RGF0ZTogRGF0ZSB8IHN0cmluZyB8IG51bWJlciwgZW5kRGF0ZTogRGF0ZSB8IHN0cmluZyB8IG51bWJlcik6IG51bWJlciB7XG4gIGNvbnN0IHN0YXJ0ID0gcGFyc2VGbGV4aWJsZURhdGUoc3RhcnREYXRlKVxuICBjb25zdCBlbmQgPSBwYXJzZUZsZXhpYmxlRGF0ZShlbmREYXRlKVxuICBcbiAgaWYgKCFzdGFydCB8fCAhZW5kKSByZXR1cm4gMFxuICBcbiAgY29uc3QgbXNQZXJEYXkgPSAyNCAqIDYwICogNjAgKiAxMDAwXG4gIHJldHVybiBNYXRoLmZsb29yKChlbmQuZ2V0VGltZSgpIC0gc3RhcnQuZ2V0VGltZSgpKSAvIG1zUGVyRGF5KVxufSJdLCJuYW1lcyI6WyJmb3JtYXQiLCJwYXJzZSIsImlzVmFsaWQiLCJzdGFydE9mV2VlayIsInBhcnNlRmxleGlibGVEYXRlIiwiZGF0ZVZhbHVlIiwiRGF0ZSIsImV4Y2VsRXBvY2giLCJtc1BlckRheSIsImRhdGUiLCJnZXRUaW1lIiwiZGF0ZVN0ciIsInRyaW0iLCJpc29EYXRlIiwiZm9ybWF0cyIsImZtdCIsInBhcnNlZCIsImZvcm1hdERhdGUiLCJnZXRNb25kYXlPZldlZWsiLCJ3ZWVrU3RhcnRzT24iLCJnZXRXZWVrSWRlbnRpZmllciIsIm1vbmRheSIsIm5vcm1hbGl6ZURhdGVUb1dlZWsiLCJub3ciLCJ3ZWVrIiwiaXNWYWxpZERhdGVTdHJpbmciLCJhcmVTYW1lRGF5IiwiZGF0ZTEiLCJkYXRlMiIsImQxIiwiZDIiLCJkYXlzQmV0d2VlbiIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJzdGFydCIsImVuZCIsIk1hdGgiLCJmbG9vciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./lib/date-utils.ts\n");

/***/ }),

/***/ "(ssr)/./lib/excel/parser.ts":
/*!*****************************!*\
  !*** ./lib/excel/parser.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseExcelFile: () => (/* binding */ parseExcelFile)\n/* harmony export */ });\n/* harmony import */ var xlsx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! xlsx */ \"(ssr)/./node_modules/xlsx/xlsx.mjs\");\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/utils */ \"(ssr)/./lib/utils.ts\");\n/* harmony import */ var _lib_date_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/date-utils */ \"(ssr)/./lib/date-utils.ts\");\n/* harmony import */ var _validator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./validator */ \"(ssr)/./lib/excel/validator.ts\");\n\n\n\n\n// Wrapper function for backward compatibility\nfunction normalizeDateToMonday(dateValue) {\n    return (0,_lib_date_utils__WEBPACK_IMPORTED_MODULE_1__.normalizeDateToWeek)(dateValue);\n}\nasync function parseExcelFile(file) {\n    return new Promise((resolve, reject)=>{\n        const reader = new FileReader();\n        reader.onload = (e)=>{\n            try {\n                // Only log essential info for debugging\n                const DEBUG = false // Set to true for detailed logging\n                ;\n                if (DEBUG) {\n                    console.log('ðŸ“Š Starting Excel parsing...', {\n                        fileSize: file.size\n                    });\n                }\n                if (!e.target?.result) {\n                    throw new Error('Failed to read file content');\n                }\n                const data = new Uint8Array(e.target.result);\n                const workbook = xlsx__WEBPACK_IMPORTED_MODULE_3__.read(data, {\n                    type: 'array',\n                    cellDates: true\n                });\n                if (!workbook.Sheets || Object.keys(workbook.Sheets).length === 0) {\n                    throw new Error('No sheets found in the Excel file');\n                }\n                const result = parseWorkbook(workbook);\n                // Only log summary on success\n                console.log(`âœ… Excel parsed: ${result.employees.length} employees, ${result.projects.length} projects, ${result.assignments.length} assignments`);\n                // Validate the parsed data\n                const validation = (0,_validator__WEBPACK_IMPORTED_MODULE_2__.validateExcelData)({\n                    employees: result.employees,\n                    projects: result.projects,\n                    assignments: result.assignments\n                });\n                if (!validation.isValid) {\n                    const errorMessage = 'Excel validation failed:\\n' + validation.errors.join('\\n');\n                    throw new Error(errorMessage);\n                }\n                // Log warnings if any\n                if (validation.warnings.length > 0) {\n                    console.warn('âš ï¸ Excel validation warnings:', validation.warnings);\n                }\n                resolve(result);\n            } catch (error) {\n                console.error('âŒ Error parsing Excel:', error);\n                if (error instanceof Error) {\n                    reject(error);\n                } else {\n                    reject(new Error('Unknown error occurred while parsing Excel file'));\n                }\n            }\n        };\n        reader.onerror = (error)=>{\n            console.error('âŒ FileReader error:', error);\n            reject(new Error('Failed to read file. Please try again.'));\n        };\n        reader.readAsArrayBuffer(file);\n    });\n}\nfunction parseWorkbook(workbook) {\n    const result = {\n        employees: [],\n        projects: [],\n        assignments: [],\n        skills: [],\n        teams: [\n            'All Teams'\n        ]\n    };\n    // Parse Employees sheet\n    if (workbook.Sheets['Employees']) {\n        const sheet = xlsx__WEBPACK_IMPORTED_MODULE_3__.utils.sheet_to_json(workbook.Sheets['Employees']);\n        result.employees = sheet.map((row)=>({\n                id: row.ID || row.id || (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.generateId)(),\n                name: row.Name || row.Employee || '',\n                email: row.Email || '',\n                maxHours: Number(row['Max Hours']) || 40,\n                team: row.Team || 'Default',\n                skills: parseSkills(row)\n            }));\n    }\n    // Parse Projects sheet\n    if (workbook.Sheets['Projects']) {\n        const sheet = xlsx__WEBPACK_IMPORTED_MODULE_3__.utils.sheet_to_json(workbook.Sheets['Projects']);\n        result.projects = sheet.map((row)=>({\n                id: row.ID || row.id || (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.generateId)(),\n                name: row.Name || row.Project || '',\n                startDate: (0,_lib_date_utils__WEBPACK_IMPORTED_MODULE_1__.parseFlexibleDate)(row['Start Date']) || new Date(),\n                endDate: (0,_lib_date_utils__WEBPACK_IMPORTED_MODULE_1__.parseFlexibleDate)(row['End Date']) || new Date(),\n                requiredSkills: row['Required Skills'] ? String(row['Required Skills']).split(',').map((s)=>s.trim()) : [],\n                portfolio: row.Portfolio || ''\n            }));\n    }\n    // Parse Assignments sheet\n    if (workbook.Sheets['Assignments']) {\n        const sheet = xlsx__WEBPACK_IMPORTED_MODULE_3__.utils.sheet_to_json(workbook.Sheets['Assignments']);\n        // Check if this is pivot-style format (columns are dates)\n        const firstRow = sheet[0] || {};\n        const columns = Object.keys(firstRow);\n        const dateColumns = columns.filter((col)=>{\n            // Check if column name looks like a date\n            return /^\\d{4}-\\d{2}-\\d{2}/.test(col) || /^\\d{1,2}\\/\\d{1,2}\\/\\d{4}/.test(col) || /^[A-Z][a-z]{2}\\s+\\d{1,2}/.test(col);\n        });\n        if (dateColumns.length > 0) {\n            // Pivot format: Each row is employee-project, columns are week dates\n            result.assignments = [];\n            sheet.forEach((row, rowIndex)=>{\n                const employeeIdOrName = row.Employee || row['Employee'] || row['Employee ID'] || '';\n                const projectIdOrName = row.Project || row['Project'] || row['Project ID'] || '';\n                if (!employeeIdOrName || !projectIdOrName) {\n                    // Skip invalid rows silently\n                    return;\n                }\n                // Try to find employee by ID first, then by name\n                let employeeId = employeeIdOrName;\n                const employeeById = result.employees.find((e)=>e.id === employeeIdOrName);\n                const employeeByName = result.employees.find((e)=>e.name === employeeIdOrName);\n                if (!employeeById && employeeByName) {\n                    employeeId = employeeByName.id;\n                }\n                // Try to find project by ID first, then by name\n                let projectId = projectIdOrName;\n                const projectById = result.projects.find((p)=>p.id === projectIdOrName);\n                const projectByName = result.projects.find((p)=>p.name === projectIdOrName);\n                if (!projectById && projectByName) {\n                    projectId = projectByName.id;\n                }\n                // Process each date column\n                dateColumns.forEach((dateCol)=>{\n                    const hours = row[dateCol];\n                    if (hours && Number(hours) > 0) {\n                        const { date, week } = normalizeDateToMonday(dateCol);\n                        const assignment = {\n                            id: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.generateId)(),\n                            employeeId: employeeId,\n                            projectId: projectId,\n                            hours: Number(hours),\n                            week: week,\n                            date: date\n                        };\n                        result.assignments.push(assignment);\n                    }\n                });\n            });\n        } else {\n            // Traditional format: Each row is one assignment\n            result.assignments = sheet.map((row, index)=>{\n                // Check all possible column names for week/date\n                const rawDate = row.Week || row['Week'] || row.Date || row['Date'] || row.week || row.date;\n                const { date, week } = normalizeDateToMonday(rawDate);\n                // Parse hours with better handling\n                const rawHours = row.Hours || row['Hours'] || row.hours || 0;\n                const parsedHours = typeof rawHours === 'string' ? parseFloat(rawHours) || 0 : Number(rawHours) || 0;\n                const employeeIdOrName = row['Employee ID'] || row.Employee || row['Employee'] || row['employee'] || '';\n                const projectIdOrName = row['Project ID'] || row.Project || row['Project'] || row['project'] || '';\n                // Try to find employee by ID first, then by name\n                let employeeId = employeeIdOrName;\n                const employeeById = result.employees.find((e)=>e.id === employeeIdOrName);\n                const employeeByName = result.employees.find((e)=>e.name === employeeIdOrName);\n                if (!employeeById && employeeByName) {\n                    employeeId = employeeByName.id;\n                }\n                // Try to find project by ID first, then by name\n                let projectId = projectIdOrName;\n                const projectById = result.projects.find((p)=>p.id === projectIdOrName);\n                const projectByName = result.projects.find((p)=>p.name === projectIdOrName);\n                if (!projectById && projectByName) {\n                    projectId = projectByName.id;\n                }\n                const assignment = {\n                    id: (0,_lib_utils__WEBPACK_IMPORTED_MODULE_0__.generateId)(),\n                    employeeId: employeeId,\n                    projectId: projectId,\n                    hours: parsedHours,\n                    week: week,\n                    date: date // New: Store full date in yyyy-MM-dd format\n                };\n                // Assignment created\n                return assignment;\n            });\n        }\n    } else {\n    // No assignments sheet found\n    }\n    // Parse Skills sheet (optional)\n    if (workbook.Sheets['Skills']) {\n        const sheet = xlsx__WEBPACK_IMPORTED_MODULE_3__.utils.sheet_to_json(workbook.Sheets['Skills']);\n        const skillSet = new Set();\n        sheet.forEach((row)=>{\n            Object.keys(row).forEach((key)=>{\n                if (key !== 'Employee' && key !== 'ID' && key !== 'Name') {\n                    skillSet.add(key);\n                }\n            });\n        });\n        result.skills = Array.from(skillSet);\n    } else {\n        // Extract skills from employees\n        const skillSet = new Set();\n        result.employees.forEach((emp)=>{\n            Object.keys(emp.skills).forEach((skill)=>skillSet.add(skill));\n        });\n        result.skills = Array.from(skillSet);\n    }\n    // Extract teams\n    const teamSet = new Set([\n        'All Teams'\n    ]);\n    result.employees.forEach((emp)=>{\n        if (emp.team) teamSet.add(emp.team);\n    });\n    result.teams = Array.from(teamSet);\n    return result;\n}\nfunction parseSkills(row) {\n    const skills = {};\n    const excludeFields = [\n        'Name',\n        'Employee',\n        'Email',\n        'ID',\n        'id',\n        'Max Hours',\n        'Team'\n    ];\n    Object.keys(row).forEach((key)=>{\n        if (!excludeFields.includes(key)) {\n            const value = row[key];\n            if (value && value !== 'None' && value !== '') {\n                // Try to parse as proficiency level\n                if ([\n                    'Beginner',\n                    'Intermediate',\n                    'Expert'\n                ].includes(value)) {\n                    skills[key] = value;\n                } else if (typeof value === 'number') {\n                    // Convert numeric values to proficiency levels\n                    if (value >= 3) skills[key] = 'Expert';\n                    else if (value >= 2) skills[key] = 'Intermediate';\n                    else if (value >= 1) skills[key] = 'Beginner';\n                } else if (value) {\n                    // Default to Intermediate for any other non-empty value\n                    skills[key] = 'Intermediate';\n                }\n            }\n        }\n    });\n    return skills;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUk7SUFDcEM7SUFDQTFDLE9BQU8yQixLQUFLLEdBQUdnRSxNQUFNQyxJQUFJLENBQUNHO0lBRTFCLE9BQU8vRjtBQUNUO0FBRUEsU0FBUzRDLFlBQVlaLEdBQVE7SUFDM0IsTUFBTU4sU0FBMkMsQ0FBQztJQUNsRCxNQUFNc0UsZ0JBQWdCO1FBQUM7UUFBUTtRQUFZO1FBQVM7UUFBTTtRQUFNO1FBQWE7S0FBTztJQUVwRnZGLE9BQU9DLElBQUksQ0FBQ3NCLEtBQUs4QixPQUFPLENBQUMyQixDQUFBQTtRQUN2QixJQUFJLENBQUNPLGNBQWNDLFFBQVEsQ0FBQ1IsTUFBTTtZQUNoQyxNQUFNUyxRQUFRbEUsR0FBRyxDQUFDeUQsSUFBSTtZQUN0QixJQUFJUyxTQUFTQSxVQUFVLFVBQVVBLFVBQVUsSUFBSTtnQkFDN0Msb0NBQW9DO2dCQUNwQyxJQUFJO29CQUFDO29CQUFZO29CQUFnQjtpQkFBUyxDQUFDRCxRQUFRLENBQUNDLFFBQVE7b0JBQzFEeEUsTUFBTSxDQUFDK0QsSUFBSSxHQUFHUztnQkFDaEIsT0FBTyxJQUFJLE9BQU9BLFVBQVUsVUFBVTtvQkFDcEMsK0NBQStDO29CQUMvQyxJQUFJQSxTQUFTLEdBQUd4RSxNQUFNLENBQUMrRCxJQUFJLEdBQUc7eUJBQ3pCLElBQUlTLFNBQVMsR0FBR3hFLE1BQU0sQ0FBQytELElBQUksR0FBRzt5QkFDOUIsSUFBSVMsU0FBUyxHQUFHeEUsTUFBTSxDQUFDK0QsSUFBSSxHQUFHO2dCQUNyQyxPQUFPLElBQUlTLE9BQU87b0JBQ2hCLHdEQUF3RDtvQkFDeER4RSxNQUFNLENBQUMrRCxJQUFJLEdBQUc7Z0JBQ2hCO1lBQ0Y7UUFDRjtJQUNGO0lBRUEsT0FBTy9EO0FBQ1QiLCJzb3VyY2VzIjpbIi9ob21lL3A0NzIvU2NoZWR1bGVyL2xpYi9leGNlbC9wYXJzZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgWExTWCBmcm9tICd4bHN4J1xuaW1wb3J0IHsgU2NoZWR1bGVEYXRhLCBBc3NpZ25tZW50LCBQcm9maWNpZW5jeUxldmVsIH0gZnJvbSAnQC90eXBlcy9zY2hlZHVsZSdcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tICdAL2xpYi91dGlscydcbmltcG9ydCB7IG5vcm1hbGl6ZURhdGVUb1dlZWssIHBhcnNlRmxleGlibGVEYXRlIH0gZnJvbSAnQC9saWIvZGF0ZS11dGlscydcbmltcG9ydCB7IHZhbGlkYXRlRXhjZWxEYXRhIH0gZnJvbSAnLi92YWxpZGF0b3InXG5cbi8vIFdyYXBwZXIgZnVuY3Rpb24gZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbmZ1bmN0aW9uIG5vcm1hbGl6ZURhdGVUb01vbmRheShkYXRlVmFsdWU6IGFueSk6IHsgZGF0ZTogc3RyaW5nLCB3ZWVrOiBzdHJpbmcgfSB7XG4gIHJldHVybiBub3JtYWxpemVEYXRlVG9XZWVrKGRhdGVWYWx1ZSlcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBhcnNlRXhjZWxGaWxlKGZpbGU6IEZpbGUpOiBQcm9taXNlPFNjaGVkdWxlRGF0YT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICBcbiAgICByZWFkZXIub25sb2FkID0gKGUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIE9ubHkgbG9nIGVzc2VudGlhbCBpbmZvIGZvciBkZWJ1Z2dpbmdcbiAgICAgICAgY29uc3QgREVCVUcgPSBmYWxzZSAvLyBTZXQgdG8gdHJ1ZSBmb3IgZGV0YWlsZWQgbG9nZ2luZ1xuICAgICAgICBpZiAoREVCVUcpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+TiiBTdGFydGluZyBFeGNlbCBwYXJzaW5nLi4uJywgeyBmaWxlU2l6ZTogZmlsZS5zaXplIH0pXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICghZS50YXJnZXQ/LnJlc3VsdCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHJlYWQgZmlsZSBjb250ZW50JylcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KGUudGFyZ2V0LnJlc3VsdCBhcyBBcnJheUJ1ZmZlcilcbiAgICAgICAgY29uc3Qgd29ya2Jvb2sgPSBYTFNYLnJlYWQoZGF0YSwgeyB0eXBlOiAnYXJyYXknLCBjZWxsRGF0ZXM6IHRydWUgfSlcbiAgICAgICAgXG4gICAgICAgIGlmICghd29ya2Jvb2suU2hlZXRzIHx8IE9iamVjdC5rZXlzKHdvcmtib29rLlNoZWV0cykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzaGVldHMgZm91bmQgaW4gdGhlIEV4Y2VsIGZpbGUnKVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCByZXN1bHQgPSBwYXJzZVdvcmtib29rKHdvcmtib29rKVxuICAgICAgICAvLyBPbmx5IGxvZyBzdW1tYXJ5IG9uIHN1Y2Nlc3NcbiAgICAgICAgY29uc29sZS5sb2coYOKchSBFeGNlbCBwYXJzZWQ6ICR7cmVzdWx0LmVtcGxveWVlcy5sZW5ndGh9IGVtcGxveWVlcywgJHtyZXN1bHQucHJvamVjdHMubGVuZ3RofSBwcm9qZWN0cywgJHtyZXN1bHQuYXNzaWdubWVudHMubGVuZ3RofSBhc3NpZ25tZW50c2ApXG4gICAgICAgIFxuICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgcGFyc2VkIGRhdGFcbiAgICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IHZhbGlkYXRlRXhjZWxEYXRhKHtcbiAgICAgICAgICBlbXBsb3llZXM6IHJlc3VsdC5lbXBsb3llZXMsXG4gICAgICAgICAgcHJvamVjdHM6IHJlc3VsdC5wcm9qZWN0cyxcbiAgICAgICAgICBhc3NpZ25tZW50czogcmVzdWx0LmFzc2lnbm1lbnRzXG4gICAgICAgIH0pXG4gICAgICAgIFxuICAgICAgICBpZiAoIXZhbGlkYXRpb24uaXNWYWxpZCkge1xuICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9ICdFeGNlbCB2YWxpZGF0aW9uIGZhaWxlZDpcXG4nICsgdmFsaWRhdGlvbi5lcnJvcnMuam9pbignXFxuJylcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBMb2cgd2FybmluZ3MgaWYgYW55XG4gICAgICAgIGlmICh2YWxpZGF0aW9uLndhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBFeGNlbCB2YWxpZGF0aW9uIHdhcm5pbmdzOicsIHZhbGlkYXRpb24ud2FybmluZ3MpXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJlc29sdmUocmVzdWx0KVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIHBhcnNpbmcgRXhjZWw6JywgZXJyb3IpXG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1Vua25vd24gZXJyb3Igb2NjdXJyZWQgd2hpbGUgcGFyc2luZyBFeGNlbCBmaWxlJykpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmVhZGVyLm9uZXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGaWxlUmVhZGVyIGVycm9yOicsIGVycm9yKVxuICAgICAgcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIHJlYWQgZmlsZS4gUGxlYXNlIHRyeSBhZ2Fpbi4nKSlcbiAgICB9XG4gICAgXG4gICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGZpbGUpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHBhcnNlV29ya2Jvb2sod29ya2Jvb2s6IFhMU1guV29ya0Jvb2spOiBTY2hlZHVsZURhdGEge1xuICBjb25zdCByZXN1bHQ6IFNjaGVkdWxlRGF0YSA9IHtcbiAgICBlbXBsb3llZXM6IFtdLFxuICAgIHByb2plY3RzOiBbXSxcbiAgICBhc3NpZ25tZW50czogW10sXG4gICAgc2tpbGxzOiBbXSxcbiAgICB0ZWFtczogWydBbGwgVGVhbXMnXSxcbiAgfVxuXG4gIC8vIFBhcnNlIEVtcGxveWVlcyBzaGVldFxuICBpZiAod29ya2Jvb2suU2hlZXRzWydFbXBsb3llZXMnXSkge1xuICAgIGNvbnN0IHNoZWV0ID0gWExTWC51dGlscy5zaGVldF90b19qc29uKHdvcmtib29rLlNoZWV0c1snRW1wbG95ZWVzJ10pXG4gICAgcmVzdWx0LmVtcGxveWVlcyA9IHNoZWV0Lm1hcCgocm93OiBhbnkpID0+ICh7XG4gICAgICBpZDogcm93LklEIHx8IHJvdy5pZCB8fCBnZW5lcmF0ZUlkKCksXG4gICAgICBuYW1lOiByb3cuTmFtZSB8fCByb3cuRW1wbG95ZWUgfHwgJycsXG4gICAgICBlbWFpbDogcm93LkVtYWlsIHx8ICcnLFxuICAgICAgbWF4SG91cnM6IE51bWJlcihyb3dbJ01heCBIb3VycyddKSB8fCA0MCxcbiAgICAgIHRlYW06IHJvdy5UZWFtIHx8ICdEZWZhdWx0JyxcbiAgICAgIHNraWxsczogcGFyc2VTa2lsbHMocm93KSxcbiAgICB9KSlcbiAgfVxuXG4gIC8vIFBhcnNlIFByb2plY3RzIHNoZWV0XG4gIGlmICh3b3JrYm9vay5TaGVldHNbJ1Byb2plY3RzJ10pIHtcbiAgICBjb25zdCBzaGVldCA9IFhMU1gudXRpbHMuc2hlZXRfdG9fanNvbih3b3JrYm9vay5TaGVldHNbJ1Byb2plY3RzJ10pXG4gICAgcmVzdWx0LnByb2plY3RzID0gc2hlZXQubWFwKChyb3c6IGFueSkgPT4gKHtcbiAgICAgIGlkOiByb3cuSUQgfHwgcm93LmlkIHx8IGdlbmVyYXRlSWQoKSxcbiAgICAgIG5hbWU6IHJvdy5OYW1lIHx8IHJvdy5Qcm9qZWN0IHx8ICcnLFxuICAgICAgc3RhcnREYXRlOiBwYXJzZUZsZXhpYmxlRGF0ZShyb3dbJ1N0YXJ0IERhdGUnXSkgfHwgbmV3IERhdGUoKSxcbiAgICAgIGVuZERhdGU6IHBhcnNlRmxleGlibGVEYXRlKHJvd1snRW5kIERhdGUnXSkgfHwgbmV3IERhdGUoKSxcbiAgICAgIHJlcXVpcmVkU2tpbGxzOiByb3dbJ1JlcXVpcmVkIFNraWxscyddIFxuICAgICAgICA/IFN0cmluZyhyb3dbJ1JlcXVpcmVkIFNraWxscyddKS5zcGxpdCgnLCcpLm1hcChzID0+IHMudHJpbSgpKVxuICAgICAgICA6IFtdLFxuICAgICAgcG9ydGZvbGlvOiByb3cuUG9ydGZvbGlvIHx8ICcnLFxuICAgIH0pKVxuICB9XG5cbiAgLy8gUGFyc2UgQXNzaWdubWVudHMgc2hlZXRcbiAgaWYgKHdvcmtib29rLlNoZWV0c1snQXNzaWdubWVudHMnXSkge1xuICAgIGNvbnN0IHNoZWV0ID0gWExTWC51dGlscy5zaGVldF90b19qc29uKHdvcmtib29rLlNoZWV0c1snQXNzaWdubWVudHMnXSlcbiAgICBcbiAgICAvLyBDaGVjayBpZiB0aGlzIGlzIHBpdm90LXN0eWxlIGZvcm1hdCAoY29sdW1ucyBhcmUgZGF0ZXMpXG4gICAgY29uc3QgZmlyc3RSb3cgPSBzaGVldFswXSB8fCB7fVxuICAgIGNvbnN0IGNvbHVtbnMgPSBPYmplY3Qua2V5cyhmaXJzdFJvdylcbiAgICBjb25zdCBkYXRlQ29sdW1ucyA9IGNvbHVtbnMuZmlsdGVyKGNvbCA9PiB7XG4gICAgICAvLyBDaGVjayBpZiBjb2x1bW4gbmFtZSBsb29rcyBsaWtlIGEgZGF0ZVxuICAgICAgcmV0dXJuIC9eXFxkezR9LVxcZHsyfS1cXGR7Mn0vLnRlc3QoY29sKSB8fCBcbiAgICAgICAgICAgICAvXlxcZHsxLDJ9XFwvXFxkezEsMn1cXC9cXGR7NH0vLnRlc3QoY29sKSB8fFxuICAgICAgICAgICAgIC9eW0EtWl1bYS16XXsyfVxccytcXGR7MSwyfS8udGVzdChjb2wpXG4gICAgfSlcbiAgICBcbiAgICBpZiAoZGF0ZUNvbHVtbnMubGVuZ3RoID4gMCkge1xuICAgICAgLy8gUGl2b3QgZm9ybWF0OiBFYWNoIHJvdyBpcyBlbXBsb3llZS1wcm9qZWN0LCBjb2x1bW5zIGFyZSB3ZWVrIGRhdGVzXG4gICAgICByZXN1bHQuYXNzaWdubWVudHMgPSBbXVxuICAgICAgXG4gICAgICBzaGVldC5mb3JFYWNoKChyb3c6IGFueSwgcm93SW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICBjb25zdCBlbXBsb3llZUlkT3JOYW1lID0gcm93LkVtcGxveWVlIHx8IHJvd1snRW1wbG95ZWUnXSB8fCByb3dbJ0VtcGxveWVlIElEJ10gfHwgJydcbiAgICAgICAgY29uc3QgcHJvamVjdElkT3JOYW1lID0gcm93LlByb2plY3QgfHwgcm93WydQcm9qZWN0J10gfHwgcm93WydQcm9qZWN0IElEJ10gfHwgJydcbiAgICAgICAgXG4gICAgICAgIGlmICghZW1wbG95ZWVJZE9yTmFtZSB8fCAhcHJvamVjdElkT3JOYW1lKSB7XG4gICAgICAgICAgLy8gU2tpcCBpbnZhbGlkIHJvd3Mgc2lsZW50bHlcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVHJ5IHRvIGZpbmQgZW1wbG95ZWUgYnkgSUQgZmlyc3QsIHRoZW4gYnkgbmFtZVxuICAgICAgICBsZXQgZW1wbG95ZWVJZCA9IGVtcGxveWVlSWRPck5hbWVcbiAgICAgICAgY29uc3QgZW1wbG95ZWVCeUlkID0gcmVzdWx0LmVtcGxveWVlcy5maW5kKGUgPT4gZS5pZCA9PT0gZW1wbG95ZWVJZE9yTmFtZSlcbiAgICAgICAgY29uc3QgZW1wbG95ZWVCeU5hbWUgPSByZXN1bHQuZW1wbG95ZWVzLmZpbmQoZSA9PiBlLm5hbWUgPT09IGVtcGxveWVlSWRPck5hbWUpXG4gICAgICAgIFxuICAgICAgICBpZiAoIWVtcGxveWVlQnlJZCAmJiBlbXBsb3llZUJ5TmFtZSkge1xuICAgICAgICAgIGVtcGxveWVlSWQgPSBlbXBsb3llZUJ5TmFtZS5pZFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBUcnkgdG8gZmluZCBwcm9qZWN0IGJ5IElEIGZpcnN0LCB0aGVuIGJ5IG5hbWVcbiAgICAgICAgbGV0IHByb2plY3RJZCA9IHByb2plY3RJZE9yTmFtZVxuICAgICAgICBjb25zdCBwcm9qZWN0QnlJZCA9IHJlc3VsdC5wcm9qZWN0cy5maW5kKHAgPT4gcC5pZCA9PT0gcHJvamVjdElkT3JOYW1lKVxuICAgICAgICBjb25zdCBwcm9qZWN0QnlOYW1lID0gcmVzdWx0LnByb2plY3RzLmZpbmQocCA9PiBwLm5hbWUgPT09IHByb2plY3RJZE9yTmFtZSlcbiAgICAgICAgXG4gICAgICAgIGlmICghcHJvamVjdEJ5SWQgJiYgcHJvamVjdEJ5TmFtZSkge1xuICAgICAgICAgIHByb2plY3RJZCA9IHByb2plY3RCeU5hbWUuaWRcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gUHJvY2VzcyBlYWNoIGRhdGUgY29sdW1uXG4gICAgICAgIGRhdGVDb2x1bW5zLmZvckVhY2goZGF0ZUNvbCA9PiB7XG4gICAgICAgICAgY29uc3QgaG91cnMgPSByb3dbZGF0ZUNvbF1cbiAgICAgICAgICBpZiAoaG91cnMgJiYgTnVtYmVyKGhvdXJzKSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0ZSwgd2VlayB9ID0gbm9ybWFsaXplRGF0ZVRvTW9uZGF5KGRhdGVDb2wpXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGFzc2lnbm1lbnQ6IEFzc2lnbm1lbnQgPSB7XG4gICAgICAgICAgICAgIGlkOiBnZW5lcmF0ZUlkKCksXG4gICAgICAgICAgICAgIGVtcGxveWVlSWQ6IGVtcGxveWVlSWQsXG4gICAgICAgICAgICAgIHByb2plY3RJZDogcHJvamVjdElkLFxuICAgICAgICAgICAgICBob3VyczogTnVtYmVyKGhvdXJzKSxcbiAgICAgICAgICAgICAgd2Vlazogd2VlayxcbiAgICAgICAgICAgICAgZGF0ZTogZGF0ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXN1bHQuYXNzaWdubWVudHMucHVzaChhc3NpZ25tZW50KVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRyYWRpdGlvbmFsIGZvcm1hdDogRWFjaCByb3cgaXMgb25lIGFzc2lnbm1lbnRcbiAgICAgIHJlc3VsdC5hc3NpZ25tZW50cyA9IHNoZWV0Lm1hcCgocm93OiBhbnksIGluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgICAgLy8gQ2hlY2sgYWxsIHBvc3NpYmxlIGNvbHVtbiBuYW1lcyBmb3Igd2Vlay9kYXRlXG4gICAgICAgIGNvbnN0IHJhd0RhdGUgPSByb3cuV2VlayB8fCByb3dbJ1dlZWsnXSB8fCByb3cuRGF0ZSB8fCByb3dbJ0RhdGUnXSB8fCByb3cud2VlayB8fCByb3cuZGF0ZVxuICAgICAgICBjb25zdCB7IGRhdGUsIHdlZWsgfSA9IG5vcm1hbGl6ZURhdGVUb01vbmRheShyYXdEYXRlKVxuICAgICAgICBcbiAgICAgICAgLy8gUGFyc2UgaG91cnMgd2l0aCBiZXR0ZXIgaGFuZGxpbmdcbiAgICAgICAgY29uc3QgcmF3SG91cnMgPSByb3cuSG91cnMgfHwgcm93WydIb3VycyddIHx8IHJvdy5ob3VycyB8fCAwXG4gICAgICAgIGNvbnN0IHBhcnNlZEhvdXJzID0gdHlwZW9mIHJhd0hvdXJzID09PSAnc3RyaW5nJyA/IHBhcnNlRmxvYXQocmF3SG91cnMpIHx8IDAgOiBOdW1iZXIocmF3SG91cnMpIHx8IDBcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGVtcGxveWVlSWRPck5hbWUgPSByb3dbJ0VtcGxveWVlIElEJ10gfHwgcm93LkVtcGxveWVlIHx8IHJvd1snRW1wbG95ZWUnXSB8fCByb3dbJ2VtcGxveWVlJ10gfHwgJydcbiAgICAgICAgY29uc3QgcHJvamVjdElkT3JOYW1lID0gcm93WydQcm9qZWN0IElEJ10gfHwgcm93LlByb2plY3QgfHwgcm93WydQcm9qZWN0J10gfHwgcm93Wydwcm9qZWN0J10gfHwgJydcbiAgICAgICAgXG4gICAgICAgIC8vIFRyeSB0byBmaW5kIGVtcGxveWVlIGJ5IElEIGZpcnN0LCB0aGVuIGJ5IG5hbWVcbiAgICAgICAgbGV0IGVtcGxveWVlSWQgPSBlbXBsb3llZUlkT3JOYW1lXG4gICAgICAgIGNvbnN0IGVtcGxveWVlQnlJZCA9IHJlc3VsdC5lbXBsb3llZXMuZmluZChlID0+IGUuaWQgPT09IGVtcGxveWVlSWRPck5hbWUpXG4gICAgICAgIGNvbnN0IGVtcGxveWVlQnlOYW1lID0gcmVzdWx0LmVtcGxveWVlcy5maW5kKGUgPT4gZS5uYW1lID09PSBlbXBsb3llZUlkT3JOYW1lKVxuICAgICAgICBcbiAgICAgICAgaWYgKCFlbXBsb3llZUJ5SWQgJiYgZW1wbG95ZWVCeU5hbWUpIHtcbiAgICAgICAgICBlbXBsb3llZUlkID0gZW1wbG95ZWVCeU5hbWUuaWRcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVHJ5IHRvIGZpbmQgcHJvamVjdCBieSBJRCBmaXJzdCwgdGhlbiBieSBuYW1lXG4gICAgICAgIGxldCBwcm9qZWN0SWQgPSBwcm9qZWN0SWRPck5hbWVcbiAgICAgICAgY29uc3QgcHJvamVjdEJ5SWQgPSByZXN1bHQucHJvamVjdHMuZmluZChwID0+IHAuaWQgPT09IHByb2plY3RJZE9yTmFtZSlcbiAgICAgICAgY29uc3QgcHJvamVjdEJ5TmFtZSA9IHJlc3VsdC5wcm9qZWN0cy5maW5kKHAgPT4gcC5uYW1lID09PSBwcm9qZWN0SWRPck5hbWUpXG4gICAgICAgIFxuICAgICAgICBpZiAoIXByb2plY3RCeUlkICYmIHByb2plY3RCeU5hbWUpIHtcbiAgICAgICAgICBwcm9qZWN0SWQgPSBwcm9qZWN0QnlOYW1lLmlkXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGFzc2lnbm1lbnQ6IEFzc2lnbm1lbnQgPSB7XG4gICAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgICBlbXBsb3llZUlkOiBlbXBsb3llZUlkLFxuICAgICAgICAgIHByb2plY3RJZDogcHJvamVjdElkLFxuICAgICAgICAgIGhvdXJzOiBwYXJzZWRIb3VycyxcbiAgICAgICAgICB3ZWVrOiB3ZWVrLCAgLy8gS2VlcCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICBkYXRlOiBkYXRlICAgLy8gTmV3OiBTdG9yZSBmdWxsIGRhdGUgaW4geXl5eS1NTS1kZCBmb3JtYXRcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQXNzaWdubWVudCBjcmVhdGVkXG4gICAgICAgIFxuICAgICAgICByZXR1cm4gYXNzaWdubWVudFxuICAgICAgfSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gTm8gYXNzaWdubWVudHMgc2hlZXQgZm91bmRcbiAgfVxuXG4gIC8vIFBhcnNlIFNraWxscyBzaGVldCAob3B0aW9uYWwpXG4gIGlmICh3b3JrYm9vay5TaGVldHNbJ1NraWxscyddKSB7XG4gICAgY29uc3Qgc2hlZXQgPSBYTFNYLnV0aWxzLnNoZWV0X3RvX2pzb24od29ya2Jvb2suU2hlZXRzWydTa2lsbHMnXSlcbiAgICBjb25zdCBza2lsbFNldCA9IG5ldyBTZXQ8c3RyaW5nPigpXG4gICAgXG4gICAgc2hlZXQuZm9yRWFjaCgocm93OiBhbnkpID0+IHtcbiAgICAgIE9iamVjdC5rZXlzKHJvdykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBpZiAoa2V5ICE9PSAnRW1wbG95ZWUnICYmIGtleSAhPT0gJ0lEJyAmJiBrZXkgIT09ICdOYW1lJykge1xuICAgICAgICAgIHNraWxsU2V0LmFkZChrZXkpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgICBcbiAgICByZXN1bHQuc2tpbGxzID0gQXJyYXkuZnJvbShza2lsbFNldClcbiAgfSBlbHNlIHtcbiAgICAvLyBFeHRyYWN0IHNraWxscyBmcm9tIGVtcGxveWVlc1xuICAgIGNvbnN0IHNraWxsU2V0ID0gbmV3IFNldDxzdHJpbmc+KClcbiAgICByZXN1bHQuZW1wbG95ZWVzLmZvckVhY2goZW1wID0+IHtcbiAgICAgIE9iamVjdC5rZXlzKGVtcC5za2lsbHMpLmZvckVhY2goc2tpbGwgPT4gc2tpbGxTZXQuYWRkKHNraWxsKSlcbiAgICB9KVxuICAgIHJlc3VsdC5za2lsbHMgPSBBcnJheS5mcm9tKHNraWxsU2V0KVxuICB9XG5cbiAgLy8gRXh0cmFjdCB0ZWFtc1xuICBjb25zdCB0ZWFtU2V0ID0gbmV3IFNldChbJ0FsbCBUZWFtcyddKVxuICByZXN1bHQuZW1wbG95ZWVzLmZvckVhY2goZW1wID0+IHtcbiAgICBpZiAoZW1wLnRlYW0pIHRlYW1TZXQuYWRkKGVtcC50ZWFtKVxuICB9KVxuICByZXN1bHQudGVhbXMgPSBBcnJheS5mcm9tKHRlYW1TZXQpXG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBwYXJzZVNraWxscyhyb3c6IGFueSk6IFJlY29yZDxzdHJpbmcsIFByb2ZpY2llbmN5TGV2ZWw+IHtcbiAgY29uc3Qgc2tpbGxzOiBSZWNvcmQ8c3RyaW5nLCBQcm9maWNpZW5jeUxldmVsPiA9IHt9XG4gIGNvbnN0IGV4Y2x1ZGVGaWVsZHMgPSBbJ05hbWUnLCAnRW1wbG95ZWUnLCAnRW1haWwnLCAnSUQnLCAnaWQnLCAnTWF4IEhvdXJzJywgJ1RlYW0nXVxuICBcbiAgT2JqZWN0LmtleXMocm93KS5mb3JFYWNoKGtleSA9PiB7XG4gICAgaWYgKCFleGNsdWRlRmllbGRzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gcm93W2tleV1cbiAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZSAhPT0gJ05vbmUnICYmIHZhbHVlICE9PSAnJykge1xuICAgICAgICAvLyBUcnkgdG8gcGFyc2UgYXMgcHJvZmljaWVuY3kgbGV2ZWxcbiAgICAgICAgaWYgKFsnQmVnaW5uZXInLCAnSW50ZXJtZWRpYXRlJywgJ0V4cGVydCddLmluY2x1ZGVzKHZhbHVlKSkge1xuICAgICAgICAgIHNraWxsc1trZXldID0gdmFsdWUgYXMgUHJvZmljaWVuY3lMZXZlbFxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAvLyBDb252ZXJ0IG51bWVyaWMgdmFsdWVzIHRvIHByb2ZpY2llbmN5IGxldmVsc1xuICAgICAgICAgIGlmICh2YWx1ZSA+PSAzKSBza2lsbHNba2V5XSA9ICdFeHBlcnQnXG4gICAgICAgICAgZWxzZSBpZiAodmFsdWUgPj0gMikgc2tpbGxzW2tleV0gPSAnSW50ZXJtZWRpYXRlJ1xuICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID49IDEpIHNraWxsc1trZXldID0gJ0JlZ2lubmVyJ1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgLy8gRGVmYXVsdCB0byBJbnRlcm1lZGlhdGUgZm9yIGFueSBvdGhlciBub24tZW1wdHkgdmFsdWVcbiAgICAgICAgICBza2lsbHNba2V5XSA9ICdJbnRlcm1lZGlhdGUnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIFxuICByZXR1cm4gc2tpbGxzXG59Il0sIm5hbWVzIjpbIlhMU1giLCJnZW5lcmF0ZUlkIiwibm9ybWFsaXplRGF0ZVRvV2VlayIsInBhcnNlRmxleGlibGVEYXRlIiwidmFsaWRhdGVFeGNlbERhdGEiLCJub3JtYWxpemVEYXRlVG9Nb25kYXkiLCJkYXRlVmFsdWUiLCJwYXJzZUV4Y2VsRmlsZSIsImZpbGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInJlYWRlciIsIkZpbGVSZWFkZXIiLCJvbmxvYWQiLCJlIiwiREVCVUciLCJjb25zb2xlIiwibG9nIiwiZmlsZVNpemUiLCJzaXplIiwidGFyZ2V0IiwicmVzdWx0IiwiRXJyb3IiLCJkYXRhIiwiVWludDhBcnJheSIsIndvcmtib29rIiwicmVhZCIsInR5cGUiLCJjZWxsRGF0ZXMiLCJTaGVldHMiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwicGFyc2VXb3JrYm9vayIsImVtcGxveWVlcyIsInByb2plY3RzIiwiYXNzaWdubWVudHMiLCJ2YWxpZGF0aW9uIiwiaXNWYWxpZCIsImVycm9yTWVzc2FnZSIsImVycm9ycyIsImpvaW4iLCJ3YXJuaW5ncyIsIndhcm4iLCJlcnJvciIsIm9uZXJyb3IiLCJyZWFkQXNBcnJheUJ1ZmZlciIsInNraWxscyIsInRlYW1zIiwic2hlZXQiLCJ1dGlscyIsInNoZWV0X3RvX2pzb24iLCJtYXAiLCJyb3ciLCJpZCIsIklEIiwibmFtZSIsIk5hbWUiLCJFbXBsb3llZSIsImVtYWlsIiwiRW1haWwiLCJtYXhIb3VycyIsIk51bWJlciIsInRlYW0iLCJUZWFtIiwicGFyc2VTa2lsbHMiLCJQcm9qZWN0Iiwic3RhcnREYXRlIiwiRGF0ZSIsImVuZERhdGUiLCJyZXF1aXJlZFNraWxscyIsIlN0cmluZyIsInNwbGl0IiwicyIsInRyaW0iLCJwb3J0Zm9saW8iLCJQb3J0Zm9saW8iLCJmaXJzdFJvdyIsImNvbHVtbnMiLCJkYXRlQ29sdW1ucyIsImZpbHRlciIsImNvbCIsInRlc3QiLCJmb3JFYWNoIiwicm93SW5kZXgiLCJlbXBsb3llZUlkT3JOYW1lIiwicHJvamVjdElkT3JOYW1lIiwiZW1wbG95ZWVJZCIsImVtcGxveWVlQnlJZCIsImZpbmQiLCJlbXBsb3llZUJ5TmFtZSIsInByb2plY3RJZCIsInByb2plY3RCeUlkIiwicCIsInByb2plY3RCeU5hbWUiLCJkYXRlQ29sIiwiaG91cnMiLCJkYXRlIiwid2VlayIsImFzc2lnbm1lbnQiLCJwdXNoIiwiaW5kZXgiLCJyYXdEYXRlIiwiV2VlayIsInJhd0hvdXJzIiwiSG91cnMiLCJwYXJzZWRIb3VycyIsInBhcnNlRmxvYXQiLCJza2lsbFNldCIsIlNldCIsImtleSIsImFkZCIsIkFycmF5IiwiZnJvbSIsImVtcCIsInNraWxsIiwidGVhbVNldCIsImV4Y2x1ZGVGaWVsZHMiLCJpbmNsdWRlcyIsInZhbHVlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./lib/excel/parser.ts\n");

/***/ }),

/***/ "(ssr)/./lib/excel/validator.ts":
/*!********************************!*\
  !*** ./lib/excel/validator.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   validateAssignment: () => (/* binding */ validateAssignment),\n/* harmony export */   validateEmployee: () => (/* binding */ validateEmployee),\n/* harmony export */   validateExcelData: () => (/* binding */ validateExcelData),\n/* harmony export */   validateProject: () => (/* binding */ validateProject)\n/* harmony export */ });\n/**\n * Validates employee data from Excel\n */ function validateEmployee(employee, index) {\n    const errors = [];\n    const warnings = [];\n    // Required fields\n    if (!employee.id && !employee.ID && !employee.Name && !employee.name) {\n        errors.push(`Row ${index + 2}: Employee must have an ID or Name`);\n    }\n    // Validate max hours\n    const maxHours = employee['Max Hours'] || employee.maxHours || employee['max hours'];\n    if (maxHours !== undefined) {\n        const hours = Number(maxHours);\n        if (isNaN(hours) || hours < 0) {\n            errors.push(`Row ${index + 2}: Invalid max hours value: ${maxHours}`);\n        } else if (hours > 80) {\n            warnings.push(`Row ${index + 2}: Unusually high max hours: ${hours}`);\n        }\n    }\n    // Validate email format if provided\n    const email = employee.Email || employee.email;\n    if (email && !isValidEmail(email)) {\n        warnings.push(`Row ${index + 2}: Invalid email format: ${email}`);\n    }\n    return {\n        isValid: errors.length === 0,\n        errors,\n        warnings\n    };\n}\n/**\n * Validates project data from Excel\n */ function validateProject(project, index) {\n    const errors = [];\n    const warnings = [];\n    // Required fields\n    if (!project.id && !project.ID && !project.Name && !project.name) {\n        errors.push(`Row ${index + 2}: Project must have an ID or Name`);\n    }\n    // Validate dates\n    const startDate = project['Start Date'] || project.startDate || project['start date'];\n    const endDate = project['End Date'] || project.endDate || project['end date'];\n    if (!startDate) {\n        errors.push(`Row ${index + 2}: Project missing start date`);\n    }\n    if (!endDate) {\n        errors.push(`Row ${index + 2}: Project missing end date`);\n    }\n    if (startDate && endDate) {\n        const start = new Date(startDate);\n        const end = new Date(endDate);\n        if (isNaN(start.getTime())) {\n            errors.push(`Row ${index + 2}: Invalid start date format: ${startDate}`);\n        }\n        if (isNaN(end.getTime())) {\n            errors.push(`Row ${index + 2}: Invalid end date format: ${endDate}`);\n        }\n        if (!isNaN(start.getTime()) && !isNaN(end.getTime()) && start > end) {\n            errors.push(`Row ${index + 2}: Start date is after end date`);\n        }\n        // Warn about projects longer than 2 years\n        if (!isNaN(start.getTime()) && !isNaN(end.getTime())) {\n            const durationDays = (end.getTime() - start.getTime()) / (1000 * 60 * 60 * 24);\n            if (durationDays > 730) {\n                warnings.push(`Row ${index + 2}: Project duration exceeds 2 years`);\n            }\n        }\n    }\n    return {\n        isValid: errors.length === 0,\n        errors,\n        warnings\n    };\n}\n/**\n * Validates assignment data from Excel\n */ function validateAssignment(assignment, index, employees, projects) {\n    const errors = [];\n    const warnings = [];\n    // Check employee reference\n    const employeeRef = assignment['Employee ID'] || assignment.Employee || assignment.employee || assignment.employeeId;\n    if (!employeeRef) {\n        errors.push(`Row ${index + 2}: Assignment missing employee reference`);\n    } else {\n        // Verify employee exists\n        const employeeExists = employees.some((e)=>e.id === employeeRef || e.name === employeeRef);\n        if (!employeeExists) {\n            errors.push(`Row ${index + 2}: Employee not found: ${employeeRef}`);\n        }\n    }\n    // Check project reference\n    const projectRef = assignment['Project ID'] || assignment.Project || assignment.project || assignment.projectId;\n    if (!projectRef) {\n        errors.push(`Row ${index + 2}: Assignment missing project reference`);\n    } else {\n        // Verify project exists\n        const projectExists = projects.some((p)=>p.id === projectRef || p.name === projectRef);\n        if (!projectExists) {\n            errors.push(`Row ${index + 2}: Project not found: ${projectRef}`);\n        }\n    }\n    // Validate hours\n    const hours = assignment.Hours || assignment.hours;\n    if (hours !== undefined && hours !== null && hours !== '') {\n        const hoursNum = Number(hours);\n        if (isNaN(hoursNum) || hoursNum < 0) {\n            errors.push(`Row ${index + 2}: Invalid hours value: ${hours}`);\n        } else if (hoursNum > 60) {\n            warnings.push(`Row ${index + 2}: Unusually high hours for single assignment: ${hoursNum}`);\n        }\n    }\n    // Check for date/week\n    const hasDate = assignment.Week || assignment.Date || assignment.week || assignment.date;\n    if (!hasDate) {\n        warnings.push(`Row ${index + 2}: Assignment missing date/week`);\n    }\n    return {\n        isValid: errors.length === 0,\n        errors,\n        warnings\n    };\n}\n/**\n * Validates the entire Excel data structure\n */ function validateExcelData(data) {\n    const allErrors = [];\n    const allWarnings = [];\n    // Check for required sheets\n    if (!data.employees || data.employees.length === 0) {\n        allErrors.push('No employees found in the Excel file');\n    }\n    if (!data.projects || data.projects.length === 0) {\n        allErrors.push('No projects found in the Excel file');\n    }\n    // Validate individual records\n    if (data.employees) {\n        data.employees.forEach((emp, i)=>{\n            const result = validateEmployee(emp, i);\n            allErrors.push(...result.errors);\n            allWarnings.push(...result.warnings);\n        });\n    }\n    if (data.projects) {\n        data.projects.forEach((proj, i)=>{\n            const result = validateProject(proj, i);\n            allErrors.push(...result.errors);\n            allWarnings.push(...result.warnings);\n        });\n    }\n    // Only validate assignments if we have valid employees and projects\n    if (data.assignments && data.employees && data.projects) {\n        // Convert to typed arrays for validation\n        const typedEmployees = data.employees;\n        const typedProjects = data.projects;\n        data.assignments.forEach((assign, i)=>{\n            const result = validateAssignment(assign, i, typedEmployees, typedProjects);\n            allErrors.push(...result.errors);\n            allWarnings.push(...result.warnings);\n        });\n    }\n    // Check for duplicate employee IDs\n    if (data.employees) {\n        const employeeIds = data.employees.map((e)=>e.id || e.ID || e.name || e.Name).filter(Boolean);\n        const duplicates = findDuplicates(employeeIds);\n        if (duplicates.length > 0) {\n            allWarnings.push(`Duplicate employee IDs found: ${duplicates.join(', ')}`);\n        }\n    }\n    // Check for duplicate project IDs\n    if (data.projects) {\n        const projectIds = data.projects.map((p)=>p.id || p.ID || p.name || p.Name).filter(Boolean);\n        const duplicates = findDuplicates(projectIds);\n        if (duplicates.length > 0) {\n            allWarnings.push(`Duplicate project IDs found: ${duplicates.join(', ')}`);\n        }\n    }\n    return {\n        isValid: allErrors.length === 0,\n        errors: allErrors,\n        warnings: allWarnings\n    };\n}\n/**\n * Helper function to validate email format\n */ function isValidEmail(email) {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n}\n/**\n * Helper function to find duplicates in an array\n */ function findDuplicates(arr) {\n    const seen = new Set();\n    const duplicates = new Set();\n    arr.forEach((item)=>{\n        if (seen.has(item)) {\n            duplicates.add(item);\n        }\n        seen.add(item);\n    });\n    return Array.from(duplicates);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LElBQUlILFdBQVdoRCxNQUFNLEdBQUcsR0FBRztZQUN6QmtDLFlBQVk1QyxJQUFJLENBQUMsQ0FBQyw2QkFBNkIsRUFBRTBELFdBQVdFLElBQUksQ0FBQyxPQUFPO1FBQzFFO0lBQ0Y7SUFFQSxPQUFPO1FBQ0xuRCxTQUFTa0MsVUFBVWpDLE1BQU0sS0FBSztRQUM5QmhCLFFBQVFpRDtRQUNSaEQsVUFBVWlEO0lBQ1o7QUFDRjtBQUVBOztDQUVDLEdBQ0QsU0FBU3BDLGFBQWFGLEtBQWE7SUFDakMsTUFBTXdELGFBQWE7SUFDbkIsT0FBT0EsV0FBV0MsSUFBSSxDQUFDekQ7QUFDekI7QUFFQTs7Q0FFQyxHQUNELFNBQVNxRCxlQUFlSyxHQUFhO0lBQ25DLE1BQU1DLE9BQU8sSUFBSUM7SUFDakIsTUFBTVIsYUFBYSxJQUFJUTtJQUV2QkYsSUFBSW5CLE9BQU8sQ0FBQ3NCLENBQUFBO1FBQ1YsSUFBSUYsS0FBS0csR0FBRyxDQUFDRCxPQUFPO1lBQ2xCVCxXQUFXVyxHQUFHLENBQUNGO1FBQ2pCO1FBQ0FGLEtBQUtJLEdBQUcsQ0FBQ0Y7SUFDWDtJQUVBLE9BQU9HLE1BQU1DLElBQUksQ0FBQ2I7QUFDcEIiLCJzb3VyY2VzIjpbIi9ob21lL3A0NzIvU2NoZWR1bGVyL2xpYi9leGNlbC92YWxpZGF0b3IudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRW1wbG95ZWUsIFByb2plY3QsIEFzc2lnbm1lbnQgfSBmcm9tICdAL3R5cGVzL3NjaGVkdWxlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFZhbGlkYXRpb25SZXN1bHQge1xuICBpc1ZhbGlkOiBib29sZWFuXG4gIGVycm9yczogc3RyaW5nW11cbiAgd2FybmluZ3M6IHN0cmluZ1tdXG59XG5cbi8qKlxuICogVmFsaWRhdGVzIGVtcGxveWVlIGRhdGEgZnJvbSBFeGNlbFxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVFbXBsb3llZShlbXBsb3llZTogYW55LCBpbmRleDogbnVtYmVyKTogVmFsaWRhdGlvblJlc3VsdCB7XG4gIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXVxuICBjb25zdCB3YXJuaW5nczogc3RyaW5nW10gPSBbXVxuICBcbiAgLy8gUmVxdWlyZWQgZmllbGRzXG4gIGlmICghZW1wbG95ZWUuaWQgJiYgIWVtcGxveWVlLklEICYmICFlbXBsb3llZS5OYW1lICYmICFlbXBsb3llZS5uYW1lKSB7XG4gICAgZXJyb3JzLnB1c2goYFJvdyAke2luZGV4ICsgMn06IEVtcGxveWVlIG11c3QgaGF2ZSBhbiBJRCBvciBOYW1lYClcbiAgfVxuICBcbiAgLy8gVmFsaWRhdGUgbWF4IGhvdXJzXG4gIGNvbnN0IG1heEhvdXJzID0gZW1wbG95ZWVbJ01heCBIb3VycyddIHx8IGVtcGxveWVlLm1heEhvdXJzIHx8IGVtcGxveWVlWydtYXggaG91cnMnXVxuICBpZiAobWF4SG91cnMgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGhvdXJzID0gTnVtYmVyKG1heEhvdXJzKVxuICAgIGlmIChpc05hTihob3VycykgfHwgaG91cnMgPCAwKSB7XG4gICAgICBlcnJvcnMucHVzaChgUm93ICR7aW5kZXggKyAyfTogSW52YWxpZCBtYXggaG91cnMgdmFsdWU6ICR7bWF4SG91cnN9YClcbiAgICB9IGVsc2UgaWYgKGhvdXJzID4gODApIHtcbiAgICAgIHdhcm5pbmdzLnB1c2goYFJvdyAke2luZGV4ICsgMn06IFVudXN1YWxseSBoaWdoIG1heCBob3VyczogJHtob3Vyc31gKVxuICAgIH1cbiAgfVxuICBcbiAgLy8gVmFsaWRhdGUgZW1haWwgZm9ybWF0IGlmIHByb3ZpZGVkXG4gIGNvbnN0IGVtYWlsID0gZW1wbG95ZWUuRW1haWwgfHwgZW1wbG95ZWUuZW1haWxcbiAgaWYgKGVtYWlsICYmICFpc1ZhbGlkRW1haWwoZW1haWwpKSB7XG4gICAgd2FybmluZ3MucHVzaChgUm93ICR7aW5kZXggKyAyfTogSW52YWxpZCBlbWFpbCBmb3JtYXQ6ICR7ZW1haWx9YClcbiAgfVxuICBcbiAgcmV0dXJuIHtcbiAgICBpc1ZhbGlkOiBlcnJvcnMubGVuZ3RoID09PSAwLFxuICAgIGVycm9ycyxcbiAgICB3YXJuaW5nc1xuICB9XG59XG5cbi8qKlxuICogVmFsaWRhdGVzIHByb2plY3QgZGF0YSBmcm9tIEV4Y2VsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVByb2plY3QocHJvamVjdDogYW55LCBpbmRleDogbnVtYmVyKTogVmFsaWRhdGlvblJlc3VsdCB7XG4gIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXVxuICBjb25zdCB3YXJuaW5nczogc3RyaW5nW10gPSBbXVxuICBcbiAgLy8gUmVxdWlyZWQgZmllbGRzXG4gIGlmICghcHJvamVjdC5pZCAmJiAhcHJvamVjdC5JRCAmJiAhcHJvamVjdC5OYW1lICYmICFwcm9qZWN0Lm5hbWUpIHtcbiAgICBlcnJvcnMucHVzaChgUm93ICR7aW5kZXggKyAyfTogUHJvamVjdCBtdXN0IGhhdmUgYW4gSUQgb3IgTmFtZWApXG4gIH1cbiAgXG4gIC8vIFZhbGlkYXRlIGRhdGVzXG4gIGNvbnN0IHN0YXJ0RGF0ZSA9IHByb2plY3RbJ1N0YXJ0IERhdGUnXSB8fCBwcm9qZWN0LnN0YXJ0RGF0ZSB8fCBwcm9qZWN0WydzdGFydCBkYXRlJ11cbiAgY29uc3QgZW5kRGF0ZSA9IHByb2plY3RbJ0VuZCBEYXRlJ10gfHwgcHJvamVjdC5lbmREYXRlIHx8IHByb2plY3RbJ2VuZCBkYXRlJ11cbiAgXG4gIGlmICghc3RhcnREYXRlKSB7XG4gICAgZXJyb3JzLnB1c2goYFJvdyAke2luZGV4ICsgMn06IFByb2plY3QgbWlzc2luZyBzdGFydCBkYXRlYClcbiAgfVxuICBcbiAgaWYgKCFlbmREYXRlKSB7XG4gICAgZXJyb3JzLnB1c2goYFJvdyAke2luZGV4ICsgMn06IFByb2plY3QgbWlzc2luZyBlbmQgZGF0ZWApXG4gIH1cbiAgXG4gIGlmIChzdGFydERhdGUgJiYgZW5kRGF0ZSkge1xuICAgIGNvbnN0IHN0YXJ0ID0gbmV3IERhdGUoc3RhcnREYXRlKVxuICAgIGNvbnN0IGVuZCA9IG5ldyBEYXRlKGVuZERhdGUpXG4gICAgXG4gICAgaWYgKGlzTmFOKHN0YXJ0LmdldFRpbWUoKSkpIHtcbiAgICAgIGVycm9ycy5wdXNoKGBSb3cgJHtpbmRleCArIDJ9OiBJbnZhbGlkIHN0YXJ0IGRhdGUgZm9ybWF0OiAke3N0YXJ0RGF0ZX1gKVxuICAgIH1cbiAgICBcbiAgICBpZiAoaXNOYU4oZW5kLmdldFRpbWUoKSkpIHtcbiAgICAgIGVycm9ycy5wdXNoKGBSb3cgJHtpbmRleCArIDJ9OiBJbnZhbGlkIGVuZCBkYXRlIGZvcm1hdDogJHtlbmREYXRlfWApXG4gICAgfVxuICAgIFxuICAgIGlmICghaXNOYU4oc3RhcnQuZ2V0VGltZSgpKSAmJiAhaXNOYU4oZW5kLmdldFRpbWUoKSkgJiYgc3RhcnQgPiBlbmQpIHtcbiAgICAgIGVycm9ycy5wdXNoKGBSb3cgJHtpbmRleCArIDJ9OiBTdGFydCBkYXRlIGlzIGFmdGVyIGVuZCBkYXRlYClcbiAgICB9XG4gICAgXG4gICAgLy8gV2FybiBhYm91dCBwcm9qZWN0cyBsb25nZXIgdGhhbiAyIHllYXJzXG4gICAgaWYgKCFpc05hTihzdGFydC5nZXRUaW1lKCkpICYmICFpc05hTihlbmQuZ2V0VGltZSgpKSkge1xuICAgICAgY29uc3QgZHVyYXRpb25EYXlzID0gKGVuZC5nZXRUaW1lKCkgLSBzdGFydC5nZXRUaW1lKCkpIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpXG4gICAgICBpZiAoZHVyYXRpb25EYXlzID4gNzMwKSB7XG4gICAgICAgIHdhcm5pbmdzLnB1c2goYFJvdyAke2luZGV4ICsgMn06IFByb2plY3QgZHVyYXRpb24gZXhjZWVkcyAyIHllYXJzYClcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIHJldHVybiB7XG4gICAgaXNWYWxpZDogZXJyb3JzLmxlbmd0aCA9PT0gMCxcbiAgICBlcnJvcnMsXG4gICAgd2FybmluZ3NcbiAgfVxufVxuXG4vKipcbiAqIFZhbGlkYXRlcyBhc3NpZ25tZW50IGRhdGEgZnJvbSBFeGNlbFxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVBc3NpZ25tZW50KGFzc2lnbm1lbnQ6IGFueSwgaW5kZXg6IG51bWJlciwgZW1wbG95ZWVzOiBFbXBsb3llZVtdLCBwcm9qZWN0czogUHJvamVjdFtdKTogVmFsaWRhdGlvblJlc3VsdCB7XG4gIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXVxuICBjb25zdCB3YXJuaW5nczogc3RyaW5nW10gPSBbXVxuICBcbiAgLy8gQ2hlY2sgZW1wbG95ZWUgcmVmZXJlbmNlXG4gIGNvbnN0IGVtcGxveWVlUmVmID0gYXNzaWdubWVudFsnRW1wbG95ZWUgSUQnXSB8fCBhc3NpZ25tZW50LkVtcGxveWVlIHx8IGFzc2lnbm1lbnQuZW1wbG95ZWUgfHwgYXNzaWdubWVudC5lbXBsb3llZUlkXG4gIGlmICghZW1wbG95ZWVSZWYpIHtcbiAgICBlcnJvcnMucHVzaChgUm93ICR7aW5kZXggKyAyfTogQXNzaWdubWVudCBtaXNzaW5nIGVtcGxveWVlIHJlZmVyZW5jZWApXG4gIH0gZWxzZSB7XG4gICAgLy8gVmVyaWZ5IGVtcGxveWVlIGV4aXN0c1xuICAgIGNvbnN0IGVtcGxveWVlRXhpc3RzID0gZW1wbG95ZWVzLnNvbWUoZSA9PiBcbiAgICAgIGUuaWQgPT09IGVtcGxveWVlUmVmIHx8IGUubmFtZSA9PT0gZW1wbG95ZWVSZWZcbiAgICApXG4gICAgaWYgKCFlbXBsb3llZUV4aXN0cykge1xuICAgICAgZXJyb3JzLnB1c2goYFJvdyAke2luZGV4ICsgMn06IEVtcGxveWVlIG5vdCBmb3VuZDogJHtlbXBsb3llZVJlZn1gKVxuICAgIH1cbiAgfVxuICBcbiAgLy8gQ2hlY2sgcHJvamVjdCByZWZlcmVuY2VcbiAgY29uc3QgcHJvamVjdFJlZiA9IGFzc2lnbm1lbnRbJ1Byb2plY3QgSUQnXSB8fCBhc3NpZ25tZW50LlByb2plY3QgfHwgYXNzaWdubWVudC5wcm9qZWN0IHx8IGFzc2lnbm1lbnQucHJvamVjdElkXG4gIGlmICghcHJvamVjdFJlZikge1xuICAgIGVycm9ycy5wdXNoKGBSb3cgJHtpbmRleCArIDJ9OiBBc3NpZ25tZW50IG1pc3NpbmcgcHJvamVjdCByZWZlcmVuY2VgKVxuICB9IGVsc2Uge1xuICAgIC8vIFZlcmlmeSBwcm9qZWN0IGV4aXN0c1xuICAgIGNvbnN0IHByb2plY3RFeGlzdHMgPSBwcm9qZWN0cy5zb21lKHAgPT4gXG4gICAgICBwLmlkID09PSBwcm9qZWN0UmVmIHx8IHAubmFtZSA9PT0gcHJvamVjdFJlZlxuICAgIClcbiAgICBpZiAoIXByb2plY3RFeGlzdHMpIHtcbiAgICAgIGVycm9ycy5wdXNoKGBSb3cgJHtpbmRleCArIDJ9OiBQcm9qZWN0IG5vdCBmb3VuZDogJHtwcm9qZWN0UmVmfWApXG4gICAgfVxuICB9XG4gIFxuICAvLyBWYWxpZGF0ZSBob3Vyc1xuICBjb25zdCBob3VycyA9IGFzc2lnbm1lbnQuSG91cnMgfHwgYXNzaWdubWVudC5ob3Vyc1xuICBpZiAoaG91cnMgIT09IHVuZGVmaW5lZCAmJiBob3VycyAhPT0gbnVsbCAmJiBob3VycyAhPT0gJycpIHtcbiAgICBjb25zdCBob3Vyc051bSA9IE51bWJlcihob3VycylcbiAgICBpZiAoaXNOYU4oaG91cnNOdW0pIHx8IGhvdXJzTnVtIDwgMCkge1xuICAgICAgZXJyb3JzLnB1c2goYFJvdyAke2luZGV4ICsgMn06IEludmFsaWQgaG91cnMgdmFsdWU6ICR7aG91cnN9YClcbiAgICB9IGVsc2UgaWYgKGhvdXJzTnVtID4gNjApIHtcbiAgICAgIHdhcm5pbmdzLnB1c2goYFJvdyAke2luZGV4ICsgMn06IFVudXN1YWxseSBoaWdoIGhvdXJzIGZvciBzaW5nbGUgYXNzaWdubWVudDogJHtob3Vyc051bX1gKVxuICAgIH1cbiAgfVxuICBcbiAgLy8gQ2hlY2sgZm9yIGRhdGUvd2Vla1xuICBjb25zdCBoYXNEYXRlID0gYXNzaWdubWVudC5XZWVrIHx8IGFzc2lnbm1lbnQuRGF0ZSB8fCBhc3NpZ25tZW50LndlZWsgfHwgYXNzaWdubWVudC5kYXRlXG4gIGlmICghaGFzRGF0ZSkge1xuICAgIHdhcm5pbmdzLnB1c2goYFJvdyAke2luZGV4ICsgMn06IEFzc2lnbm1lbnQgbWlzc2luZyBkYXRlL3dlZWtgKVxuICB9XG4gIFxuICByZXR1cm4ge1xuICAgIGlzVmFsaWQ6IGVycm9ycy5sZW5ndGggPT09IDAsXG4gICAgZXJyb3JzLFxuICAgIHdhcm5pbmdzXG4gIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZXMgdGhlIGVudGlyZSBFeGNlbCBkYXRhIHN0cnVjdHVyZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVFeGNlbERhdGEoZGF0YToge1xuICBlbXBsb3llZXM6IGFueVtdXG4gIHByb2plY3RzOiBhbnlbXVxuICBhc3NpZ25tZW50czogYW55W11cbn0pOiBWYWxpZGF0aW9uUmVzdWx0IHtcbiAgY29uc3QgYWxsRXJyb3JzOiBzdHJpbmdbXSA9IFtdXG4gIGNvbnN0IGFsbFdhcm5pbmdzOiBzdHJpbmdbXSA9IFtdXG4gIFxuICAvLyBDaGVjayBmb3IgcmVxdWlyZWQgc2hlZXRzXG4gIGlmICghZGF0YS5lbXBsb3llZXMgfHwgZGF0YS5lbXBsb3llZXMubGVuZ3RoID09PSAwKSB7XG4gICAgYWxsRXJyb3JzLnB1c2goJ05vIGVtcGxveWVlcyBmb3VuZCBpbiB0aGUgRXhjZWwgZmlsZScpXG4gIH1cbiAgXG4gIGlmICghZGF0YS5wcm9qZWN0cyB8fCBkYXRhLnByb2plY3RzLmxlbmd0aCA9PT0gMCkge1xuICAgIGFsbEVycm9ycy5wdXNoKCdObyBwcm9qZWN0cyBmb3VuZCBpbiB0aGUgRXhjZWwgZmlsZScpXG4gIH1cbiAgXG4gIC8vIFZhbGlkYXRlIGluZGl2aWR1YWwgcmVjb3Jkc1xuICBpZiAoZGF0YS5lbXBsb3llZXMpIHtcbiAgICBkYXRhLmVtcGxveWVlcy5mb3JFYWNoKChlbXAsIGkpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlRW1wbG95ZWUoZW1wLCBpKVxuICAgICAgYWxsRXJyb3JzLnB1c2goLi4ucmVzdWx0LmVycm9ycylcbiAgICAgIGFsbFdhcm5pbmdzLnB1c2goLi4ucmVzdWx0Lndhcm5pbmdzKVxuICAgIH0pXG4gIH1cbiAgXG4gIGlmIChkYXRhLnByb2plY3RzKSB7XG4gICAgZGF0YS5wcm9qZWN0cy5mb3JFYWNoKChwcm9qLCBpKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZVByb2plY3QocHJvaiwgaSlcbiAgICAgIGFsbEVycm9ycy5wdXNoKC4uLnJlc3VsdC5lcnJvcnMpXG4gICAgICBhbGxXYXJuaW5ncy5wdXNoKC4uLnJlc3VsdC53YXJuaW5ncylcbiAgICB9KVxuICB9XG4gIFxuICAvLyBPbmx5IHZhbGlkYXRlIGFzc2lnbm1lbnRzIGlmIHdlIGhhdmUgdmFsaWQgZW1wbG95ZWVzIGFuZCBwcm9qZWN0c1xuICBpZiAoZGF0YS5hc3NpZ25tZW50cyAmJiBkYXRhLmVtcGxveWVlcyAmJiBkYXRhLnByb2plY3RzKSB7XG4gICAgLy8gQ29udmVydCB0byB0eXBlZCBhcnJheXMgZm9yIHZhbGlkYXRpb25cbiAgICBjb25zdCB0eXBlZEVtcGxveWVlcyA9IGRhdGEuZW1wbG95ZWVzIGFzIEVtcGxveWVlW11cbiAgICBjb25zdCB0eXBlZFByb2plY3RzID0gZGF0YS5wcm9qZWN0cyBhcyBQcm9qZWN0W11cbiAgICBcbiAgICBkYXRhLmFzc2lnbm1lbnRzLmZvckVhY2goKGFzc2lnbiwgaSkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGVBc3NpZ25tZW50KGFzc2lnbiwgaSwgdHlwZWRFbXBsb3llZXMsIHR5cGVkUHJvamVjdHMpXG4gICAgICBhbGxFcnJvcnMucHVzaCguLi5yZXN1bHQuZXJyb3JzKVxuICAgICAgYWxsV2FybmluZ3MucHVzaCguLi5yZXN1bHQud2FybmluZ3MpXG4gICAgfSlcbiAgfVxuICBcbiAgLy8gQ2hlY2sgZm9yIGR1cGxpY2F0ZSBlbXBsb3llZSBJRHNcbiAgaWYgKGRhdGEuZW1wbG95ZWVzKSB7XG4gICAgY29uc3QgZW1wbG95ZWVJZHMgPSBkYXRhLmVtcGxveWVlc1xuICAgICAgLm1hcChlID0+IGUuaWQgfHwgZS5JRCB8fCBlLm5hbWUgfHwgZS5OYW1lKVxuICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgIGNvbnN0IGR1cGxpY2F0ZXMgPSBmaW5kRHVwbGljYXRlcyhlbXBsb3llZUlkcylcbiAgICBpZiAoZHVwbGljYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICBhbGxXYXJuaW5ncy5wdXNoKGBEdXBsaWNhdGUgZW1wbG95ZWUgSURzIGZvdW5kOiAke2R1cGxpY2F0ZXMuam9pbignLCAnKX1gKVxuICAgIH1cbiAgfVxuICBcbiAgLy8gQ2hlY2sgZm9yIGR1cGxpY2F0ZSBwcm9qZWN0IElEc1xuICBpZiAoZGF0YS5wcm9qZWN0cykge1xuICAgIGNvbnN0IHByb2plY3RJZHMgPSBkYXRhLnByb2plY3RzXG4gICAgICAubWFwKHAgPT4gcC5pZCB8fCBwLklEIHx8IHAubmFtZSB8fCBwLk5hbWUpXG4gICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgY29uc3QgZHVwbGljYXRlcyA9IGZpbmREdXBsaWNhdGVzKHByb2plY3RJZHMpXG4gICAgaWYgKGR1cGxpY2F0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgYWxsV2FybmluZ3MucHVzaChgRHVwbGljYXRlIHByb2plY3QgSURzIGZvdW5kOiAke2R1cGxpY2F0ZXMuam9pbignLCAnKX1gKVxuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIHtcbiAgICBpc1ZhbGlkOiBhbGxFcnJvcnMubGVuZ3RoID09PSAwLFxuICAgIGVycm9yczogYWxsRXJyb3JzLFxuICAgIHdhcm5pbmdzOiBhbGxXYXJuaW5nc1xuICB9XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIHZhbGlkYXRlIGVtYWlsIGZvcm1hdFxuICovXG5mdW5jdGlvbiBpc1ZhbGlkRW1haWwoZW1haWw6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBjb25zdCBlbWFpbFJlZ2V4ID0gL15bXlxcc0BdK0BbXlxcc0BdK1xcLlteXFxzQF0rJC9cbiAgcmV0dXJuIGVtYWlsUmVnZXgudGVzdChlbWFpbClcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZmluZCBkdXBsaWNhdGVzIGluIGFuIGFycmF5XG4gKi9cbmZ1bmN0aW9uIGZpbmREdXBsaWNhdGVzKGFycjogc3RyaW5nW10pOiBzdHJpbmdbXSB7XG4gIGNvbnN0IHNlZW4gPSBuZXcgU2V0PHN0cmluZz4oKVxuICBjb25zdCBkdXBsaWNhdGVzID0gbmV3IFNldDxzdHJpbmc+KClcbiAgXG4gIGFyci5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgIGlmIChzZWVuLmhhcyhpdGVtKSkge1xuICAgICAgZHVwbGljYXRlcy5hZGQoaXRlbSlcbiAgICB9XG4gICAgc2Vlbi5hZGQoaXRlbSlcbiAgfSlcbiAgXG4gIHJldHVybiBBcnJheS5mcm9tKGR1cGxpY2F0ZXMpXG59Il0sIm5hbWVzIjpbInZhbGlkYXRlRW1wbG95ZWUiLCJlbXBsb3llZSIsImluZGV4IiwiZXJyb3JzIiwid2FybmluZ3MiLCJpZCIsIklEIiwiTmFtZSIsIm5hbWUiLCJwdXNoIiwibWF4SG91cnMiLCJ1bmRlZmluZWQiLCJob3VycyIsIk51bWJlciIsImlzTmFOIiwiZW1haWwiLCJFbWFpbCIsImlzVmFsaWRFbWFpbCIsImlzVmFsaWQiLCJsZW5ndGgiLCJ2YWxpZGF0ZVByb2plY3QiLCJwcm9qZWN0Iiwic3RhcnREYXRlIiwiZW5kRGF0ZSIsInN0YXJ0IiwiRGF0ZSIsImVuZCIsImdldFRpbWUiLCJkdXJhdGlvbkRheXMiLCJ2YWxpZGF0ZUFzc2lnbm1lbnQiLCJhc3NpZ25tZW50IiwiZW1wbG95ZWVzIiwicHJvamVjdHMiLCJlbXBsb3llZVJlZiIsIkVtcGxveWVlIiwiZW1wbG95ZWVJZCIsImVtcGxveWVlRXhpc3RzIiwic29tZSIsImUiLCJwcm9qZWN0UmVmIiwiUHJvamVjdCIsInByb2plY3RJZCIsInByb2plY3RFeGlzdHMiLCJwIiwiSG91cnMiLCJob3Vyc051bSIsImhhc0RhdGUiLCJXZWVrIiwid2VlayIsImRhdGUiLCJ2YWxpZGF0ZUV4Y2VsRGF0YSIsImRhdGEiLCJhbGxFcnJvcnMiLCJhbGxXYXJuaW5ncyIsImZvckVhY2giLCJlbXAiLCJpIiwicmVzdWx0IiwicHJvaiIsImFzc2lnbm1lbnRzIiwidHlwZWRFbXBsb3llZXMiLCJ0eXBlZFByb2plY3RzIiwiYXNzaWduIiwiZW1wbG95ZWVJZHMiLCJtYXAiLCJmaWx0ZXIiLCJCb29sZWFuIiwiZHVwbGljYXRlcyIsImZpbmREdXBsaWNhdGVzIiwiam9pbiIsInByb2plY3RJZHMiLCJlbWFpbFJlZ2V4IiwidGVzdCIsImFyciIsInNlZW4iLCJTZXQiLCJpdGVtIiwiaGFzIiwiYWRkIiwiQXJyYXkiLCJmcm9tIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./lib/excel/validator.ts\n");

/***/ })

};
;